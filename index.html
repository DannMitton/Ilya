<!DOCTYPE html>
<html lang="ru" translate="no">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google" content="notranslate">
  <title>Ilya — v6.0.86 CSS dead class removal (C.8)</title>
  
  <!-- Favicon: simple И in terracotta circle -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23a85a3a'/><text x='50' y='68' font-size='50' fill='white' text-anchor='middle' font-family='serif'>И</text></svg>">
  
  <!-- Noto Serif for all text -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500&family=Noto+Serif:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
  
  <!-- Pako library for gzip decompression -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  
  <style>
    /* CALM AUTHORITY PALETTE v5.2 — Kimi Design System — Muted Sage Edition */
    :root {
      /* Core Palette */
      --ilya-paper: #ffffff;
      --ilya-parchment: #fafafa;
      --ilya-binding: #f5f5f0;
      --ilya-binding-dark: #ebebe5;
      
      /* Legacy aliases (for backward compatibility) */
      --paper: #faf6f0;
      --surface: #ffffff;
      
      /* Typography Colors */
      --ilya-text-primary: #2c3e50;
      --ilya-text-secondary: #5a6c7d;
      --ilya-text-muted: #7f8c8d;
      --ilya-text-caption: #95a5a6;
      
      /* Legacy ink aliases */
      --ink-primary: #1a1612;
      --ink-secondary: #4a4540;
      
      /* Ilya Stationery Palette (v5.9.6) */
      --stationery-cream: #F8F5F0;        /* Warm aged manuscript */
      --stationery-ink: #1A1612;          /* Rich black, not pure */
      --stationery-accent: #8B9A7D;       /* Sage green - primary accent */
      --stationery-sage: #8B9A7D;         /* Alias for clarity */
      --stationery-watermark: rgba(139, 154, 125, 0.06); /* Faint sage */
      
      /* Borders & Focus */
      --ilya-border-light: #e8e8e8;
      --ilya-border: #e0e0e0;
      --ilya-border-focus: #7a9e7e;
      
      /* Unverified/Inferred State (v5.11.32) */
      --color-muted-border: #c4c4bc;
      --color-muted-text: #6b6b6b;
      
      /* Functional Colors — Muted Sage Accent */
      --ilya-accent: #7a9e7e;
      --ilya-accent-light: rgba(122, 158, 126, 0.1);
      --ilya-accent-hover: #6b8e6f;
      
      /* Legacy accent aliases (terracotta for existing components) */
      --accent: #a85a3a;
      --accent-muted: rgba(168, 90, 58, 0.75);
      
      /* Status Colors */
      --ilya-warning: #d4a373;
      
      /* Fonts */
      --font-mono: 'Courier New', 'Consolas', monospace;
      --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-ipa: 'Doulos SIL', 'Charis SIL', 'Gentium', 'Noto Serif', 'Times New Roman', serif;
      
      /* Paper dimensions (v5.8.2) */
      /* Letter: 8.5in × 11in at 96dpi = 816px × 1056px */
      /* A4: 210mm × 297mm at 96dpi ≈ 794px × 1123px */
      --paper-width: 816px;
      --paper-height: 1056px;
      --paper-aspect: 8.5 / 11;
      
      /* Shadows */
      --ilya-shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      
      /* Legacy shadow aliases */
      --shadow-ambient: 0 1px 2px rgba(26, 22, 18, 0.08);
      --shadow-card: 0 2px 8px rgba(26, 22, 18, 0.1);
      --shadow-paper: 0 2px 12px rgba(26, 22, 18, 0.08);
      
      /* Document Container */
      --ilya-doc-radius: 16px;
      --ilya-doc-border: 2px solid var(--ilya-border);
      --ilya-doc-shadow: 0 4px 20px rgba(0,0,0,0.05);
      
      /* Spacing Scale (8px base) */
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      
      /* Typography Scale */
      --text-xs: 12px;
      --text-sm: 14px;
      --text-base: 16px;
      
      /* Animation Timing */
      --duration-fast: 150ms;
      --duration-base: 300ms;
      --ease-out: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      
      /* Legacy */
      --radius: 6px;
      --ease: cubic-bezier(0.34, 0, 0.2, 1);
      --drawer-handle-height: 36px;
    }

    /* RESET & BASE */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans', system-ui, sans-serif;
      background-color: #e8e4de;
      color: var(--ink-primary);
      line-height: 1.6;
      min-height: 100vh;
      overflow: hidden;
    }

    /* UNIFIED FOCUS SYSTEM — All interactive elements use 2px sage outline */
    :focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    :focus:not(:focus-visible) {
      outline: none;
    }
    
    :focus-visible {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    /* Form elements use border + box-shadow instead of outline */
    input:focus,
    textarea:focus,
    select:focus,
    [contenteditable]:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    input:focus:not(:focus-visible),
    textarea:focus:not(:focus-visible),
    select:focus:not(:focus-visible),
    [contenteditable]:focus:not(:focus-visible) {
      box-shadow: none;
      border-color: var(--ilya-border);
    }

    /* DISPLAY CONTAINER: Main app layout */
    .ilya-layout {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    /* DRAWER: Left-side workbench (v6.0) — During transition: position fixed to avoid breaking — existing column layout. Converts to flex sibling — when old input-drawer is removed in Phase 2. */
    .ilya-drawer {
      position: fixed;
      left: 0;
      top: 0;
      width: 360px;
      min-width: 320px;
      max-width: 400px;
      height: 100vh;
      background: var(--surface);
      border-right: 1px solid rgba(26, 22, 18, 0.08);
      box-shadow: 4px 0 24px rgba(0, 0, 0, 0.05);
      overflow: hidden;
      transform: translateX(-100%);
      transition: transform 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
      z-index: 10;
      display: flex;
      flex-direction: column;
    }

    .ilya-drawer[data-state="open"] {
      transform: translateX(0);
    }

    /* Drawer internal layout */
    .drawer-header {
      flex-shrink: 0;
      padding: var(--space-lg) var(--space-lg) var(--space-md);
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .drawer-title {
      display: inline-block;
      width: 80px;
      height: 28px;
    }
    .drawer-title svg {
      display: block;
      width: 100%;
      height: 100%;
    }

    .drawer-section-label {
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--ilya-text-secondary);
      margin-bottom: var(--space-md);
      margin-top: var(--space-lg);
    }

    .drawer-section-label:first-child {
      margin-top: 0;
    }

    .drawer-body {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-lg);
      background: var(--ilya-binding);
    }

    /* Breath animation: language swap (v6.0.54, Kimi spec)
       150ms fade-out + lift, 250ms fade-in + settle. Total 400ms.
       Header stays still. Applied to drawer-body, inspector-body, paper-stack. */
    .breath-out {
      animation: breathOut 150ms cubic-bezier(0.25, 0.1, 0.25, 1.0) forwards;
    }
    .breath-in {
      animation: breathIn 250ms cubic-bezier(0.25, 0.1, 0.25, 1.0) forwards;
    }
    @keyframes breathOut {
      from { opacity: 1; transform: translateY(0); }
      to   { opacity: 0; transform: translateY(-2px); }
    }
    @keyframes breathIn {
      from { opacity: 0; transform: translateY(-2px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    /* WELCOME PREFACE (First-run name collection) — Shows once on first drawer open, then never returns */
    .welcome-preface {
      margin-bottom: var(--space-lg);
      padding-bottom: var(--space-lg);
      border-bottom: 1px solid var(--ilya-border-light);
    }
    
    .welcome-preface.hidden {
      display: none;
    }
    
    .preface-text {
      font-size: 0.95em;
      letter-spacing: 0.01em;
      color: var(--ilya-text-secondary);
      line-height: 1.5;
      margin: 0 0 var(--space-md) 0;
    }
    
    .preface-field {
      margin-bottom: var(--space-md);
    }
    
    .preface-field input {
      width: 100%;
      padding: 10px 12px;
      font-size: 0.95rem;
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      background: var(--surface);
      color: var(--ink-primary);
    }
    
    .preface-field input:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .preface-field input::placeholder {
      color: var(--ilya-text-muted);
    }
    
    .preface-actions {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    
    .preface-actions .btn-primary {
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 500;
      color: white;
      background: var(--ilya-accent);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 150ms ease;
    }
    
    .preface-actions .btn-primary:hover {
      background: var(--ilya-accent-hover);
    }
    
    .preface-actions .link-secondary {
      font-size: 0.9rem;
      color: var(--ilya-text-muted);
      text-decoration: none;
      cursor: pointer;
      transition: color 150ms ease;
    }
    
    .preface-actions .link-secondary:hover {
      color: var(--ilya-text-secondary);
    }

    /* Internal state containers */
    .drawer-root,
    .drawer-inspector {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition: transform 200ms ease, opacity 200ms ease, visibility 200ms;
      pointer-events: none;
    }

    /* Root state visible */
    .ilya-drawer[data-mode="root"] .drawer-root {
      transform: translateX(0);
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .ilya-drawer[data-mode="root"] .drawer-inspector {
      transform: translateX(20px);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Drill/inspect state visible */
    .ilya-drawer[data-mode="inspect"] .drawer-root {
      transform: translateX(-20px);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .ilya-drawer[data-mode="inspect"] .drawer-inspector {
      transform: translateX(0);
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    /* Inspector Header (Phase 3A) */
    .inspector-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      border-bottom: 1px solid var(--ilya-border-light);
      background: var(--surface);
    }

    .inspector-header .back-btn {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      background: var(--surface);
      color: var(--ilya-text-secondary);
      font-size: 18px;
      cursor: pointer;
      transition: all 150ms ease;
      flex-shrink: 0;
    }

    .inspector-header .back-btn:hover {
      background: var(--ilya-binding);
      border-color: var(--ilya-border-focus);
      color: var(--ilya-text-primary);
    }

    .inspector-header .inspector-word {
      font-family: 'Noto Serif', serif;
      font-size: 1.25rem;
      font-weight: 500;
      color: var(--ilya-text-primary);
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Inspector Body (Phase 3B) */
    .inspector-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }

    /* Syllable Label (monosyllable/clitic context) */
    .inspector-syllable-label {
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--ilya-text-secondary);
      text-align: left;
      align-self: flex-start;
      margin-bottom: 8px;
    }

    .inspector-syllable-label:empty {
      display: none;
    }

    /* Syllable Buttons Container */
    .inspector-syllable-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      margin-bottom: 12px;
    }

    .inspector-syllable-display {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    /* Syllable buttons in drawer - reuse existing .syllable-btn styles */
    .inspector-syllable-display .syllable-btn {
      font-family: var(--font-ipa);
      font-size: 1.1rem;
      padding: 8px 12px;
    }

    .yo-lock-message {
      font-size: 0.78rem;
      color: var(--ilya-accent);
      opacity: 0;
      max-height: 0;
      overflow: hidden;
      transition: opacity 200ms var(--ease), max-height 200ms var(--ease);
      padding: 0;
    }
    
    .yo-lock-message.visible {
      opacity: 1;
      max-height: 2em;
      padding: 2px 0 4px;
    }

    /* Boundary reset button in drawer */
    .inspector-syllable-header .boundary-reset-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      border: 1px solid var(--ilya-border);
      border-radius: 4px;
      background: var(--surface);
      color: var(--ilya-text-muted);
      cursor: pointer;
      transition: all 150ms ease;
      margin-left: 8px;
    }

    .inspector-syllable-header .boundary-reset-btn:hover {
      background: var(--ilya-binding);
      border-color: var(--ilya-accent);
      color: var(--ilya-text-primary);
    }

    /* Cyrillic Display */
    .inspector-cyrillic {
      font-family: 'Noto Serif', serif;
      font-size: 1.25rem;
      font-weight: 500;
      color: var(--ink-primary);
      text-align: center;
      margin-bottom: 12px;
    }

    /* Gloss Section */
    .inspector-gloss-section {
      text-align: center;
      margin-bottom: 8px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--ilya-border-light);
    }

    .inspector-gloss-inline {
      font-family: 'Noto Serif', serif;
      font-size: 0.95rem;
      font-style: italic;
      color: var(--ilya-accent);
      padding: 8px 16px;
      border-radius: 6px;
      display: inline-block;
      min-width: 120px;
      background-color: var(--ilya-accent-light);
      border: none;
      transition: all 150ms var(--ease);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px);
      background-size:
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position:
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:hover {
      background-color: rgba(122, 158, 126, 0.15);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px);
      background-size:
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position:
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:focus {
      outline: none;
      background-color: rgba(122, 158, 126, 0.15);
      border: 2px solid var(--ilya-accent);
      background-image: none;
      box-shadow: 0 0 0 2px var(--ilya-accent-light);
    }

    .inspector-gloss-inline:not(:empty) {
      background: transparent;
      border-color: transparent;
      color: var(--ilya-accent);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px);
      background-size: 100% 2px;
      background-position: 0 100%;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:not(:empty):hover {
      background-color: var(--ilya-accent-light);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px);
      background-size: 100% 2px;
      background-position: 0 100%;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:empty::before {
      content: attr(data-placeholder);
      color: var(--ilya-accent);
      opacity: 0.7;
      font-style: italic;
    }

    /* Ribbon Section (Phase 3C) */
    /* REFINEMENTS v6.0.18: Fixes from testing */
    .inspector-ribbon-section {
      margin-bottom: 16px;
    }

    /* Drawer ribbon inherits .ribbon-vertical styles but needs drawer-specific adjustments */
    .inspector-ribbon.ribbon-vertical {
      padding: 0;
      border-radius: 8px;
      background: var(--ilya-binding);
    }

    /* Refinement 1: Condensed row spacing - 48px height, hairline separators */
    .inspector-ribbon .phoneme-row {
      min-height: 48px;
      padding: 0 12px;
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
    }

    .inspector-ribbon .phoneme-row:last-child {
      border-bottom: none;
    }

    /* Refinement 3: Remove fading - trust user attention */
    /* Higher specificity to override base .ribbon-vertical rules */
    .inspector-ribbon.ribbon-vertical.has-active-blurb .phoneme-row:not(.expanded),
    .inspector-ribbon.ribbon-vertical .phoneme-row:not(.expanded),
    .inspector-ribbon .phoneme-row:not(.expanded) {
      opacity: 1 !important;
    }
    
    /* Remove sage background from expanded rows in drawer */
    /* NO PERIMETER on expanded rows - perimeters are ONLY for stressed syllables */
    #ilyaDrawer .inspector-ribbon .phoneme-row.expanded,
    .ilya-drawer .inspector-ribbon .phoneme-row.expanded,
    .inspector-ribbon .phoneme-row.expanded,
    .inspector-ribbon.ribbon-vertical .phoneme-row.expanded {
      background: transparent !important;
      border: none !important;
      border-width: 0 !important;
      outline: none !important;
      box-shadow: none !important;
    }
    
    /* Remove focus outline from rows inside drawer - prevents nested perimeters */
    .inspector-ribbon .phoneme-row:focus,
    .inspector-ribbon .phoneme-row.expanded:focus {
      outline: none !important;
    }

    /* Refinement 2: Blurb simplification - HIDDEN by default, NO PERIMETER */
    /* RULE: Perimeters identify STRESSED SYLLABLES only. Blurbs have NO border. */
    /* Override all base overlay styles for drawer context */
    /* Using maximum specificity to ensure override */
    #ilyaDrawer .inspector-ribbon .phoneme-blurb-overlay,
    .ilya-drawer .inspector-ribbon .phoneme-blurb-overlay,
    .inspector-ribbon .phoneme-blurb-overlay {
      position: relative !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      max-height: 0 !important;
      overflow: hidden !important;
      background: transparent !important;
      border: none !important;
      border-width: 0 !important;
      border-style: none !important;
      outline: none !important;
      box-shadow: none !important;
      padding: 12px 0 8px 48px !important; /* Set immediately - no transition */
      margin: 0 !important;
      opacity: 0 !important;
      visibility: hidden !important;
      transform: none !important;
      pointer-events: none !important;
      min-height: 0 !important;
      z-index: auto !important;
      border-radius: 0 !important;
      /* Collapse: fast */
      transition: max-height 200ms ease-in,
                  opacity 150ms ease,
                  visibility 0ms linear 200ms,
                  margin 200ms ease-in !important;
    }

    /* Expanded blurb - soft, welcoming fade-in after row fully expands */
    /* Phase 3C timing: 350ms expand, 400ms fade starting at 300ms */
    #ilyaDrawer .inspector-ribbon .phoneme-row.expanded .phoneme-blurb-overlay,
    .ilya-drawer .inspector-ribbon .phoneme-row.expanded .phoneme-blurb-overlay,
    .inspector-ribbon .phoneme-row.expanded .phoneme-blurb-overlay {
      max-height: 800px !important;
      margin-top: 4px !important;
      background: transparent !important;
      border: none !important;
      border-width: 0 !important;
      border-style: none !important;
      outline: none !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
      overflow-y: auto !important;
      /* Phase 3C approved: 350ms stately expand, 400ms fade starting at 300ms */
      transition: max-height 350ms cubic-bezier(0.25, 0.46, 0.45, 0.94),
                  opacity 400ms ease-in-out 300ms,
                  visibility 0ms linear 0ms,
                  margin 350ms cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
    }

    .inspector-ribbon .phoneme-blurb-overlay .blurb-text {
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--ilya-text-secondary);
      margin-bottom: 6px;
    }

    .inspector-ribbon .phoneme-blurb-overlay .blurb-citation {
      font-size: 0.8rem;
      font-style: italic;
      color: var(--accent-muted, rgba(168, 90, 58, 0.75));
    }

    .inspector-ribbon .phoneme-blurb-overlay .blurb-citation::before {
      content: '— ';
    }

    /* Refinement 4: Stressed syllable - 2px sage perimeter, NO fill */
    .inspector-ribbon .stressed-syllable-region {
      background: transparent !important;
      border: 2px solid var(--ilya-accent);
      border-radius: 6px;
      padding: 4px;
      margin: 8px 0;
    }

    .inspector-ribbon .stressed-syllable-region:first-child {
      margin-top: 0;
    }

    /* Rows inside stressed region don't need extra bottom border at region edge */
    .inspector-ribbon .stressed-syllable-region .phoneme-row:last-child {
      border-bottom: none;
    }

    /* Cluster groups in drawer */
    .inspector-ribbon .cluster-group {
      margin: 4px 0;
    }

    /* Refinement 5: Clitic arrow styling */
    .inspector-ribbon .clitic-arrow-row {
      min-height: 48px;
      padding: 0 12px;
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
      display: flex;
      align-items: center;
      cursor: pointer;
      border-radius: 4px;
      transition: background 150ms ease;
    }

    .inspector-ribbon .clitic-arrow-row:hover {
      background: rgba(122, 158, 126, 0.06);
    }

    .inspector-ribbon .clitic-arrow-row:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 1px;
    }

    .inspector-ribbon .clitic-arrow-row .arrow-symbol {
      font-size: 1.25em;
      color: var(--ilya-accent);
      opacity: 0.7;
      width: 28px;
      text-align: center;
    }

    .inspector-ribbon .clitic-arrow-row .arrow-label {
      font-size: 0.85rem;
      color: var(--ilya-text-muted);
      margin-left: 8px;
    }

    .inspector-ribbon .clitic-arrow-row.expanded {
      background: rgba(122, 158, 126, 0.1);
    }

    /* PHASE 4A: Word-to-Word Content Morph — 250ms cross-fade with sage highlight — on changed phonemes */
    /* Inspector body morph animation */
    .inspector-body.morphing {
      opacity: 0;
      transform: translateY(4px);
    }
    
    .inspector-body {
      transition: opacity 125ms ease-out, transform 125ms ease-out;
    }
    
    .inspector-body.morph-in {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Sage highlight for changed phonemes */
    .phoneme-row.phoneme-changed,
    .cluster-group.phoneme-changed {
      animation: sage-pulse 400ms ease-out;
    }
    
    @keyframes sage-pulse {
      0% {
        background-color: rgba(122, 158, 126, 0.25);
        box-shadow: inset 0 0 0 2px var(--ilya-accent);
      }
      100% {
        background-color: transparent;
        box-shadow: inset 0 0 0 2px transparent;
      }
    }

    /* Controls Section (Phase 3D) */
    .inspector-controls {
      display: flex;
      flex-direction: column;
      padding: 16px 0;
      margin-top: 8px;
      border-top: 1px solid rgba(26, 22, 18, 0.06);
      min-height: 120px; /* Ensures spacer has room to work */
    }
    
    .inspector-control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 16px;
      margin-bottom: 8px;
      background: var(--ilya-binding);
      border-radius: 8px;
    }
    
    .inspector-control-row:last-of-type {
      margin-bottom: 0;
    }
    
    .inspector-control-label {
      font-size: 0.85rem;
      color: var(--ilya-text-secondary);
      flex-shrink: 0;
      margin-right: 12px;
    }
    
    /* Spacer pushes assimilation row to bottom */
    .inspector-controls-spacer {
      flex-grow: 1;
      min-height: 8px;
    }
    
    /* Stress source row - collapsed by default, slides in from left with overshoot */
    .inspector-stress-source-row {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-sm);
      padding: 0;
      margin-bottom: 0;
      max-height: 0;
      overflow: hidden;
      transform: translateX(-100%);
      transition: max-height 900ms cubic-bezier(0.0, 0.7, 0.1, 1.0),
                  padding 900ms cubic-bezier(0.0, 0.7, 0.1, 1.0),
                  margin-bottom 900ms cubic-bezier(0.0, 0.7, 0.1, 1.0),
                  transform 900ms cubic-bezier(0.22, 1.2, 0.36, 1.0);
    }

    .inspector-stress-source-row.expanded {
      max-height: 120px;
      padding: 8px 0;
      margin-bottom: 8px;
      overflow: visible;
      transform: translateX(0);
    }

    .inspector-stress-source-row.hidden {
      display: none;
    }
    
    .inspector-stress-source-label {
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--ilya-text-secondary);
      align-self: flex-start;
    }

    .inspector-stress-source-control {
      display: flex;
      gap: 2px;
      width: 100%;
    }
    
    .inspector-stress-source-control .segment {
      padding: 6px 10px;
      font-size: 0.75rem;
      flex: 1;
    }

    /* Pulsating attribution arrow — fixed overlay straddling drawer edge */
    .stress-attribution-arrow {
      display: none;
      position: fixed;
      z-index: 15;
      transform: rotate(165deg);
      transform-origin: center center;
      pointer-events: none;
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.15));
    }

    .stress-attribution-arrow.visible {
      display: block;
      animation: pulse-arrow 1.5s ease-in-out infinite;
    }

    @keyframes pulse-arrow {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }
    
    /* Variant row (ё toggle) - sage accent when ё active */
    .inspector-variant-row {
      flex-direction: column;
      padding: 0;
      overflow: hidden;
    }
    
    .variant-row-main {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      padding: 10px 16px;
    }
    
    .inspector-variant-control {
      display: flex;
      gap: 4px;
    }
    
    .inspector-variant-control .segment {
      min-width: 40px;
      padding: 6px 14px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .inspector-variant-control .segment[data-variant="yo"].active {
      background: var(--ilya-accent);
      color: white;
    }
    
    .inspector-variant-control .segment[data-variant="ye"].active {
      background: var(--ilya-text-muted);
      color: white;
    }
    
    /* Staged state - dashed outline indicates pending */
    .inspector-variant-control .segment.staged {
      background: white;
      outline: 2px dashed var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* Confirmation row - slides in below */
    .variant-confirm-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      padding: 0 16px;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: max-height 200ms ease-out, opacity 150ms ease, padding 200ms ease-out;
    }
    
    .variant-confirm-row.visible {
      max-height: 80px;
      opacity: 1;
      padding: 0 16px 12px 16px;
    }
    
    .variant-confirm-text {
      font-size: 0.8rem;
      color: var(--ilya-text-secondary);
      line-height: 1.4;
    }
    
    .variant-confirm-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    
    .variant-cancel-btn,
    .variant-apply-btn {
      padding: 5px 12px;
      font-size: 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms ease;
    }
    
    .variant-cancel-btn {
      background: transparent;
      border: 1px solid var(--ilya-border);
      color: var(--ilya-text-secondary);
    }
    
    .variant-cancel-btn:hover {
      border-color: var(--ilya-text-secondary);
    }
    
    .variant-apply-btn {
      background: var(--ilya-accent);
      border: none;
      color: white;
    }
    
    .variant-apply-btn:hover {
      background: var(--ilya-accent-hover);
    }
    
    /* Assimilation row - footer-docked, de-emphasized */
    .inspector-assimilation-row {
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      background: rgba(245, 245, 240, 0.6); /* Lighter than other controls */
      border-top: 1px solid rgba(26, 22, 18, 0.06);
      margin-top: auto; /* Ensures docking to bottom */
      margin-bottom: 0;
      padding: 10px 16px;
    }
    
    .inspector-assimilation-row .inspector-control-label {
      font-size: 0.85rem;
      margin-right: 0;
      margin-bottom: 0;
    }
    
    .inspector-assimilation-row.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    
    .inspector-assimilation-control {
      display: flex;
      gap: 4px;
      align-self: flex-end;
    }
    
    .inspector-assimilation-control .segment {
      padding: 6px 16px;
      font-size: 0.8rem;
      min-width: 48px;
    }
    
    /* Committed state for user selections */
    .inspector-controls .segment.committed {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      outline: 1px solid var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* Toast notification for ё warning */
    .inspector-yo-toast {
      position: sticky;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 0 16px;
      background: var(--ilya-text-primary);
      color: white;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: max-height 200ms var(--ease), opacity 200ms var(--ease), padding 200ms var(--ease);
      border-radius: 8px;
      margin-top: 12px;
    }
    
    .inspector-yo-toast.visible {
      max-height: 60px;
      opacity: 1;
      padding: 10px 16px;
    }
    
    .inspector-yo-toast .undo-btn {
      background: transparent;
      border: 1px solid white;
      color: white;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 150ms;
    }
    
    .inspector-yo-toast .undo-btn:hover {
      background: rgba(255,255,255,0.15);
    }
    
    .inspector-yo-toast .ok-btn {
      background: transparent;
      border: 1px solid white;
      color: white;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 150ms;
      margin-left: 6px;
    }
    
    .inspector-yo-toast .ok-btn:hover {
      background: rgba(255,255,255,0.15);
    }

    /* Scrim: tablet overlay mode only */
    .drawer-scrim {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(26, 22, 18, 0.1);
      z-index: 9;
    }

    /* Tablet: drawer overlays paper (same as desktop during transition) */
    @media (min-width: 601px) and (max-width: 899px) {
      .ilya-drawer {
        z-index: 100;
      }

      .ilya-drawer[data-state="open"] ~ .drawer-scrim {
        display: block;
      }
    }

    /* Mobile: bottom sheet (Phase 5A) */
    @media (max-width: 600px) {
      .ilya-drawer {
        top: auto;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        max-width: 100%;
        min-width: 100%;
        height: auto;
        max-height: 70vh;
        border-right: none;
        border-top: 1px solid rgba(26, 22, 18, 0.08);
        border-radius: 16px 16px 0 0;
        box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.05);
        transform: translateY(100%);
        z-index: 100;
      }

      .ilya-drawer[data-state="open"] {
        transform: translateY(0);
      }

      .ilya-drawer[data-state="open"] ~ .drawer-scrim {
        display: block;
      }
      
      /* Drag handle: visible only on mobile */
      .drawer-drag-handle {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 12px 0 8px;
        cursor: grab;
        touch-action: none;
      }
      
      .drawer-drag-handle:active {
        cursor: grabbing;
      }
      
      .drag-handle-bar {
        width: 36px;
        height: 4px;
        background: rgba(26, 22, 18, 0.2);
        border-radius: 2px;
      }
      
      /* Adjust drawer header for mobile */
      .drawer-header {
        padding-top: 0;
      }
      
      /* Drawer body needs overflow for scrolling */
      .drawer-root .drawer-body,
      .drawer-inspector .inspector-body {
        max-height: calc(70vh - 100px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      /* Textarea sizing for mobile */
      .drawer-textarea {
        min-height: 120px;
        max-height: 150px;
      }
      
      /* Language pill needs no mobile override — 52×24px is touch-accessible */
      
      /* Phase 5B: Mobile Drill state (Inspector) */
      
      /* Compact inspector header */
      .drawer-inspector .drawer-header {
        padding: 8px 16px;
        gap: 8px;
      }
      
      /* Syllable buttons: horizontal scroll on mobile */
      .inspector-syllable-display {
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        gap: 6px;
        padding-bottom: 4px;
      }
      
      .inspector-syllable-display .syllable-btn {
        flex-shrink: 0;
        min-width: 44px;
        padding: 6px 10px;
        font-size: 0.9rem;
      }
      
      /* Compact ribbon for mobile */
      .inspector-ribbon .phoneme-row {
        padding: 8px 12px;
      }
      
      /* Control modules: stack vertically on mobile */
      .inspector-controls {
        flex-direction: column;
        gap: 12px;
      }
      
      .inspector-controls .control-row {
        flex-wrap: wrap;
      }
      
      /* Blurb text sizing for mobile */
      .inspector-ribbon .phoneme-blurb-overlay .blurb-text {
        font-size: 0.85rem;
        line-height: 1.5;
      }
    }
    
    /* Drag handle: hidden on desktop/tablet */
    @media (min-width: 601px) {
      .drawer-drag-handle {
        display: none;
      }
    }

    /* Print: hide drawer entirely */
    
    /* PAPER APERTURE: Viewing area with inset depth */
    .paper-aperture {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
      min-height: 0; /* Flex child needs this to scroll */
      transition: transform 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
    }

    /* Paper shifts right when drawer opens (desktop ≥900px) */
    @media (min-width: 900px) {
      .ilya-layout.drawer-open .paper-aperture {
        transform: translateX(clamp(120px, 20vw, 180px));
      }
    }

    /* PAPER: Document simulation (v5.9.1) — Supports Letter (8.5×11) and A4 (210×297mm) — Height-constrained with aspect-ratio calculating width */
    .paper {
      /* Height is the constraining dimension; aspect-ratio calculates width */
      height: min(var(--paper-height), 80vh);
      aspect-ratio: var(--paper-aspect);
      max-width: calc(100% - 3rem);
      background: var(--surface);
      box-shadow: var(--shadow-paper);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
      margin: 1.5rem auto;
      transition: aspect-ratio 300ms ease-out, 
                  height 300ms ease-out;
      
      /* Ghosted scrollbar (Calm Authority) */
      scrollbar-width: thin;
      scrollbar-color: rgba(74, 69, 64, 0.2) transparent;
    }
    
    /* WebKit ghosted scrollbar */
    .paper::-webkit-scrollbar {
      width: 6px;
    }
    
    .paper::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .paper::-webkit-scrollbar-thumb {
      background: rgba(74, 69, 64, 0.2);
      border-radius: 3px;
    }
    
    .paper::-webkit-scrollbar-thumb:hover {
      background: rgba(74, 69, 64, 0.35);
    }
    
    /* A4 paper size */
    .paper[data-size="a4"] {
      --paper-width: 794px;
      --paper-height: 1123px;
      --paper-aspect: 210 / 297;
    }

    /* PAGE TEMPLATES (v5.9.4) — Multi-page stationery design */
    /* Container for multiple pages */
    .paper-stack {
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 24px;
    }
    
    /* Individual page */
    .paper-page {
      width: min(var(--paper-width), 100% - 3rem);
      min-height: var(--paper-height);
      aspect-ratio: var(--paper-aspect);
      background: var(--stationery-cream);
      box-shadow: 0 2px 4px rgba(26, 22, 18, 0.08);
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      position: relative;
      overflow: hidden;  /* Prevent content bleed between pages (v5.11.9) */
      
      /* GPU acceleration for shadow performance */
      transform: translateY(0);
      will-change: transform;
    }
    
    /* A4 variant */
    .paper-page[data-size="a4"] {
      --paper-width: 794px;
      --paper-height: 1123px;
      --paper-aspect: 210 / 297;
    }
    
    /* PAGE 1: TITLE TEMPLATE */
    .paper-page[data-template="title"] {
      /* Structure defined by children */
    }
    
    /* Bracket logo [ Ilya ] */
    .page-logo {
      position: absolute;
      top: 48px;
      left: 72px;
      font-size: 18px;
      color: var(--stationery-sage);
      display: flex;
      align-items: baseline;
      gap: 2px;
    }
    
    .page-logo .bracket {
      font-family: var(--font-mono);
      font-weight: 600;
    }
    
    .page-logo .logo-name {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-style: italic;
      font-weight: normal;
      letter-spacing: 0.5px;
    }
    
    /* Title header block */
    .page-header-title {
      padding: 72px 72px 16px;
      text-align: left;
    }
    
    .page-title {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-size: 28px;
      font-weight: normal;
      color: var(--stationery-ink);
      margin: 0 0 16px 0;
      letter-spacing: 0.5px;
    }
    
    .page-metadata {
      font-family: var(--font-sans);
      font-size: 11px;
      font-weight: 500;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    
    .page-metadata .divider {
      color: var(--stationery-sage);
      font-weight: 300;
    }
    
    .page-metadata-rule {
      width: 200px;
      height: 1px;
      background: var(--stationery-sage);
      margin-top: 16px;
      border: none;
    }
    
    /* PAGES 2+: SUBSEQUENT TEMPLATE */
    .paper-page[data-template="subsequent"] {
      /* Structure defined by children */
    }
    
    /* Faint bracket watermark */
    .paper-page[data-template="subsequent"]::before {
      content: "[ ]";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--font-mono);
      font-size: 48px;
      font-weight: 300;
      color: var(--stationery-watermark);
      letter-spacing: 8px;
      pointer-events: none;
    }
    
    /* Running header */
    .page-header-running {
      padding: 36px 72px 8px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      border-bottom: 1px solid var(--stationery-sage);
      margin: 0 72px;
      padding-left: 0;
      padding-right: 0;
    }
    
    .running-title {
      font-family: var(--font-sans);
      font-size: 10px;
      font-weight: 600;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    /* PAGE CONTENT AREA */
    .page-content {
      flex: 1;
      padding: 16px 72px;
      padding-bottom: 120px; /* Clearance for absolute footer (reduced from 150px in v5.11.17) */
      display: flex;
      flex-direction: column;
    }
    
    .page-content.empty {
      justify-content: center;
      align-items: center;
    }
    
    .page-ghost-text {
      color: var(--ink-secondary);
      opacity: 0.25;
      font-style: italic;
      font-family: var(--font-sans);
      font-size: 14px;
      text-align: center;
    }
    
    /* PAGE FOOTER (v5.9.6) — 2/3 attribution left, 1/3 pagination right — Positioned absolutely at bottom of page */
    .page-footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px 72px 32px;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 24px;
      align-items: end;
      background: var(--stationery-cream);
    }
    
    .footer-attribution {
      font-family: var(--font-sans);
      font-size: 8px;
      line-height: 1.5;
      color: var(--ink-secondary);
      max-width: 100%;
    }
    
    .footer-attribution p {
      margin: 0 0 4px 0;
    }
    
    .footer-attribution p:last-child {
      margin-bottom: 0;
    }
    
    .footer-pagination {
      font-family: var(--font-sans);
      font-size: 10px;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: right;
      white-space: nowrap;
    }
    
    /* PRINT STYLES FOR PAGES */
        
    /* MOBILE: HORIZONTAL SWIPE */
    @media (max-width: 768px) {
      .paper-stack {
        flex-direction: row;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        gap: 0;
        padding: 16px;
      }
      
      .paper-page {
        flex: 0 0 calc(100vw - 32px);
        scroll-snap-align: center;
        margin: 0 8px;
      }
    
      .cluster-overlay-container {
        right: 4px;
      }
      
      .cluster-rubric {
        max-width: none;
        flex: 1;
      }
      
      .cluster-details {
        margin-left: 0;
        width: 100%;
      }
    }

    .paper .verse-container {
      flex: 1;
    }
    
    .verse-container {
      max-width: 100%;
    }

    /* VERSE LINE */
    .verse-line {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 0.625rem; /* Column gap reduced from 1.5rem for density (v5.11.18) */
      align-items: flex-start;
      padding: 0.45rem 0;
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
      width: 100%;
    }

    .verse-line:last-child {
      border-bottom: none;
    }

    /* WORD STACK */
    .word-stack {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.1rem;
      padding: 0.35rem 0.5rem 0.35rem 0;
      cursor: pointer;
      border-radius: var(--radius);
      transition: background 150ms var(--ease);
      flex-shrink: 0;
    }
    
    .word-stack:hover {
      background: rgba(168, 90, 58, 0.06);
    }

    .word-stack:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    /* Vowelless clitics: reduced gap (4px) to visually connect with host (v5.11.19) */
    .word-stack.vowelless-clitic.proclitic {
      margin-right: -0.375rem; /* Reduces 10px gap to 4px before host */
    }
    .word-stack.vowelless-clitic.enclitic {
      margin-left: -0.375rem; /* Reduces 10px gap to 4px after host */
    }

    .word-stack[aria-selected="true"] {
      background: var(--ilya-accent-light);
    }

    .word-stack .ipa {
      font-family: 'Charis SIL', 'Doulos SIL', 'Noto Serif', 'DejaVu Sans', serif;
      font-size: 1rem;
      color: var(--ink-secondary);
      letter-spacing: 0.01em;
    }

    .word-stack .cyrillic {
      font-family: 'Noto Serif', serif;
      font-size: 1rem;
      font-weight: 500;
      color: var(--ink-primary);
    }

    .word-stack .punct {
      color: var(--ink-secondary);
      opacity: 0.7;
    }

    .word-stack .gloss {
      font-family: 'Noto Serif', serif;
      font-size: 0.8rem;
      font-style: italic;
      color: var(--accent-muted);
      min-height: 1.1em;
      min-width: 1em;
    }

    .word-stack.proclitic .cyrillic,
    .word-stack.enclitic .cyrillic {
      font-weight: 500;
    }
    
    /* Clitics show directional arrows — normal spacing (v5.11.10) */
    
    /* UNVERIFIED STRESS: "Verify" Treatment (v5.11.32) — Dashed box with smallcaps label for inferred stress */
    .stress-unverified-container {
      position: relative;
      display: inline-flex;
      align-items: center;
      border-radius: 3px;
      padding: 3px 8px 12px 6px; /* Extra bottom padding for label */
      background-color: rgba(245, 244, 240, 0.3);
      cursor: pointer;
      transition: background-color 0.15s ease;
      
      /* Custom dashed border: 16px dash, 6px gap */
      /* Four gradient layers: top, bottom, left, right edges */
      background-image: 
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px);
      background-size: 
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position: 
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }
    
    .stress-unverified-container:hover {
      background-color: rgba(245, 244, 240, 0.6);
      /* Darken dashes on hover */
      background-image: 
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px);
      background-size: 
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position: 
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }
    
    .stress-unverified-container .word-stack {
      /* Reset word-stack padding when inside container */
      padding: 0;
    }
    
    .stress-unverified-label {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translate(-50%, 50%);
      font-family: var(--font-sans);
      font-variant: small-caps;
      font-size: 0.6rem;
      letter-spacing: 0.08em;
      color: var(--color-muted-text);
      background-color: var(--stationery-cream);
      padding: 0 4px;
      line-height: 1;
      white-space: nowrap;
      pointer-events: none;
    }
    
    /* Print/PDF: hide Verify boxes, show clean content */
    
    /* DRAWER: Textarea */
    .drawer-textarea {
      width: 100%;
      height: 360px;
      min-height: 120px;
      padding: 0.75rem;
      padding-right: 2.75rem; /* space for OCR icon */
      font-family: monospace;
      font-size: 0.95rem;
      line-height: 1.6;
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: var(--radius);
      resize: vertical;
      transition: border-color 150ms var(--ease);
    }

    .drawer-textarea:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }

    .drawer-textarea::placeholder {
      color: var(--ilya-text-muted);
      opacity: 0.7;
    }

    /* Textarea wrapper (positions OCR overlay) */
    .textarea-wrapper {
      position: relative;
    }

    /* OCR icon: top-right corner inside textarea */
    .ocr-overlay-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      opacity: 0.6;
      color: var(--ilya-text-secondary);
      transition: opacity 200ms var(--ease), color 200ms var(--ease), transform 200ms var(--ease);
      z-index: 2;
    }

    .textarea-wrapper:hover .ocr-overlay-btn,
    .drawer-textarea:focus ~ .ocr-overlay-btn {
      opacity: 1;
    }

    .ocr-overlay-btn:hover {
      color: var(--ilya-accent);
      transform: scale(1.05);
    }

    .ocr-overlay-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none;
    }

    .ocr-overlay-btn:disabled:hover {
      color: var(--ilya-text-secondary);
    }

    .footer-status {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      font-size: 0.75rem;
      color: var(--ink-secondary);
    }

    .char-counter {
      opacity: 0;
      visibility: hidden;
      min-width: 7ch;
      display: inline-block;
      transition: opacity 200ms var(--ease), visibility 200ms var(--ease);
    }

    .char-counter::after {
      content: '\200b';
    }

    .char-counter.visible {
      opacity: 1;
      visibility: visible;
    }

    .char-counter.warning {
      color: #b45309;
    }

    .char-counter.error {
      color: #dc2626;
    }

    /* OCR Status */
    .ocr-status {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      color: var(--ink-secondary);
    }

    .ocr-status.error {
      color: #c75d5d;
    }

    .ocr-status.success {
      color: var(--ilya-accent);
    }

    .ocr-status .spinner {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Scan button icon alignment */
    #ocrScanBtn {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    #ocrScanBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Drawer-specific input section layout */
    .drawer-input-section {
      margin-top: var(--space-lg);
    }

    .drawer-input-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: var(--space-sm);
      min-height: 1.5rem;
    }

    .drawer-input-footer .footer-status {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      font-size: 0.75rem;
      color: var(--ilya-text-muted);
    }

    .drawer-input-actions {
      margin-top: var(--space-md);
    }

    .drawer-secondary-actions {
      display: flex;
      gap: var(--space-sm);
    }

    /* Button styles — square tile variant for action row (v6.0.77) */
    .drawer-secondary-actions .btn,
    .drawer-secondary-actions .btn-export {
      flex: 1;
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: var(--space-sm);
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 500;
      line-height: 1.3;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }

    /* Button styles */
    .btn {
      padding: 0.5rem 1.25rem;
      border-radius: var(--radius);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }

    .btn-primary {
      background: var(--ilya-accent);
      color: white;
      border: none;
    }

    .btn-primary:hover {
      background: var(--ilya-accent-hover);
    }
    
    .btn-primary:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .btn-secondary {
      background: transparent;
      color: var(--ilya-text-secondary);
      border: 1px solid var(--ilya-border);
    }

    .btn-secondary:hover {
      border-color: var(--ilya-text-secondary);
      color: var(--ilya-text-primary);
    }
    
    .btn-secondary:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    /* LANGUAGE PILL (v6.0.51) — Unified segmented pill — Kimi spec — Used in Root (left-aligned, pre-flight) and — Drill (right-flush, display swap) */
    .lang-toggle-pill {
      display: inline-flex;
      width: 52px;
      height: 24px;
      background: rgba(139, 154, 125, 0.12);
      border-radius: 12px;
      position: relative;
      cursor: pointer;
      user-select: none;
      flex-shrink: 0;
    }

    .lang-option {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-sans);
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6B6B6B;
      transition: color 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
      z-index: 2;
      border: none;
      background: none;
      padding: 0;
      cursor: pointer;
    }

    .lang-option.active {
      color: #fff;
    }

    .lang-option:hover:not(.active) {
      color: #4A4A4A;
    }

    .lang-pill-indicator {
      position: absolute;
      width: 50%;
      height: 100%;
      background: #8B9A7D;
      border-radius: 12px;
      transition: transform 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
      z-index: 1;
    }

    /* EN active */
    .lang-toggle-pill[data-lang="en"] .lang-pill-indicator {
      transform: translateX(0);
    }

    /* FR active */
    .lang-toggle-pill[data-lang="fr"] .lang-pill-indicator {
      transform: translateX(100%);
    }

    /* Drill placement: right-flush, above phoneme ribbon */
    .inspector-header .lang-toggle-pill {
      flex-shrink: 0;
      margin-left: auto;
    }

    /* GHOST TEXT: Empty state instruction */
    .ghost-text {
      margin: 0;
      padding: 0;
      font-family: 'Noto Serif', serif;
      font-style: italic;
      font-size: 1rem;
      line-height: 1.6;
      color: var(--ink-secondary);
      opacity: 0.5;
      max-width: 45em;
    }

    .ghost-text p {
      margin: 0 0 0.5rem 0;
    }

    .ghost-text.hidden {
      display: none;
    }

    .syllable-btn {
      font-family: 'Noto Serif', serif;
      font-size: 1.15rem;
      padding: 0.5rem 0.75rem;
      background: var(--surface);
      border: 1px solid rgba(26, 22, 18, 0.15);
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }

    .syllable-btn:hover {
      border-color: var(--ilya-accent);
      background: var(--ilya-accent-light);
    }
    
    .syllable-btn:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .syllable-btn.stressed {
      background: var(--ilya-accent);
      color: white;
      border-color: var(--ilya-accent);
      font-weight: 500;
    }

    .syllable-btn.stressed:hover {
      background: var(--ilya-accent-hover);
    }
    
    .syllable-btn.disabled,
    .syllable-btn:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      background: var(--ilya-parchment);
      border-color: rgba(26, 22, 18, 0.1);
    }
    
    .syllable-btn.disabled:hover,
    .syllable-btn:disabled:hover {
      border-color: rgba(26, 22, 18, 0.1);
      background: var(--ilya-parchment);
    }
    
    .syllable-btn.disabled:focus,
    .syllable-btn:disabled:focus {
      outline: none;
    }
    
    /* Syllable drag states (v5.10.15) */
    .syllable-btn.dragging {
      opacity: 0.5;
      transform: scale(0.98);
    }
    
    .syllable-btn.drag-target {
      border-color: var(--ilya-accent);
      box-shadow: 0 0 0 3px rgba(122, 158, 126, 0.3);
    }
    
    .syllable-btn.drag-invalid {
      animation: shake 0.3s ease-out;
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    
    /* Ghost consonant during drag */
    .consonant-ghost {
      position: fixed;
      pointer-events: none;
      font-family: var(--font-ipa);
      font-size: 1.15rem;
      padding: 0.3rem 0.5rem;
      background: var(--surface);
      border: 1px solid var(--ilya-accent);
      border-radius: 4px;
      opacity: 0.85;
      z-index: 10000;
      transition: opacity 0.15s, transform 0.15s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .consonant-ghost.valid {
      background: var(--ilya-accent-light);
      border-color: var(--ilya-accent);
    }
    
    .consonant-ghost.invalid {
      background: #fee;
      border-color: #c44;
      opacity: 0.6;
    }
    
    /* Boundary reset button (v5.11.43) - explicit reset for adjusted boundaries */
    .boundary-reset-btn {
      font-size: 1rem;
      padding: 0.25rem 0.5rem;
      margin-left: 0.5rem;
      background: transparent;
      border: 1px solid var(--ilya-accent-light);
      border-radius: 4px;
      color: var(--ilya-accent);
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease, background 0.15s ease;
      vertical-align: middle;
    }
    
    .boundary-reset-btn.visible {
      opacity: 1;
    }
    
    .boundary-reset-btn:hover {
      background: var(--ilya-accent-light);
      border-color: var(--ilya-accent);
    }
    
    .boundary-reset-btn:active {
      background: var(--ilya-accent);
      color: white;
    }
    
    /* VERTICAL RIBBON (v5.5) — Replaces horizontal ribbon-grid */
    .ribbon-vertical {
      --ribbon-inline-padding: 12px;
      --syllable-gap: 16px;
      --stressed-tint-opacity: 0.08;
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 8px 0;
      /* Allow overlays to extend beyond container */
      overflow: visible;
    }
    
    /* Phoneme row - minimum 44px for tap targets */
    .phoneme-row {
      position: relative;
      display: flex;
      align-items: center;
      min-height: 44px;
      padding: 0 var(--ribbon-inline-padding);
      cursor: pointer;
      border-radius: 4px;
      transition: background 150ms var(--ease);
    }
    
    .phoneme-row:hover {
      background: rgba(122, 158, 126, 0.06);
    }
    
    .phoneme-row:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 1px;
    }
    
    /* Metrical spacing between syllables */
    .phoneme-row[data-syllable-start="true"] {
      margin-top: var(--syllable-gap);
    }
    
    .phoneme-row[data-syllable-start="true"]:first-child,
    .stressed-syllable-region:first-child {
      margin-top: 0;
    }
    
    /* Stressed syllable region - subtle tint with soft radius */
    .stressed-syllable-region {
      background: rgba(122, 158, 126, var(--stressed-tint-opacity));
      border-radius: 6px;
      padding: 6px 0;
      margin: var(--syllable-gap) 0 0 0;
      /* Removed negative horizontal margins - let rows keep consistent padding */
    }
    
    .stressed-syllable-region:first-child {
      margin-top: 0;
    }
    
    .stressed-syllable-region .phoneme-row {
      /* Keep same padding as unstressed rows to prevent layout shift */
      padding: 0 var(--ribbon-inline-padding);
    }
    
    .stressed-syllable-region .phoneme-row[data-syllable-start="true"] {
      margin-top: 0;
    }
    
    /* Typography hierarchy */
    .phoneme-mapping {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-height: 32px;
    }
    
    /* Ensure clicks pass through to parent row */
    .phoneme-cyr,
    .phoneme-arrow,
    .phoneme-ipa {
      pointer-events: none;
    }
    
    .phoneme-cyr {
      font-family: 'Noto Serif', serif;
      color: var(--ilya-text-muted);
      width: 20px;
      font-size: 0.95rem;
    }
    
    .phoneme-arrow {
      color: var(--ilya-text-caption);
      font-size: 0.75rem;
      opacity: 0.5;
    }
    
    .phoneme-ipa {
      font-family: var(--font-ipa);
      color: var(--ilya-text-primary);
      font-size: 0.95rem;
    }
    
    /* Silent letter styling (deletion clusters) */
    .phoneme-row.silent-letter .phoneme-cyr {
      color: var(--ilya-text-caption);
    }
    
    .phoneme-row.silent-letter .phoneme-ipa {
      color: var(--ilya-text-caption);
      font-style: italic;
      font-family: var(--font-sans);
      font-size: 0.8rem;
    }
    
    /* Cluster box - full perimeter groups merged letters (v5.11.29) */
    /* CLUSTER TWO-LAYER ARCHITECTURE (v5.11.31) — Per Kimi's spec: always-visible rubric, vertical accordion for details — - Perimeter: demoted to 1px, subtle grouping indicator — - Rubric: always visible, content-sized — - Details: accordion below rubric on click */
    /* Cluster group wrapper */
    .cluster-group {
      position: relative;
      cursor: pointer;
    }
    
    /* Perimeter via ::before - demoted to 1px, reduced saturation */
    .cluster-group::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 4px;
      width: 36px;
      border: 1px solid rgba(122, 158, 126, 0.5); /* Demoted: 1px, 50% opacity */
      border-radius: 4px;
      pointer-events: none;
      z-index: 2;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }
    
    /* Hover: subtle glow on perimeter */
    .cluster-group:hover::before {
      border-color: rgba(122, 158, 126, 0.7);
      box-shadow: 0 0 8px rgba(122, 158, 126, 0.15);
    }
    
    /* Cluster member rows - completely neutral */
    .cluster-group .phoneme-row.cluster-member {
      min-height: 44px;
      background: transparent !important;
      pointer-events: none;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
    }
    
    .cluster-group .phoneme-row.cluster-member:hover,
    .cluster-group .phoneme-row.cluster-member:focus {
      background: transparent !important;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
    }
    
    .cluster-group .phoneme-row.cluster-member .phoneme-arrow,
    .cluster-group .phoneme-row.cluster-member .phoneme-ipa {
      visibility: hidden;
    }
    
    /* Prevent cluster rows from fading when blurb is active */
    .ribbon-vertical.has-active-blurb .cluster-group .phoneme-row {
      opacity: 1 !important;
    }
    
    /* Hidden click target (covers perimeter area) */
    .cluster-perimeter {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 4px;
      width: 36px;
      background: transparent;
      pointer-events: auto;
      cursor: pointer;
      z-index: 3;
      border: none;
      outline: none;
    }
    
    .cluster-perimeter:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    /* Overlay container - ALWAYS VISIBLE (rubric), accordion for details */
    .cluster-overlay-container {
      position: absolute;
      top: 50%;
      left: 40px; /* Flush with perimeter right edge */
      right: 8px; /* Fill remaining ribbon width */
      transform: translateY(-50%);
      display: flex;
      align-items: flex-start;
      flex-direction: column;
      z-index: 15;
      pointer-events: auto;
    }
    
    /* Rubric row: connector + formula (always visible) */
    .cluster-rubric-row {
      display: flex;
      align-items: center;
      width: 100%;
    }
    
    /* Connector beam - always visible */
    .cluster-connector {
      width: 16px;
      min-width: 16px;
      height: 2px;
      background: rgba(122, 158, 126, 0.5); /* Matches demoted perimeter */
      flex-shrink: 0;
      transition: background 150ms ease;
    }
    
    .cluster-group:hover .cluster-connector {
      background: rgba(122, 158, 126, 0.7);
    }
    
    /* Rubric bubble - always visible, compact, content-sized */
    .cluster-rubric {
      background: rgba(250, 250, 248, 0.95);
      border: 1px solid rgba(122, 158, 126, 0.4);
      border-radius: 4px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: background 150ms ease, border-color 150ms ease;
      flex: 1;
      max-width: 200px;
    }
    
    .cluster-rubric:hover {
      background: rgba(122, 158, 126, 0.08);
      border-color: rgba(122, 158, 126, 0.6);
    }
    
    .cluster-rubric .cluster-formula-ortho {
      font-family: 'Noto Serif', serif;
      font-size: 0.95rem;
      color: var(--ilya-text-muted);
    }
    
    .cluster-rubric .cluster-formula-arrow {
      font-size: 0.85rem;
      color: var(--ilya-text-caption);
    }
    
    .cluster-rubric .cluster-formula-ipa {
      font-family: var(--font-ipa);
      font-size: 1rem;
      color: var(--ilya-text-primary);
    }
    
    /* Details panel - accordion below rubric */
    .cluster-details {
      margin-left: 16px; /* Align with rubric (past connector) */
      margin-top: 0;
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 250ms ease, opacity 150ms ease, margin-top 150ms ease;
      width: calc(100% - 16px);
    }
    
    .cluster-group.active .cluster-details {
      max-height: 300px;
      opacity: 1;
      margin-top: 8px;
    }
    
    .cluster-details-content {
      background: white;
      border: 1px solid rgba(122, 158, 126, 0.3);
      border-radius: 4px;
      padding: 12px 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }
    
    .cluster-details .cluster-blurb-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: var(--ilya-text-secondary);
    }
    
    .cluster-details .cluster-blurb-citation {
      font-size: 0.75rem;
      color: var(--ilya-text-caption);
      margin-top: 8px;
      font-style: italic;
    }
    
    /* Mobile: stack vertically */
        
    /* END CLUSTER TWO-LAYER ARCHITECTURE */
    /* Blurb content (accordion) */
    .phoneme-blurb {
      overflow: hidden;
      min-height: 0;
    }
    
    .blurb-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: var(--ilya-text-secondary);
      margin-bottom: 4px;
    }
    
    .blurb-citation {
      font-size: 0.75rem;
      font-style: italic;
      color: var(--ilya-text-caption);
    }
    
    /* FLOATING BLURB OVERLAY (v5.5) — "Inline Overlay" pattern per Kimi's design — Scholarly annotation without layout shift */
    /* Backdrop: white fade behind active blurb */
    .ribbon-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.7);
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms var(--ease);
      z-index: 5;
      border-radius: 6px;
    }
    
    .ribbon-backdrop.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* Expanded row stays prominent */
    .ribbon-vertical.has-active-blurb .phoneme-row.expanded {
      z-index: 6;
      opacity: 1;
      filter: none;
    }
    
    /* Expanded row gets subtle highlight */
    .phoneme-row.expanded {
      background: rgba(122, 158, 126, 0.1);
      border-radius: 4px;
    }
    
    /* The floating blurb overlay */
    .phoneme-blurb-overlay {
      position: absolute;
      top: calc(100% + 4px);
      left: -6px;
      right: -6px;
      background: #FAFAF8;
      /* border: 2px solid var(--ilya-accent); -- REMOVED: no borders on blurbs */
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06),
                  0 2px 8px rgba(122, 158, 126, 0.1);
      padding: 16px;
      z-index: 10;
      min-height: 60px;
      max-height: 200px;
      overflow-y: auto;
      
      /* Hidden by default */
      opacity: 0;
      pointer-events: none;
      transform: scale(0.98) translateY(4px);
      transition: opacity 200ms var(--ease),
                  transform 200ms var(--ease);
    }
    
    /* When row is expanded, show overlay */
    .phoneme-row.expanded .phoneme-blurb-overlay {
      opacity: 1;
      pointer-events: auto;
      transform: scale(1) translateY(0);
    }
    
    /* Blurb content styling within overlay */
    .phoneme-blurb-overlay .blurb-text {
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--ilya-text-primary);
      margin-bottom: 8px;
    }
    
    .phoneme-blurb-overlay .blurb-citation {
      font-size: 0.8rem;
      font-style: italic;
      color: var(--ilya-accent);
    }
    
    /* Segmented Control */
    .segmented-control {
      display: flex;
      background: #F3F4F6;
      border-radius: 6px;
      padding: 2px;
      gap: 2px;
    }
    
    .segment {
      flex: 1;
      padding: 0.35rem 0.4rem;
      font-size: 0.7rem;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
      box-sizing: border-box;
    }
    
    .segment:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    /* Active/committed segment */
    .segment.active {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
    }
    
    /* Staged segment (pending, not yet committed) */
    .segment.staged {
      background: white;
      color: var(--ink-secondary);
      outline: 1px dashed #9CA3AF;
      outline-offset: -2px;
    }
    
    /* Committed segment (saved) */
    .segment.committed {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      outline: 1px solid var(--ilya-accent);
      outline-offset: -2px;
    }

    .citation {
      font-size: 0.8rem;
      line-height: 1.5;
    }
    
    .drawer-tab {
      flex: 1;
      padding: var(--space-md);
      font-size: var(--text-sm);
      font-weight: 500;
      color: var(--ilya-text-secondary);
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      transition: all var(--duration-fast) var(--ease-out);
    }
    
    .drawer-tab.active {
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border-bottom-color: var(--ilya-accent);
    }
    
    .drawer-tab:hover:not(.active) {
      background: rgba(122, 158, 126, 0.05);
    }
    
    .drawer-tab:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* DASHBOARD: Form Components */
    .form-group {
      margin-bottom: var(--space-md);
    }
    
    .form-input {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      transition: all var(--duration-fast) var(--ease-out);
    }
    
    .form-input:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .form-input::placeholder {
      color: var(--ilya-text-muted);
    }
    
    .form-hint {
      font-size: 10px;
      color: var(--ilya-text-muted);
      margin-top: 4px;
      font-style: italic;
    }
    
    /* DASHBOARD: Searchable Select */
    .searchable-select {
      position: relative;
      width: 100%;
    }
    
    .select-trigger {
      width: 100%;
      padding: var(--space-md);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all var(--duration-fast) var(--ease-out);
      text-align: left;
    }
    
    .select-trigger:hover {
      border-color: var(--ilya-border-focus);
    }
    
    .select-trigger.active {
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .select-trigger .chevron-down {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .select-trigger.active .chevron-down {
      transform: rotate(180deg);
    }
    
    .select-trigger .placeholder {
      color: var(--ilya-text-muted);
    }
    
    .select-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      box-shadow: var(--ilya-shadow-md);
      z-index: 100;
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
      transition: all var(--duration-base) var(--ease-out);
    }
    
    .select-dropdown.open {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }
    
    .select-search {
      width: 100%;
      padding: var(--space-md);
      border: none;
      border-bottom: 1px solid var(--ilya-border-light);
      font-size: var(--text-sm);
      font-family: var(--font-sans);
    }
    
    .select-search:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .select-option {
      padding: var(--space-md);
      cursor: pointer;
      border-bottom: 1px solid var(--ilya-border-light);
      transition: background var(--duration-fast) var(--ease-out);
    }
    
    .select-option:last-child {
      border-bottom: none;
    }
    
    .select-option:hover,
    .select-option.highlighted {
      background: var(--ilya-accent-light);
    }
    
    .select-option .primary {
      display: block;
      font-weight: 500;
      color: var(--ilya-text-primary);
    }
    
    .select-option .secondary {
      display: block;
      font-size: var(--text-xs);
      color: var(--ilya-text-caption);
      margin-top: 2px;
    }
    
    .select-option.custom {
      font-style: italic;
      color: var(--ilya-text-secondary);
      border-top: 2px solid var(--ilya-border);
    }
    
    /* DASHBOARD: Profile Section */
    .profile-section {
      margin-top: auto;
      border-top: 1px solid var(--ilya-border);
      padding-top: var(--space-lg);
    }
    
    .profile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: var(--space-sm) 0;
    }
    
    .profile-header:hover {
      opacity: 0.8;
    }
    
    .profile-title {
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--ilya-text-secondary);
    }
    
    .profile-active {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
    }
    
    .profile-chevron {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .profile-section.expanded .profile-chevron {
      transform: rotate(180deg);
    }
    
    .profile-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-base) var(--ease-out),
                  opacity var(--duration-base) var(--ease-out);
      opacity: 0;
    }
    
    .profile-section.expanded .profile-content {
      max-height: 300px;
      opacity: 1;
    }
    
    .profile-select {
      width: 100%;
      padding: var(--space-md);
      margin: var(--space-md) 0;
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      cursor: pointer;
    }
    
    .profile-select:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .profile-description {
      display: flex;
      gap: var(--space-sm);
      font-size: var(--text-sm);
      font-family: var(--font-ipa);
      color: var(--ilya-text-secondary);
      line-height: 1.5;
      padding: var(--space-md);
      background: var(--ilya-paper);
      border-radius: 6px;
    }
    
    .info-icon-circle {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      font-style: italic;
      font-family: var(--font-sans);
      color: var(--ilya-accent);
      border: 1.5px solid var(--ilya-accent);
      border-radius: 50%;
      opacity: 0.7;
    }
    
    .profile-future {
      display: none; /* Hidden until multiple profiles implemented */
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
      margin-top: var(--space-md);
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    /* DOCUMENT SECTION (v5.8.2) — Paper size selection in dashboard */
    .document-section {
      margin-top: var(--space-lg);
      border-top: 1px solid var(--ilya-border);
      padding-top: var(--space-lg);
    }
    
    .document-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: var(--space-sm) 0;
    }
    
    .document-header:hover {
      opacity: 0.8;
    }
    
    .document-title {
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--ilya-text-secondary);
    }
    
    .document-active {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
    }
    
    .document-pages {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
      margin-left: 8px;
    }
    
    .document-pages::before {
      content: "•";
      margin-right: 8px;
    }
    
    .document-chevron {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .document-section.expanded .document-chevron {
      transform: rotate(180deg);
    }
    
    .document-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-base) var(--ease-out),
                  opacity var(--duration-base) var(--ease-out);
      opacity: 0;
    }
    
    .document-section.expanded .document-content {
      max-height: 150px;
      opacity: 1;
    }
    
    /* Paper size segmented control */
    .paper-size-control {
      display: flex;
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      padding: 3px;
      gap: 3px;
      margin: var(--space-md) 0;
    }
    
    .paper-size-btn {
      flex: 1;
      padding: 0.5rem 0.75rem;
      font-size: var(--text-sm);
      font-weight: 500;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
      min-height: 44px;
    }
    
    .paper-size-btn:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    .paper-size-btn.active {
      background: var(--ink-primary);
      color: white;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    }
    
    .paper-size-label {
      display: block;
      font-weight: 500;
    }
    
    .paper-size-dims {
      display: block;
      font-size: var(--text-xs);
      opacity: 0.7;
      margin-top: 2px;
    }
    
    /* Export button (inline tile, v6.0.77) */
    .btn-export {
      background: var(--stationery-sage);
      color: white;
      border: none;
      gap: 6px;
    }
    
    .btn-export:hover {
      background: #7a8a6d;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(139, 154, 125, 0.3);
    }
    
    .btn-export:active {
      transform: translateY(0);
    }
    
    .btn-export:disabled {
      background: var(--ilya-border);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .btn-export .export-icon {
      width: 18px;
      height: 18px;
    }

    /* PRINT STYLES */
    @media print {
      /* Hide all UI elements */
      .ilya-drawer,
      .drawer-scrim {
        display: none !important;
      }

      /* Reset body and aperture */
      body {
        background: white !important;
        padding: 0;
        margin: 0;
        overflow: visible !important;
        height: auto !important;
      }
      
      .ilya-layout {
        display: block;
        padding: 0;
        margin: 0;
        overflow: visible !important;
        height: auto !important;
      }
      
      .paper-aperture {
        padding: 0;
        overflow: visible;
        box-shadow: none;
        display: block;
        background: white;
        width: 100%;
      }

      /* Paper stack: no gaps, visible overflow */
      .paper-stack {
        gap: 0;
        padding: 0;
        display: block;
      }

      /* Individual pages - WYSIWYG fix (v5.11.6)
         Force each paper-page to be one physical page */
      .paper-page {
        page-break-after: always;
        page-break-inside: avoid;
        break-after: page;
        break-inside: avoid;
        box-shadow: none !important;
        margin: 0;
        padding: 0.5in 0.75in;
        width: 8.5in;
        min-height: 11in;
        height: 11in;  /* Force full page height */
        overflow: visible;  /* But don't clip if slightly over */
        background: white;
        box-sizing: border-box;
        position: relative;
      }
      
      /* Last page shouldn't force a trailing blank */
      .paper-page:last-child {
        page-break-after: auto;
        break-after: auto;
      }
      
      /* A4: 210mm × 297mm */
      .paper-page[data-size="a4"] {
        width: 210mm;
        min-height: 297mm;
        height: 297mm;
        padding: 12.7mm 15mm;
      }
      
      /* Hide watermark in print */
      .paper-page[data-template="subsequent"]::before {
        display: none;
      }

      /* Word stacks: no hover effects */
      .word-stack {
        cursor: default;
        background: transparent !important;
      }

      .word-stack:hover {
        background: none !important;
        box-shadow: none !important;
      }

      /* Verse lines: avoid breaking mid-line */
      .verse-line {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      
      /* Footer: align with page content area (v5.11.6) */
      .page-footer {
        position: absolute;
        bottom: 0;
        left: 0.75in;
        right: 0.75in;
        padding: 12px 0 24px 0;  /* Keep vertical padding only */
      }
      
      /* Page content: remove horizontal padding (paper-page provides it) */
      .page-content {
        padding-left: 0;
        padding-right: 0;
      }
      
      /* Page header title: align with content (v5.11.31) */
      .page-header-title {
        padding-left: 0;
        padding-right: 0;
      }
      
      /* Running header: align with content (v5.11.31) */
      .page-header-running {
        margin-left: 0;
        margin-right: 0;
      }
      
      /* Logo: align with content edge (v5.11.31) */
      .page-logo {
        left: 0.75in;
        top: 0.25in;
      }

      /* Page setup - minimal margins, content has its own padding */
      @page {
        margin: 0;
        size: letter;
      }
      
      @page :first {
        margin: 0;
      }
    
      /* Consolidated from earlier @media print block */
      .paper {
        width: 8.5in;
        height: 11in;
        margin: 0;
        box-shadow: none;
        overflow: visible;
      }
      
      .paper[data-size="a4"] {
        width: 210mm;
        height: 297mm;
      }

      /* Consolidated from earlier @media print block */
      .stress-unverified-container {
        padding: 0;
        background: transparent;
        background-image: none;
      }
      .stress-unverified-label {
        display: none;
      }
    }

    /* RESPONSIVE */
    @media (max-width: 880px) {
      .paper {
        min-height: auto;
      }
    }

    @media (max-width: 480px) {

      .word-stack .cyrillic {
        font-size: 1.1rem;
      }

      .word-stack .ipa {
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body class="notranslate">

  <div class="ilya-layout">

    <!-- Drawer: The workbench (v6.0) -->
    <aside class="ilya-drawer" id="ilyaDrawer" data-state="closed" data-mode="root">
      
      <!-- Phase 5A: Mobile drag handle (visible only on ≤600px) -->
      <div class="drawer-drag-handle" aria-hidden="true">
        <div class="drag-handle-bar"></div>
      </div>

      <!-- Root State: Dashboard/Input (content migrated in Phase 2) -->
      <div class="drawer-root" id="drawerRoot">
        <div class="drawer-header">
          <span class="drawer-title"><svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="120" height="42" viewBox="0 0 526 184" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Ilya"><g transform="translate(0,184) scale(0.1,-0.1)" fill="#8B9A7D" stroke="none"><path d="M1925 1783 c-85 -4 -102 -10 -108 -35 -7 -26 7 -38 45 -38 81 0 103 -46 78 -160 -10 -41 -63 -273 -119 -516 -57 -249 -101 -463 -101 -492 0 -121 118 -162 290 -100 58 21 80 40 80 70 0 14 -6 17 -22 13 -55 -11 -91 -13 -123 -4 -27 8 -36 17 -43 43 -6 18 -7 46 -5 62 5 29 191 840 237 1036 15 59 26 112 26 118 0 10 -90 11 -235 3z M1127 1673 c-14 -13 -7 -52 11 -56 9 -3 39 -11 65 -17 87 -23 87 -22 22 -307 -32 -136 -63 -273 -70 -303 -84 -373 -98 -427 -117 -447 -26 -28 -59 -40 -130 -48 -39 -4 -58 -11 -58 -20 0 -7 -3 -20 -6 -29 -6 -14 23 -16 279 -16 l285 0 4 30 c4 28 3 30 -51 41 -31 6 -64 15 -73 20 -43 23 -42 33 48 421 47 205 97 419 109 475 26 111 45 157 74 172 10 6 49 15 87 21 69 11 84 20 84 53 0 16 -20 17 -278 17 -153 0 -282 -3 -285 -7z M50 859 l0 -710 181 3 181 3 24 28 c33 39 31 81 -5 118 -28 28 -34 29 -115 29 l-86 0 0 530 0 530 84 0 c75 0 88 3 113 24 22 19 28 32 28 66 0 35 -6 46 -30 66 -29 23 -36 24 -202 24 l-173 0 0 -711z M4803 1560 c-28 -12 -56 -66 -49 -95 3 -12 14 -33 25 -46 17 -21 30 -24 112 -29 52 -3 93 -8 92 -12 -2 -5 -3 -242 -3 -528 l0 -520 -77 0 c-88 0 -122 -13 -141 -53 -11 -22 -11 -35 -2 -63 19 -56 50 -64 245 -64 l165 0 0 710 0 710 -172 -1 c-95 0 -183 -4 -195 -9z M3690 1297 c-165 -56 -296 -197 -353 -382 -35 -112 -29 -274 14 -362 82 -169 293 -192 455 -50 44 38 64 41 64 9 0 -10 13 -33 29 -52 29 -35 29 -35 112 -35 75 0 136 15 206 49 1 1 5 14 8 29 l7 28 -66 -7 c-94 -10 -116 6 -116 83 0 30 5 72 10 92 37 133 139 596 133 602 -4 4 -43 -2 -85 -13 -73 -20 -79 -20 -112 -4 -86 41 -210 46 -306 13z m241 -70 c23 -15 38 -37 47 -65 13 -39 11 -53 -21 -190 -20 -81 -46 -190 -58 -242 -25 -111 -50 -144 -143 -190 -101 -51 -192 -34 -233 42 -25 48 -30 221 -9 313 35 146 125 282 222 333 56 30 150 30 195 -1z M2370 1291 c-85 -28 -110 -43 -116 -68 -4 -13 -5 -26 -3 -28 2 -2 27 1 55 7 40 8 58 7 80 -4 28 -13 29 -15 28 -88 -1 -53 -15 -131 -48 -262 -67 -270 -61 -348 27 -406 35 -24 50 -27 118 -26 88 2 166 32 252 98 27 21 51 35 54 32 3 -3 -8 -49 -25 -103 -65 -205 -175 -327 -303 -335 -41 -3 -43 -2 -69 45 -53 95 -101 125 -165 101 -21 -8 -45 -56 -45 -89 0 -75 65 -115 198 -123 226 -13 394 85 496 287 25 51 54 122 65 159 39 131 183 804 174 813 -5 5 -42 6 -83 1 l-75 -7 -67 -300 c-88 -397 -77 -366 -148 -414 -106 -70 -209 -78 -254 -18 -33 45 -26 122 33 356 56 219 63 278 42 328 -25 61 -114 79 -221 44z"/></g></svg></span>
          <!-- Language pill — header placement: flush right, level with sigil (v6.0.52) -->
          <div class="lang-toggle-pill" id="rootLangPill" data-lang="en" role="radiogroup" aria-label="Gloss language">
            <div class="lang-pill-indicator"></div>
            <button class="lang-option active" data-lang="en" role="radio" aria-checked="true">EN</button>
            <button class="lang-option" data-lang="fr" role="radio" aria-checked="false">FR</button>
          </div>
        </div>
        <div class="drawer-body">

          <!-- Welcome Preface (First-run name collection) -->
          <div class="welcome-preface hidden" id="welcomePreface">
            <p class="preface-text" data-i18n="welcome.text">Welcome to Ilya. Your name will appear in the footer of every transcription you make.</p>
            <div class="preface-field">
              <input type="text" id="welcomeNameInput" 
                     placeholder="e.g. Dr. Jane Smith or J. Smith"
                     maxlength="50"
                     aria-label="Your name for attribution">
            </div>
            <div class="preface-actions">
              <button class="btn-primary" id="welcomeSaveBtn" data-i18n="welcome.save">Save</button>
              <a class="link-secondary" id="welcomeSkipBtn">Skip for now</a>
            </div>
          </div>

          <!-- Text Input (Phase 2B) -->
          <div class="drawer-input-section">
            <!-- Textarea with OCR overlay -->
            <div class="textarea-wrapper">
              <textarea
                class="drawer-textarea"
                id="drawerTextInput"
                placeholder="Paste Russian lyrics here..."
                data-i18n="input.placeholder" data-i18n-target="placeholder"
                aria-label="Russian text input"
              ></textarea>

              <!-- OCR: icon inside textarea top-right corner -->
              <button class="ocr-overlay-btn" id="drawerOcrBtn"
                      aria-label="Import Russian text from image"
                      disabled
                      title="Loading Russian language pack...">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 7V5a2 2 0 0 1 2-2h2"/>
                  <path d="M17 3h2a2 2 0 0 1 2 2v2"/>
                  <path d="M21 17v2a2 2 0 0 1-2 2h-2"/>
                  <path d="M7 21H5a2 2 0 0 1-2-2v-2"/>
                </svg>
              </button>

              <!-- Hidden file input for OCR -->
              <input type="file"
                     id="drawerOcrFileInput"
                     accept="image/*"
                     capture="environment"
                     aria-hidden="true"
                     style="display: none;">
            </div>

            <!-- Footer: character counter + OCR status -->
            <div class="drawer-input-footer">
              <div class="footer-status">
                <span class="char-counter" id="drawerCharCounter"></span>
                <span class="ocr-status" id="drawerOcrStatus" style="display: none;">
                  <svg class="spinner" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" stroke-opacity="0.25"/>
                    <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
                  </svg>
                  <span class="ocr-status-text"></span>
                </span>
              </div>
            </div>

            <!-- Action buttons -->
            <div class="drawer-input-actions">
              <div class="drawer-secondary-actions">
                <button class="btn btn-secondary" id="drawerClearBtn" data-i18n="btn.newText">New Text</button>
                <button type="button" class="btn btn-export" id="exportPdfBtn">
                  <svg class="export-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="12" y1="18" x2="12" y2="12"></line>
                    <line x1="9" y1="15" x2="12" y2="12"></line>
                    <line x1="15" y1="15" x2="12" y2="12"></line>
                  </svg>
                  <span data-i18n="page.exportPdf">Export PDF</span>
                </button>
                <button class="btn btn-primary" id="drawerTranscribeBtn" data-i18n="btn.transcribe">Transcribe</button>
              </div>
            </div>
          </div>

          <!-- Song Setup -->
          <div class="drawer-section-label" data-i18n="setup.heading">Song Setup</div>

          <!-- Title -->
          <div class="form-group">
            <input type="text" class="form-input" id="metaTitle" placeholder="Title" data-i18n="setup.title" data-i18n-target="placeholder">
          </div>

          <!-- Opus -->
          <div class="form-group">
            <input type="text" class="form-input" id="metaOpus" placeholder="Opus / Catalogue" data-i18n="setup.opus" data-i18n-target="placeholder">
          </div>

          <!-- Composer (searchable select) -->
          <div class="form-group">
            <div class="searchable-select" id="composerSelect">
              <button type="button" class="select-trigger" id="composerTrigger">
                <span class="placeholder" data-i18n="setup.composer">Composer</span>
                <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
              <div class="select-dropdown" id="composerDropdown">
                <input type="text" class="select-search" placeholder="Type to filter..." data-i18n="setup.filterPlaceholder" data-i18n-target="placeholder" id="composerSearch">
                <div class="select-options" id="composerOptions"></div>
              </div>
            </div>
          </div>

          <!-- Poet (searchable select) -->
          <div class="form-group">
            <div class="searchable-select" id="poetSelect">
              <button type="button" class="select-trigger" id="poetTrigger">
                <span class="placeholder" data-i18n="setup.poet">Poet / Librettist</span>
                <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
              <div class="select-dropdown" id="poetDropdown">
                <input type="text" class="select-search" placeholder="Type to filter..." data-i18n="setup.filterPlaceholder" data-i18n-target="placeholder" id="poetSearch">
                <div class="select-options" id="poetOptions"></div>
              </div>
            </div>
          </div>

          <!-- Transcriber Name -->
          <div class="form-group">
            <input type="text" class="form-input" id="metaTranscriber" placeholder="Your name (for attribution)" data-i18n="setup.name" data-i18n-target="placeholder">
            <div class="form-hint" data-i18n="setup.nameHint">Appears in document footer</div>
          </div>

          <!-- Transcription Profile -->
          <div class="profile-section" id="profileSection">
            <div class="profile-header" id="profileHeader">
              <div>
                <span class="profile-title" data-i18n="profile.label">Transcription Profile</span>
                <span class="profile-active" id="profileActive" data-i18n="profile.oldMuscovite">Old Muscovite</span>
              </div>
              <svg class="profile-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </div>
            <div class="profile-content">
              <select class="profile-select" id="profileSelect">
                <option value="old-muscovite" data-i18n="profile.oldMuscovite" selected>Old Muscovite</option>
                <option value="peterburgian" data-i18n="profile.peterburgian">Peterburgian</option>
                <option value="choral" data-i18n="profile.choral">Choral</option>
              </select>
              <div class="profile-description" id="profileDescription">
                <span class="info-icon-circle">i</span>
                <span data-i18n="profile.descOldMuscovite" data-i18n-target="html">Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]</span>
              </div>
              <div class="profile-future" data-i18n="page.viewProfiles">View all profiles →</div>
            </div>
          </div>

          <!-- Document Settings -->
          <div class="drawer-section-label" data-i18n="page.heading">Page</div>

          <div class="document-section" id="documentSection">
            <div class="document-header" id="documentHeader">
              <div>
                <span class="document-title" data-i18n="page.paperSize">Paper Size</span>
                <span class="document-active" id="documentActive">Letter (8.5×11)</span>
                <span class="document-pages" id="pageNumber">1 page</span>
              </div>
              <svg class="document-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </div>
            <div class="document-content">
              <div class="paper-size-control" id="paperSizeControl">
                <button type="button" class="paper-size-btn active" data-size="letter" id="paperSizeLetter">
                  <span class="paper-size-label" data-i18n="page.letter">Letter</span>
                  <span class="paper-size-dims">8.5 × 11 in</span>
                </button>
                <button type="button" class="paper-size-btn" data-size="a4" id="paperSizeA4">
                  <span class="paper-size-label" data-i18n="page.a4">A4</span>
                  <span class="paper-size-dims">210 × 297 mm</span>
                </button>
              </div>
            </div>
          </div>

        </div>
      </div>

      <!-- Drill State: Word Inspector (content migrated in Phase 3) -->
      <div class="drawer-inspector" id="drawerInspector">
        <!-- Inspector Header -->
        <div class="inspector-header">
          <button class="back-btn" id="drawerBackBtn" aria-label="Back to dashboard">←</button>
          <span class="inspector-word" id="inspectorWordDisplay">—</span>
          <!-- Language pill — Drill placement: inspector header, right-aligned (v6.0.53) -->
          <div class="lang-toggle-pill" id="drillLangPill" data-lang="en" role="radiogroup" aria-label="Gloss language">
            <div class="lang-pill-indicator"></div>
            <button class="lang-option active" data-lang="en" role="radio" aria-checked="true">EN</button>
            <button class="lang-option" data-lang="fr" role="radio" aria-checked="false">FR</button>
          </div>
        </div>
        
        <!-- Inspector Body -->
        <div class="inspector-body">
          
          <!-- Syllable Label (monosyllable/clitic context) -->
          <div class="inspector-syllable-label" id="inspectorSyllableLabel"></div>
          
          <!-- Syllable Buttons (interactive IPA) -->
          <div class="inspector-syllable-header" id="inspectorSyllableHeader">
            <div class="inspector-syllable-display" id="inspectorSyllableDisplay"></div>
            <button class="boundary-reset-btn" id="inspectorBoundaryResetBtn" title="Reset syllable boundaries" aria-label="Reset syllable boundaries" style="display: none;">↺</button>
          </div>
          
          <!-- ё lock feedback message -->
          <div class="yo-lock-message" id="inspectorYoLockMessage" data-i18n="inspector.yoLockMessage">⟨ё⟩ is always stressed</div>
          
          <!-- Stress source (proximity-grouped with syllable buttons) -->
          <div class="inspector-stress-source-row" id="inspectorStressSourceRow" aria-live="polite">
            <div class="inspector-stress-source-label" data-i18n="inspector.stressLabel">Identify stress source</div>
            <div class="segmented-control inspector-stress-source-control" id="inspectorStressSourceButtons">
              <button class="segment" id="inspectorStressDictionary" data-source="dictionary" data-i18n="inspector.stressDictionary">Dictionary</button>
              <button class="segment" id="inspectorStressComposer" data-source="composer" data-i18n="inspector.stressComposer">Composer</button>
              <button class="segment" id="inspectorStressUser" data-source="user" data-i18n="inspector.stressUser">My choice</button>
            </div>
          </div>
          
          <!-- Cyrillic Display -->
          <div class="inspector-cyrillic" id="inspectorCyrillic">—</div>
          
          <!-- Editable Gloss -->
          <div class="inspector-gloss-section">
            <span 
              class="inspector-gloss-inline" 
              id="inspectorGlossInline"
              contenteditable="true"
              role="textbox"
              aria-label="Translation"
              data-placeholder="add translation"
              data-i18n="inspector.glossPlaceholder" data-i18n-target="placeholder"
            ></span>
          </div>
          
          <!-- Phoneme Ribbon (Phase 3C) -->
          <div class="inspector-ribbon-section" id="inspectorRibbonSection">
            <div class="inspector-ribbon ribbon-vertical" id="inspectorRibbon">
              <!-- Populated by JavaScript -->
            </div>
          </div>
          
          <!-- Footer Controls (Phase 3D) -->
          <div class="inspector-controls" id="inspectorControls">
            
            <!-- Variant row (ё/е toggle) - rare but more common than assimilation -->
            <div class="inspector-control-row inspector-variant-row" id="inspectorVariantRow" style="display: none;">
              <div class="variant-row-main">
                <span class="inspector-control-label" id="inspectorVariantLabel" data-i18n="inspector.variantLabel">Restore ё:</span>
                <div class="segmented-control inspector-variant-control">
                  <button class="segment" id="inspectorVariantYo" data-variant="yo">ё</button>
                  <button class="segment" id="inspectorVariantYe" data-variant="ye">е</button>
                </div>
              </div>
              <div class="variant-confirm-row" id="inspectorVariantConfirm">
                <span class="variant-confirm-text">This changes the vowel sound and stress position.</span>
                <div class="variant-confirm-actions">
                  <button class="variant-cancel-btn" id="inspectorVariantCancel">Cancel</button>
                  <button class="variant-apply-btn" id="inspectorVariantApply">Apply</button>
                </div>
              </div>
            </div>
            
            <!-- Spacer pushes assimilation to bottom -->
            <div class="inspector-controls-spacer"></div>
            
            <!-- Assimilation row (word boundary control) - footer-docked, occasional use -->
            <div class="inspector-control-row inspector-assimilation-row" id="inspectorAssimilationRow" style="display: none;">
              <span class="inspector-control-label" id="inspectorBoundaryLabel" data-i18n="inspector.boundaryLabel">Break between [—] and [—]?</span>
              <div class="segmented-control inspector-assimilation-control">
                <button class="segment" id="inspectorAssimilationLinked" data-boundary="soft">No</button>
                <button class="segment" id="inspectorAssimilationSeparated" data-boundary="hard">Yes</button>
              </div>
            </div>
            
            <!-- Toast for ё warning -->
            <div class="inspector-yo-toast" id="inspectorYoToast">
              <span id="inspectorYoToastText">ё → е changes pronunciation</span>
              <div style="display: flex; gap: 6px;">
                <button class="undo-btn" id="inspectorYoUndoBtn">Undo</button>
                <button class="ok-btn" id="inspectorYoOkBtn">OK</button>
              </div>
            </div>
            
          </div>
          
        </div>
      </div>

    </aside>

    <!-- Scrim: tablet/mobile overlay backdrop -->
    <div class="drawer-scrim" id="drawerScrim"></div>
    
    <!-- Attribution arrow: fixed overlay straddling drawer edge -->
    <div class="stress-attribution-arrow" id="stressAttributionArrow" aria-hidden="true">
      <svg viewBox="0 0 32 24" width="48" height="36" xmlns="http://www.w3.org/2000/svg">
        <path d="M3,7 H18 V2 L30,12 L18,22 V17 H3 Q0,17 0,14 V10 Q0,7 3,7 Z" fill="var(--ilya-accent)"/>
      </svg>
    </div>
    
    <!-- Paper Aperture: Viewing area with inset depth -->
    <main class="paper-aperture" id="paperAperture">
      
      <!-- Paper Stack: Multi-page container (v5.9.4) -->
      <div class="paper-stack" id="paperStack">
        
        <!-- Pages render here dynamically -->
        
      </div>

    </main>

    <!-- Input Drawer: Bottom-anchored, collapsible -->
    <!-- Old input-drawer removed in Phase 2C - all input now in left drawer -->

  </div>

  <script>
/* STRESS DICTIONARY (Tiered Loading Architecture) — Kaikki.org Wiktionary extract — 1.29M words — Tier 1: 405K lemmas (loaded immediately) — Tier 2: 887K inflections (lazy loaded on interaction) */
let STRESS_DICTIONARY = {};
let DICTIONARY_LOADED = false;
let TIER2_LOADED = false;
let TIER2_LOADING = false;

// Gloss language state (v6.0.4)
// Supports bilingual glosses: {en: '...', fr: '...'}
let currentGlossLanguage = 'en';

// Metadata form references (dissolved from DashboardController in D.3)
let metaTitleInput, metaOpusInput, metaTranscriberInput, metaComposerSelect, metaPoetSelect, metaExportBtn;

// --- UI_LABELS + setUILanguage() (v6.0.54) — i18n skin system for static UI text. — Keys match data-i18n attributes (Phase A, item 4). — Must be top-level scope so DocumentState/DrawerState can access. ---
const UI_LABELS = {
  'welcome.text': {
    en: 'Welcome to Ilya. Your name will appear in the footer of every transcription you make.',
    fr: 'Bienvenue sur Ilya. Votre nom apparaîtra au bas de chaque transcription que vous réaliserez.'
  },
  'welcome.save': {
    en: 'Save',
    fr: 'Enregistrer'
  },
  'input.placeholder': {
    en: 'Paste Russian lyrics here...',
    fr: 'Collez le texte russe ici...'
  },
  'btn.newText': {
    en: 'New Text',
    fr: 'Nouveau texte'
  },
  'btn.transcribe': {
    en: 'Transcribe',
    fr: 'Transcrire'
  },
  'setup.heading': {
    en: 'Song Setup',
    fr: 'Détails du chant'
  },
  'setup.title': {
    en: 'Title',
    fr: 'Titre'
  },
  'setup.opus': {
    en: 'Opus / Catalogue',
    fr: 'Opus / Catalogue'
  },
  'setup.composer': {
    en: 'Composer',
    fr: 'Compositeur'
  },
  'setup.poet': {
    en: 'Poet / Librettist',
    fr: 'Poète / Librettiste'
  },
  'setup.name': {
    en: 'Your name (for attribution)',
    fr: 'Votre nom (pour l\u2019attribution)'
  },
  'setup.nameHint': {
    en: 'Appears in document footer',
    fr: 'Apparaît au bas du document'
  },
  'setup.filterPlaceholder': {
    en: 'Type to filter...',
    fr: 'Filtrer...'
  },
  'profile.label': {
    en: 'Transcription Profile',
    fr: 'Profil de transcription'
  },
  'page.heading': {
    en: 'Page',
    fr: 'Page'
  },
  'page.letter': {
    en: 'Letter',
    fr: 'Lettre'
  },
  'page.a4': {
    en: 'A4',
    fr: 'A4'
  },
  'page.exportPdf': {
    en: 'Export PDF',
    fr: 'Exporter en PDF'
  },
  'page.exportHint': {
    en: 'Opens print dialog. Select "Save as PDF".',
    fr: 'Ouvre la boîte d\u2019impression. Sélectionnez \u00ab\u202FEnregistrer en PDF\u202F\u00bb.'
  },
  'inspector.stressLabel': {
    en: 'Identify stress source',
    fr: 'Identifier la source de l\u2019accent'
  },
  'inspector.stressDictionary': {
    en: 'Dictionary',
    fr: 'Dictionnaire'
  },
  'inspector.stressComposer': {
    en: 'Composer',
    fr: 'Compositeur'
  },
  'inspector.stressUser': {
    en: 'My choice',
    fr: 'Mon choix'
  },
  'inspector.variantLabel': {
    en: 'Restore ё:',
    fr: 'Rétablir ё\u202F:'
  },
  'inspector.boundaryLabel': {
    en: 'Break between [—] and [—]?',
    fr: 'Frontière entre [—] et [—]\u202F?'
  },
  'inspector.glossPlaceholder': {
    en: 'add translation',
    fr: 'ajouter une traduction'
  },
  'inspector.clitic': {
    en: 'Unstressed clitic',
    fr: 'Clitique sans accent'
  },
  'inspector.stressedMono': {
    en: 'Stressed monosyllable',
    fr: 'Monosyllabe tonique'
  },
  'inspector.unstressedMono': {
    en: 'Unstressed monosyllable',
    fr: 'Monosyllabe sans accent'
  },
  'inspector.yoToastYoToYe': {
    en: 'ё → е changes pronunciation',
    fr: 'ё → е modifie la prononciation'
  },
  'inspector.yoToastYeToYo': {
    en: 'е → ё changes pronunciation',
    fr: 'е → ё modifie la prononciation'
  },
  'inspector.yoLockMessage': {
    en: '⟨ё⟩ is always stressed',
    fr: '⟨ё⟩ est toujours accentué'
  },
  'paper.verify': {
    en: 'verify',
    fr: 'à vérifier'
  },
  'paper.songTitle': {
    en: 'Song Title',
    fr: 'Titre du chant'
  },
  'counter.chars': {
    en: 'chars',
    fr: 'car.'
  },
  'profile.oldMuscovite': {
    en: 'Old Muscovite',
    fr: 'Vieux muscovite'
  },
  'profile.peterburgian': {
    en: 'Peterburgian',
    fr: 'Petersbourgeois'
  },
  'profile.choral': {
    en: 'Choral',
    fr: 'Choral'
  },
  'profile.descOldMuscovite': {
    en: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]',
    fr: 'Réduction vocalique <em>ikanié</em>, [ʃʲː] pour щ, adjectivaux scéniques [ɨj]'
  },
  'profile.descPeterburgian': {
    en: 'Ekanye vowel reduction, [ʃtʃ] for щ, modern adjectivals [ij]',
    fr: 'Réduction vocalique <em>ékanié</em>, [ʃtʃ] pour щ, adjectivaux modernes [ij]'
  },
  'profile.descChoral': {
    en: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj], reduced intensity for vowel matching',
    fr: 'Réduction vocalique <em>ikanié</em>, [ʃʲː] pour щ, adjectivaux scéniques [ɨj], intensité réduite pour l\u2019harmonisation vocalique'
  },
  'page.paperSize': {
    en: 'Paper Size',
    fr: 'Format du papier'
  },
  'page.viewProfiles': {
    en: 'View all profiles \u2192',
    fr: 'Voir tous les profils \u2192'
  },
  'page.countOne': {
    en: '1 page',
    fr: '1 page'
  },
  'page.countMany': {
    en: '{n} pages',
    fr: '{n} pages'
  }
};

/**
 * setUILanguage(lang)
 * Walks all elements with [data-i18n] and swaps their visible text.
 * Handles four target types:
 *   - placeholder: elements with data-i18n-target="placeholder"
 *   - aria-label: elements with data-i18n-target="aria"
 *   - html: elements with data-i18n-target="html" (allows <em> etc.)
 *   - textContent: default
 * Also refreshes profile section for current selection.
 * Falls back to English for any missing key.
 */
function setUILanguage(lang) {
  const target = (lang === 'fr') ? 'fr' : 'en';
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    const entry = UI_LABELS[key];
    if (!entry) return;
    const text = entry[target] || entry.en;
    const mode = el.getAttribute('data-i18n-target');
    if (mode === 'placeholder') {
      // Native inputs use .placeholder; contenteditable uses data-placeholder
      if (el.hasAttribute('placeholder')) {
        el.placeholder = text;
      } else {
        el.setAttribute('data-placeholder', text);
      }
    } else if (mode === 'aria') {
      el.setAttribute('aria-label', text);
    } else if (mode === 'html') {
      el.innerHTML = text;
    } else {
      el.textContent = text;
    }
  });
  
  // Refresh profile section for current selection (v6.0.54)
  if (typeof ProfileController !== 'undefined' && ProfileController.currentProfile) {
    ProfileController.setProfile(ProfileController.currentProfile);
  }
}

/**
 * Extract gloss in current language from new bilingual format
 * Handles both old format (string) and new format ({en, fr})
 */
function extractGloss(g) {
  if (!g) return currentGlossLanguage === 'fr' ? 'À VÉRIFIER' : '';
  
  // String format = English-only (legacy)
  if (typeof g === 'string') {
    return currentGlossLanguage === 'fr' ? 'À VÉRIFIER' : g;
  }
  
  // Object format = bilingual
  if (typeof g === 'object') {
    if (currentGlossLanguage === 'fr') {
      return g.fr || 'À VÉRIFIER';
    }
    return g.en || g.fr || '';
  }
  
  return '';
}

/**
 * Extract blurb text in current gloss language from bilingual format
 * Handles both old format (string) and new format ({en, fr})
 * @param {Object} blurbData - The blurb object with .blurb property
 * @returns {string} The blurb text in the current language
 */
function extractBlurbText(blurbData) {
  if (!blurbData || !blurbData.blurb) return '';
  
  const blurbContent = blurbData.blurb;
  
  // String format = English-only (legacy)
  let text;
  if (typeof blurbContent === 'string') {
    text = blurbContent;
  } else if (typeof blurbContent === 'object') {
    text = blurbContent[currentGlossLanguage] || blurbContent.en || '';
  } else {
    return '';
  }
  
  // Prevent IPA notation from breaking across lines (v6.0.52)
  // Wraps /…/, […], and ⟨…⟩ in nowrap spans
  text = text.replace(/\/[^/]+\//g, m => `<span style="white-space:nowrap">${m}</span>`);
  text = text.replace(/\[[^\]]+\]/g, m => `<span style="white-space:nowrap">${m}</span>`);
  text = text.replace(/⟨[^⟩]+⟩/g, m => `<span style="white-space:nowrap">${m}</span>`);
  
  return text;
}

// Tier 1: Load immediately, blocks until ready
async function loadTier1() {
    try {
        const response = await fetch('data/ilya_tier1_final.json.gz');
        if (response.ok) {
            const compressed = await response.arrayBuffer();
            const decompressed = pako.inflate(new Uint8Array(compressed), { to: 'string' });
            STRESS_DICTIONARY = JSON.parse(decompressed);
            DICTIONARY_LOADED = true;
            return;
        }
        
        // Fallback to legacy dictionary if tier1 not found
        const legacyResponse = await fetch('data/ilya_dictionary.json.gz');
        if (legacyResponse.ok) {
            const compressed = await legacyResponse.arrayBuffer();
            const decompressed = pako.inflate(new Uint8Array(compressed), { to: 'string' });
            STRESS_DICTIONARY = JSON.parse(decompressed);
            DICTIONARY_LOADED = true;
            return;
        }
        
    } catch (error) {
    }
}

// Tier 2: Lazy load with chunked merge to avoid UI freeze
async function loadTier2() {
    if (TIER2_LOADING || TIER2_LOADED) return;
    TIER2_LOADING = true;
    
    try {
        const response = await fetch('data/ilya_tier2.json.gz');
        if (!response.ok) {
            return;
        }
        
        const compressed = await response.arrayBuffer();
        const decompressed = pako.inflate(new Uint8Array(compressed), { to: 'string' });
        const inflections = JSON.parse(decompressed);
        
        // Chunked merge: 10K entries per frame to prevent UI jank
        const entries = Object.entries(inflections);
        const chunkSize = 10000;
        
        for (let i = 0; i < entries.length; i += chunkSize) {
            const chunk = entries.slice(i, i + chunkSize);
            chunk.forEach(([k, v]) => STRESS_DICTIONARY[k] = v);
            
            // Yield to main thread between chunks
            if (i + chunkSize < entries.length) {
                await new Promise(resolve => requestAnimationFrame(resolve));
            }
        }
        
        TIER2_LOADED = true;
        
    } catch (error) {
    } finally {
        TIER2_LOADING = false;
    }
}

// Trigger Tier 2 on first user interaction or after 5 seconds
let tier2Triggered = false;
function triggerTier2Load() {
    if (!tier2Triggered) {
        tier2Triggered = true;
        // Small delay to ensure UI is fully responsive first
        setTimeout(loadTier2, 100);
    }
}

// Attach interaction listeners (fire once)
document.addEventListener('click', triggerTier2Load, { once: true });
document.addEventListener('keydown', triggerTier2Load, { once: true });
document.addEventListener('paste', triggerTier2Load, { once: true });

// Safety: Load Tier 2 after 5 seconds regardless
setTimeout(triggerTier2Load, 5000);

let SINGER_SUPPLEMENT = {};
let SUPPLEMENT_LOADED = false;
let _supplementLoadPromise = null;

async function loadSingerSupplement() {
    try {
        const response = await fetch('data/singer-supplement.json');
        if (response.ok) {
            SINGER_SUPPLEMENT = await response.json();
            SUPPLEMENT_LOADED = true;
        }
    } catch (error) {
    }
}

async function loadRuleRegistry() {
    try {
        const response = await fetch('data/rule-registry.json');
        if (response.ok) {
            RuleRegistry.blurbs = await response.json();
        }
    } catch (error) {
    }
}

// Start Tier 1, Singer's Supplement, and Rule Registry immediately
_supplementLoadPromise = Promise.all([loadTier1(), loadSingerSupplement(), loadRuleRegistry()]);

/* GLOSS FORMATTING HELPERS — Handles verbose grammatical descriptions from kaikki.org */
/**
 * Extract lemma from grammatical gloss text
 * e.g., "short feminine singular past indicative perfective of уга́снуть (ugásnutʹ)" → "угаснуть"
 */
function extractLemmaFromGloss(gloss) {
    if (!gloss) return null;
    
    // Pattern: "... of CYRILLIC_WORD (transliteration)" or just "... of CYRILLIC_WORD"
    const match = gloss.match(/of\s+([а-яёА-ЯЁ́]+)(?:\s*\(|$|\s|,)/i);
    if (match) {
        // Remove any combining accents from the extracted lemma
        return match[1].normalize('NFD').replace(/[\u0300-\u036f]/g, '').normalize('NFC').toLowerCase();
    }
    return null;
}

/**
 * Look up semantic gloss for a lemma
 */
function getLemmaGloss(lemma) {
    if (!lemma) return null;
    
    const lemmaEntry = STRESS_DICTIONARY[lemma];
    if (!lemmaEntry) return null;
    
    const entryGloss = Array.isArray(lemmaEntry) 
        ? (lemmaEntry[0].gloss || lemmaEntry[0].g || '')
        : (lemmaEntry.gloss || lemmaEntry.g || '');
    
    // Don't return if it's also a grammatical description
    if (entryGloss && !/^(short |inflection |nominative |genitive |dative |accusative |instrumental |prepositional )/i.test(entryGloss)) {
        return entryGloss;
    }
    return null;
}

/**
 * Curated short glosses for common words (Issue P)
 * These override verbose dictionary glosses to maintain column alignment.
 * Key = lemma (base form), so inflected forms inherit the gloss.
 */
// Bilingual curated glosses (v6.0.54)
// Fallback display glosses for common words whose dictionary entries
// contain verbose grammatical descriptions instead of clean translations.
// Format: {en, fr} — resolved by extractGloss() via currentGlossLanguage.
const CURATED_GLOSSES = new Map([
    // Personal pronouns
    ['я', { en: 'I', fr: 'je' }],
    ['ты', { en: 'you', fr: 'tu' }],
    ['он', { en: 'he', fr: 'il' }],
    ['она', { en: 'she', fr: 'elle' }],
    ['оно', { en: 'it', fr: 'cela' }],
    ['мы', { en: 'we', fr: 'nous' }],
    ['вы', { en: 'you (pl.)', fr: 'vous' }],
    ['они', { en: 'they', fr: 'ils/elles' }],
    // Pronoun oblique forms (when lemma lookup fails)
    ['меня', { en: 'me', fr: 'me' }],
    ['мне', { en: 'to me', fr: 'à moi' }],
    ['мной', { en: 'by me', fr: 'par moi' }],
    ['мною', { en: 'by me', fr: 'par moi' }],
    ['тебя', { en: 'you', fr: 'te' }],
    ['тебе', { en: 'you', fr: 'à toi' }],
    ['тобой', { en: 'by you', fr: 'par toi' }],
    ['тобою', { en: 'by you', fr: 'par toi' }],
    ['его', { en: 'him/his', fr: 'lui/son' }],
    ['него', { en: 'him', fr: 'lui' }],
    ['ему', { en: 'to him', fr: 'à lui' }],
    ['нему', { en: 'to him', fr: 'à lui' }],
    ['им', { en: 'by him', fr: 'par lui' }],
    ['ним', { en: 'him', fr: 'lui' }],
    ['её', { en: 'her', fr: 'elle/sa' }],
    ['неё', { en: 'her', fr: 'elle' }],
    ['ей', { en: 'to her', fr: 'à elle' }],
    ['ней', { en: 'her', fr: 'elle' }],
    ['ею', { en: 'by her', fr: 'par elle' }],
    ['нею', { en: 'by her', fr: 'par elle' }],
    ['нас', { en: 'us', fr: 'nous' }],
    ['нам', { en: 'to us', fr: 'à nous' }],
    ['нами', { en: 'by us', fr: 'par nous' }],
    ['вас', { en: 'you (pl.)', fr: 'vous' }],
    ['вам', { en: 'to you', fr: 'à vous' }],
    ['вами', { en: 'by you', fr: 'par vous' }],
    ['их', { en: 'them/their', fr: 'eux/leur' }],
    ['них', { en: 'them', fr: 'eux' }],
    ['ими', { en: 'by them', fr: 'par eux' }],
    ['ними', { en: 'them', fr: 'eux' }],
    // Possessives (all genders/cases)
    ['мой', { en: 'my', fr: 'mon' }],
    ['моя', { en: 'my', fr: 'ma' }],
    ['моё', { en: 'my', fr: 'mon' }],
    ['мои', { en: 'my', fr: 'mes' }],
    ['моего', { en: 'my', fr: 'mon' }],
    ['моей', { en: 'my', fr: 'ma' }],
    ['моему', { en: 'my', fr: 'mon' }],
    ['моим', { en: 'my', fr: 'mon' }],
    ['моими', { en: 'my', fr: 'mes' }],
    ['моих', { en: 'my', fr: 'mes' }],
    ['мою', { en: 'my', fr: 'ma' }],
    ['твой', { en: 'your', fr: 'ton' }],
    ['твоя', { en: 'your', fr: 'ta' }],
    ['твоё', { en: 'your', fr: 'ton' }],
    ['твои', { en: 'your', fr: 'tes' }],
    ['твоего', { en: 'your', fr: 'ton' }],
    ['твоей', { en: 'your', fr: 'ta' }],
    ['твоему', { en: 'your', fr: 'ton' }],
    ['твоим', { en: 'your', fr: 'ton' }],
    ['твоими', { en: 'your', fr: 'tes' }],
    ['твоих', { en: 'your', fr: 'tes' }],
    ['твою', { en: 'your', fr: 'ta' }],
    ['свой', { en: "one's own", fr: 'son propre' }],
    ['наш', { en: 'our', fr: 'notre' }],
    ['ваш', { en: 'your (pl.)', fr: 'votre' }],
    // Demonstratives
    ['этот', { en: 'this', fr: 'ce/cet' }],
    ['эта', { en: 'this', fr: 'cette' }],
    ['это', { en: 'this/it is', fr: 'ceci/c\'est' }],
    ['эти', { en: 'these', fr: 'ces' }],
    ['тот', { en: 'that', fr: 'celui-là' }],
    ['та', { en: 'that', fr: 'celle' }],
    ['то', { en: 'that', fr: 'cela' }],
    ['те', { en: 'those', fr: 'ceux/celles' }],
    // Interrogatives
    ['что', { en: 'what/that', fr: 'quoi/que' }],
    ['чего', { en: 'what', fr: 'de quoi' }],
    ['чему', { en: 'to what', fr: 'à quoi' }],
    ['чем', { en: 'what (instr.)', fr: 'par quoi' }],
    ['кто', { en: 'who', fr: 'qui' }],
    ['кого', { en: 'whom', fr: 'qui (acc.)' }],
    ['кому', { en: 'to whom', fr: 'à qui' }],
    ['кем', { en: 'by whom', fr: 'par qui' }],
    ['чей', { en: 'whose', fr: 'à qui' }],
    ['чья', { en: 'whose', fr: 'à qui' }],
    ['чьё', { en: 'whose', fr: 'à qui' }],
    ['чьи', { en: 'whose', fr: 'à qui' }],
    // Common adverbs
    ['где', { en: 'where', fr: 'où' }],
    ['как', { en: 'how', fr: 'comment' }],
    ['когда', { en: 'when', fr: 'quand' }],
    ['здесь', { en: 'here', fr: 'ici' }],
    ['там', { en: 'there', fr: 'là-bas' }],
    ['сюда', { en: 'hither', fr: 'par ici' }],
    ['туда', { en: 'thither', fr: 'par là' }],
    ['тут', { en: 'here', fr: 'ici' }],
    ['уже', { en: 'already', fr: 'déjà' }],
    ['уж', { en: 'already', fr: 'déjà' }],
    ['ещё', { en: 'still, yet', fr: 'encore' }],
    ['еще', { en: 'still, yet', fr: 'encore' }],
    // Quantifiers
    ['весь', { en: 'all', fr: 'tout' }],
    ['вся', { en: 'all', fr: 'toute' }],
    ['всё', { en: 'everything', fr: 'tout' }],
    ['все', { en: 'everyone', fr: 'tous' }],
    ['всех', { en: 'all', fr: 'tous' }],
    ['всем', { en: 'all', fr: 'tous' }],
    ['сам', { en: 'oneself', fr: 'soi-même' }],
    ['сама', { en: 'herself', fr: 'elle-même' }],
    ['само', { en: 'itself', fr: 'lui-même' }],
    ['сами', { en: 'themselves', fr: 'eux-mêmes' }],
    ['один', { en: 'one, alone', fr: 'un, seul' }],
    ['одна', { en: 'one, alone', fr: 'une, seule' }],
    ['одно', { en: 'one, alone', fr: 'un, seul' }],
    // Common verbs
    ['быть', { en: 'to be', fr: 'être' }],
    ['есть', { en: 'is/to eat', fr: 'est/manger' }],
    ['нет', { en: 'no/there is no', fr: 'non/il n\'y a pas' }],
    ['сойти', { en: 'to descend', fr: 'descendre' }],
    ['сойдём', { en: 'we will descend', fr: 'nous descendrons' }],
    ['сойду', { en: 'I will descend', fr: 'je descendrai' }],
    // Preposition-like
    ['между', { en: 'between', fr: 'entre' }],
    ['меж', { en: 'between', fr: 'entre' }],
    ['ради', { en: 'for the sake of', fr: "pour l'amour de" }],
    // Numbers
    ['два', { en: 'two', fr: 'deux' }],
    ['три', { en: 'three', fr: 'trois' }],
    // Common short words in vocal lit
    ['день', { en: 'day', fr: 'jour' }],
    ['ночь', { en: 'night', fr: 'nuit' }],
    ['путь', { en: 'path, way', fr: 'chemin, voie' }],
    ['жизнь', { en: 'life', fr: 'vie' }],
    ['смерть', { en: 'death', fr: 'mort' }],
    ['любовь', { en: 'love', fr: 'amour' }],
    ['душа', { en: 'soul', fr: 'âme' }],
    ['сердце', { en: 'heart', fr: 'cœur' }],
    ['час', { en: 'hour', fr: 'heure' }],
    ['год', { en: 'year', fr: 'an' }],
    ['век', { en: 'century, age', fr: 'siècle' }],
    // Additional common vocab (v5.11.18)
    ['странствие', { en: 'wandering', fr: 'errance' }],
    ['странствии', { en: 'wandering', fr: 'errance' }],
    ['странствия', { en: 'wandering', fr: 'errance' }],
    ['мгновение', { en: 'moment', fr: 'instant' }],
    ['мгновенье', { en: 'moment', fr: 'instant' }],
    ['воспоминание', { en: 'memory', fr: 'souvenir' }],
    ['воспоминанье', { en: 'memory', fr: 'souvenir' }],
    ['судьбина', { en: 'fate, destiny', fr: 'destin' }],
    ['провожать', { en: 'to see off', fr: 'accompagner' }],
    ['провождать', { en: 'to see off', fr: 'accompagner' }],
    ['угадать', { en: 'to guess', fr: 'deviner' }],
    ['годовщина', { en: 'anniversary', fr: 'anniversaire' }],
    ['годовщину', { en: 'anniversary', fr: 'anniversaire' }],
    ['бой', { en: 'battle, fight', fr: 'combat' }],
    ['бою', { en: 'battle', fr: 'combat' }],
    ['волна', { en: 'wave', fr: 'vague' }],
    ['волнах', { en: 'waves', fr: 'vagues' }],
    // v5.11.21: Additional Станцы vocab
    ['уединённый', { en: 'solitary', fr: 'solitaire' }],
    ['уединенный', { en: 'solitary', fr: 'solitaire' }],
    ['патриарх', { en: 'patriarch', fr: 'patriarche' }],
    ['забвенный', { en: 'forgotten', fr: 'oublié' }],
    ['младенец', { en: 'infant', fr: 'nourrisson' }],
    ['младенца', { en: 'infant', fr: 'nourrisson' }],
    ['уступаю', { en: 'I yield', fr: 'je cède' }],
    ['уступать', { en: 'to yield', fr: 'céder' }],
    ['тлеть', { en: 'to decay', fr: 'se décomposer' }],
    ['цвести', { en: 'to bloom', fr: 'fleurir' }],
    ['годину', { en: 'hour, time', fr: 'heure, temps' }],
    ['грядущей', { en: 'coming, future', fr: 'à venir' }],
    ['грядущий', { en: 'coming, future', fr: 'à venir' }],
    ['соседняя', { en: 'neighboring', fr: 'voisin(e)' }],
    ['долина', { en: 'valley', fr: 'vallée' }],
    ['охладелый', { en: 'cold, dead', fr: 'refroidi' }],
    ['прах', { en: 'dust, ashes', fr: 'cendres' }],
    ['бесчувственному', { en: 'insensible', fr: 'insensible' }],
    ['бесчувственный', { en: 'insensible', fr: 'insensible' }],
    ['истлевать', { en: 'to decay', fr: 'se décomposer' }],
    ['предел', { en: 'limit, end', fr: 'limite' }],
    ['пределу', { en: 'limit, end', fr: 'limite' }],
    ['почивать', { en: 'to rest, sleep', fr: 'reposer' }],
    ['гробовой', { en: 'grave, deathly', fr: 'sépulcral' }],
    ['гробового', { en: 'grave', fr: 'sépulcral' }],
    ['младая', { en: 'young', fr: 'jeune' }],
    ['равнодушная', { en: 'indifferent', fr: 'indifférent(e)' }],
    ['равнодушный', { en: 'indifferent', fr: 'indifférent' }],
    ['природа', { en: 'nature', fr: 'nature' }],
    ['краса', { en: 'beauty', fr: 'beauté' }],
    ['красою', { en: 'beauty', fr: 'beauté' }],
    ['вечною', { en: 'eternal', fr: 'éternel(le)' }],
    ['сиять', { en: 'to shine', fr: 'briller' }],
    // Test words
    ['резчик', { en: 'carver, cutter', fr: 'graveur' }],
]);

/**
 * Format gloss for word-stack display (minimal, translation only)
 */
function formatGlossForDisplay(gloss, pos, lemma, word) {
    // Bilingual gloss data takes priority (v6.0.48)
    if (gloss && typeof gloss === 'object' && (gloss.en || gloss.fr)) {
        return extractGloss(gloss);
    }
    
    // Check curated glosses first (word form, then lemma)
    if (word && CURATED_GLOSSES.has(word.toLowerCase())) {
        return extractGloss(CURATED_GLOSSES.get(word.toLowerCase()));
    }
    if (lemma && CURATED_GLOSSES.has(lemma.toLowerCase())) {
        return extractGloss(CURATED_GLOSSES.get(lemma.toLowerCase()));
    }
    
    // Blank for missing glosses: leave space for pencil users (v5.11.20)
    if (!gloss) return '';
    
    // First, try to extract a clean translation from verbose patterns
    const cleanedGloss = extractCleanGloss(gloss);
    
    // Detect verbose grammatical patterns from kaikki.org
    const isGrammatical = /^(short |inflection of|nominative |genitive |dative |accusative |instrumental |prepositional |comparative |superlative )/i.test(cleanedGloss) 
                       || /\b(singular|plural)\s+(of|past|present|future)\b/i.test(cleanedGloss);
    
    if (isGrammatical) {
        // Try lemma field first, then extract from gloss text
        const effectiveLemma = lemma || extractLemmaFromGloss(gloss);
        
        if (effectiveLemma) {
            // Look up lemma's semantic gloss
            const semanticGloss = getLemmaGloss(effectiveLemma);
            if (semanticGloss) {
                return truncateGloss(extractCleanGloss(semanticGloss), 5);
            }
            // Fallback: leave blank for pencil users (no arrow - v5.11.22)
            return '';
        }
        // No lemma found: leave blank
        return '';
    }
    
    // Clean, semantic gloss — truncate to 5 words max for PDF display
    return truncateGloss(cleanedGloss, 5);
}

/**
 * Extract clean translation from verbose dictionary glosses
 * Handles patterns like "Usually translated as 'this'" → "this"
 */
function extractCleanGloss(gloss) {
    if (!gloss) return '';
    
    // Pattern: "translated as X" or "Translated as X" — extract X
    let match = gloss.match(/translated as ["']?([^"'.,;\/]+)/i);
    if (match) return match[1].replace(/["']/g, '').trim();
    
    // Pattern: "diminutive of X: Y" or "augmentative of X: Y" → extract Y
    match = gloss.match(/^(?:diminutive|augmentative|pejorative|endearing form) of [^:]+:\s*(.+)$/i);
    if (match) return match[1].trim();
    
    // Pattern: simple gloss followed by verbose parenthetical explanation
    // e.g., "I (first-person singular subject pronoun)" → "I"
    // e.g., "house, building (a residential building)" → "house, building"
    // But keep useful clarifications like "birch (tree or wood)"
    match = gloss.match(/^([^(]+)\s*\((?:a |the |first|second|third|singular|plural|subject|object|nominative|genitive|dative|accusative|masculine|feminine|neuter)[^)]*\)$/i);
    if (match) return match[1].trim();
    
    // Pattern: starts with linguistic jargon followed by simple gloss in parens
    // e.g., "proximal demonstrative (this)" but NOT "birch (tree or wood)"
    if (/^(mostly |generic |proximal |distal |demonstrative )/i.test(gloss)) {
        match = gloss.match(/\(([a-z][^)]{0,20})\)\s*$/i);
        if (match && !/\d/.test(match[1])) return match[1].trim();
    }
    
    // No extraction pattern matched — return original
    return gloss;
}

/**
 * Truncate gloss to N words max AND M characters max, adding ellipsis if needed
 * v5.11.8: Reduced maxChars to 18 for tighter word stack layout
 */
function truncateGloss(gloss, maxWords, maxChars = 18) {
    if (!gloss) return '';
    
    // First, strip ALL parenthetical content for word stack display
    let cleaned = gloss.replace(/\s*\([^)]*\)/g, ''); // Remove all parentheticals
    cleaned = cleaned.replace(/\s*\([^)]*$/, ''); // Remove unclosed parentheticals
    cleaned = cleaned.trim();
    
    // Word limit (no ellipsis)
    const words = cleaned.split(/\s+/);
    if (words.length > maxWords) {
        cleaned = words.slice(0, maxWords).join(' ');
    }
    
    // Character limit - truncate at word boundary, no ellipsis
    if (cleaned.length > maxChars) {
        const truncatedWords = [];
        let charCount = 0;
        for (const word of cleaned.split(/\s+/)) {
            if (charCount + word.length + (truncatedWords.length > 0 ? 1 : 0) <= maxChars) {
                truncatedWords.push(word);
                charCount += word.length + (truncatedWords.length > 1 ? 1 : 0);
            } else {
                break;
            }
        }
        cleaned = truncatedWords.join(' ') || cleaned.slice(0, maxChars);
    }
    
    // Remove dangling particles after comma/semicolon (v5.11.19)
    // "to wander, to" → "to wander" (the trailing "to" is semantically incomplete)
    cleaned = cleaned.replace(/[,;]\s+(to|a|the|of|in|on|for|and|or)$/i, '');
    
    // Remove trailing punctuation for cleaner appearance
    cleaned = cleaned.replace(/[,;:]+$/, '');
    
    return cleaned;
}

/**
 * Add combining acute accent (U+0301) to the stressed vowel in Cyrillic text.
 * Exception: ё/Ё already indicates stress via dieresis, so no acute added.
 * 
 * @param {string} word - The Cyrillic word
 * @param {Array} syllables - Array of syllable objects with isStressed property
 * @returns {string} - Word with acute on stressed vowel (or unchanged if ё is stressed)
 */
function addStressMarkToCyrillic(word, syllables) {
    if (!syllables || syllables.length === 0) return word;
    
    // Find the stressed syllable
    const stressedSyl = syllables.find(s => s.isStressed);
    if (!stressedSyl) return word;
    
    // Find position of stressed syllable's Cyrillic in the word
    const vowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                           'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
    
    // Count vowels to find stressed syllable position
    let vowelCount = 0;
    let stressedSylIndex = 0;
    for (let i = 0; i < syllables.length; i++) {
        if (syllables[i].isStressed) {
            stressedSylIndex = i;
            break;
        }
    }
    
    // Now find the (stressedSylIndex + 1)th vowel in the word
    let currentVowelNum = 0;
    const chars = Array.from(word);
    let result = '';
    
    for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        result += char;
        
        if (vowels.has(char)) {
            if (currentVowelNum === stressedSylIndex) {
                // This is the stressed vowel — add acute unless it's ё/Ё
                if (char !== 'ё' && char !== 'Ё') {
                    result += '\u0301'; // Combining acute accent
                }
            }
            currentVowelNum++;
        }
    }
    
    return result;
}

/**
 * Add combining acute accent to the vowel in a syllable string (for syllable button display).
 * Exception: ё/Ё already indicates stress via dieresis, so no acute added.
 * 
 * @param {string} syllable - A single Cyrillic syllable
 * @returns {string} - Syllable with acute on its vowel (or unchanged if ё)
 */
function addAcuteToSyllable(syllable) {
    const vowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                           'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
    
    const chars = Array.from(syllable);
    let result = '';
    let acuteAdded = false;
    
    for (const char of chars) {
        result += char;
        if (!acuteAdded && vowels.has(char) && char !== 'ё' && char !== 'Ё') {
            result += '\u0301'; // Combining acute accent
            acuteAdded = true;
        }
    }
    
    return result;
}

    /* TRANSCRIPTION PROFILES */
    const TRANSCRIPTION_PROFILES = {
      'old-muscovite': {
        name: 'Old Muscovite',
        i18nName: 'profile.oldMuscovite',
        i18nDesc: 'profile.descOldMuscovite',
        default: true,
        params: {
          reduction: 'ikanye',
          shcha: 'shshokanye',    // [ʃʲː]
          adjectival: 'stage',     // [ɨj]
          intensity: 'full'
        },
        description: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]'
      },
      'peterburgian': {
        name: 'Peterburgian',
        i18nName: 'profile.peterburgian',
        i18nDesc: 'profile.descPeterburgian',
        params: {
          reduction: 'ekanye',
          shcha: 'shchokanye',    // [ʃtʃ]
          adjectival: 'modern',    // [ij]
          intensity: 'full'
        },
        description: 'Ekanye vowel reduction, [ʃtʃ] for щ, modern adjectivals [ij]'
      },
      'choral': {
        name: 'Choral',
        i18nName: 'profile.choral',
        i18nDesc: 'profile.descChoral',
        params: {
          reduction: 'ikanye',
          shcha: 'shshokanye',    // [ʃʲː]
          adjectival: 'stage',     // [ɨj]
          intensity: 'reduced'
        },
        description: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj], reduced intensity for vowel matching'
      }
    };
    
    /* TAB CONTROLLER (Mobile) */
    const TabController = {
      tabs: null,
      inputZone: null,
      dashboardZone: null,
      activeTab: 'text',
      
      init() {
        this.tabs = document.querySelectorAll('.drawer-tab');
        this.inputZone = document.getElementById('inputZone');
        this.dashboardZone = document.getElementById('dashboardZone');
        
        if (!this.tabs.length) return;
        
        this.tabs.forEach(tab => {
          tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
        
        // Check viewport and show appropriate zone
        this.handleResize();
        window.addEventListener('resize', () => this.handleResize());
      },
      
      switchTab(tabName) {
        this.activeTab = tabName;
        
        // Update tab buttons
        this.tabs.forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        
        // Update zones visibility (mobile only)
        if (window.innerWidth < 768) {
          this.inputZone.classList.toggle('hidden', tabName !== 'text');
          this.dashboardZone.classList.toggle('hidden', tabName !== 'details');
        }
      },
      
      handleResize() {
        // Desktop: show both zones
        if (window.innerWidth >= 768) {
          this.inputZone.classList.remove('hidden');
          this.dashboardZone.classList.remove('hidden');
        } else {
          // Mobile: show only active tab
          this.switchTab(this.activeTab);
        }
      }
    };
    
    /* SEARCHABLE SELECT CONTROLLER */
    const SearchableSelect = {
      instances: {},
      
      create(config) {
        const { id, trigger, dropdown, search, options, data, onSelect } = config;
        
        const instance = {
          isOpen: false,
          selectedValue: null,
          selectedDisplay: null,
          filteredData: [...data],
          highlightIndex: -1,
          
          open() {
            this.isOpen = true;
            trigger.classList.add('active');
            dropdown.classList.add('open');
            search.value = '';
            this.filteredData = [...data]; // Reset filtered data
            this.highlightIndex = -1;
            search.focus();
            this.render(this.filteredData);
          },
          
          close() {
            this.isOpen = false;
            trigger.classList.remove('active');
            dropdown.classList.remove('open');
            this.highlightIndex = -1;
          },
          
          toggle() {
            if (this.isOpen) this.close();
            else this.open();
          },
          
          select(item) {
            this.selectedValue = item;
            this.selectedDisplay = `${item.latin} (${item.dates})`;
            
            // Update trigger display
            trigger.innerHTML = `
              <span>${this.selectedDisplay}</span>
              <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            `;
            
            this.close();
            if (onSelect) onSelect(item);
          },
          
          filter(query) {
            const q = query.toLowerCase();
            this.filteredData = data.filter(item => 
              item.latin.toLowerCase().includes(q) ||
              item.cyrillic.toLowerCase().includes(q)
            );
            this.highlightIndex = -1;
            this.render(this.filteredData);
          },
          
          render(items) {
            let html = items.map((item, idx) => `
              <div class="select-option ${idx === this.highlightIndex ? 'highlighted' : ''}" data-index="${idx}">
                <span class="primary">${item.latin}</span>
                <span class="secondary">${item.cyrillic} • ${item.dates}</span>
              </div>
            `).join('');
            
            // Add "Not in list" option
            html += `<div class="select-option custom" data-custom="true">+ Not in list (enter custom)</div>`;
            
            options.innerHTML = html;
            
            // Bind click handlers
            options.querySelectorAll('.select-option').forEach(opt => {
              opt.addEventListener('click', () => {
                if (opt.dataset.custom) {
                  // Custom entry - for now just close
                  this.close();
                  // Future: show custom input
                } else {
                  const idx = parseInt(opt.dataset.index);
                  this.select(this.filteredData[idx]);
                }
              });
            });
          }
        };
        
        // Event listeners
        trigger.addEventListener('click', () => instance.toggle());
        search.addEventListener('input', (e) => instance.filter(e.target.value));
        
        // Make trigger focusable and respond to typing
        trigger.setAttribute('tabindex', '0');
        trigger.addEventListener('keydown', (e) => {
          // If typing a printable character, open and start filtering
          if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            if (!instance.isOpen) {
              instance.open();
            }
            search.value = e.key;
            instance.filter(e.key);
          } else if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            instance.toggle();
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (!instance.isOpen) instance.open();
          } else if (e.key === 'Escape') {
            instance.close();
          }
        });
        
        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!trigger.contains(e.target) && !dropdown.contains(e.target)) {
            instance.close();
          }
        });
        
        // Keyboard navigation
        search.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            instance.highlightIndex = Math.min(instance.highlightIndex + 1, instance.filteredData.length - 1);
            instance.render(instance.filteredData);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            instance.highlightIndex = Math.max(instance.highlightIndex - 1, 0);
            instance.render(instance.filteredData);
          } else if (e.key === 'Enter' && instance.highlightIndex >= 0) {
            e.preventDefault();
            instance.select(instance.filteredData[instance.highlightIndex]);
          } else if (e.key === 'Escape') {
            instance.close();
          }
        });
        
        this.instances[id] = instance;
        return instance;
      }
    };
    
    /* PROFILE CONTROLLER */
    const ProfileController = {
      section: null,
      header: null,
      select: null,
      description: null,
      activeLabel: null,
      currentProfile: 'old-muscovite',
      
      init() {
        this.section = document.getElementById('profileSection');
        this.header = document.getElementById('profileHeader');
        this.select = document.getElementById('profileSelect');
        this.description = document.getElementById('profileDescription');
        this.activeLabel = document.getElementById('profileActive');
        
        if (!this.section) return;
        
        // Toggle expand/collapse
        this.header.addEventListener('click', () => {
          this.section.classList.toggle('expanded');
        });
        
        // Profile selection
        this.select.addEventListener('change', (e) => {
          this.setProfile(e.target.value);
        });
      },
      
      setProfile(profileKey) {
        const profile = TRANSCRIPTION_PROFILES[profileKey];
        if (!profile) return;
        
        this.currentProfile = profileKey;
        const lang = currentGlossLanguage || 'en';
        const name = UI_LABELS[profile.i18nName]?.[lang] || profile.name;
        const desc = UI_LABELS[profile.i18nDesc]?.[lang] || profile.description;
        this.activeLabel.textContent = name;
        this.description.innerHTML = `
          <span class="info-icon-circle">i</span>
          <span>${desc}</span>
        `;
        
        // Update select option labels
        if (this.select) {
          Array.from(this.select.options).forEach(opt => {
            const p = TRANSCRIPTION_PROFILES[opt.value];
            if (p) opt.textContent = UI_LABELS[p.i18nName]?.[lang] || p.name;
          });
        }
        
        // TODO: Trigger re-transcription if content exists
      },
      
      getParams() {
        return TRANSCRIPTION_PROFILES[this.currentProfile]?.params || TRANSCRIPTION_PROFILES['old-muscovite'].params;
      }
    };
    
    /* PAPER MANAGER — Paper size, page count, and multi-page distribution */
    const PaperManager = {
      section: null,
      header: null,
      activeLabel: null,
      paperSizeBtns: null,
      pageNumberEl: null,
      currentSize: 'letter',
      lineHeightCache: null,
      lineHeightCacheHash: null,
      PAPER_HEIGHTS: {
        letter: 1056,  // 11in × 96dpi
        a4: 1123       // 297mm × 96dpi / 25.4
      },
      init() {
        this.section = document.getElementById('documentSection');
        this.header = document.getElementById('documentHeader');
        this.activeLabel = document.getElementById('documentActive');
        this.paperSizeBtns = document.querySelectorAll('.paper-size-btn');
        this.pageNumberEl = document.getElementById('pageNumber');
        if (!this.section) return;
        this.header.addEventListener('click', () => {
          this.section.classList.toggle('expanded');
        });
        this.paperSizeBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            this.setSize(btn.dataset.size);
          });
        });
        window.addEventListener('resize', () => {
          this.updatePageCount();
        });
      },
      setSize(size) {
        if (size === this.currentSize) return;
        this.currentSize = size;
        this.paperSizeBtns.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.size === size);
        });
        this.activeLabel.textContent = size === 'letter' ? 'Letter (8.5×11)' : 'A4 (210×297)';
        const pages = document.querySelectorAll('.paper-page');
        pages.forEach(page => {
          if (size === 'a4') {
            page.setAttribute('data-size', 'a4');
          } else {
            page.removeAttribute('data-size');
          }
        });
        setTimeout(() => {
          this.updatePageCount();
        }, 400);
      },
      getSize() {
        return this.currentSize;
      },
      updatePageCount() {
        if (!this.pageNumberEl) return;
        let totalPages = 1;
        if (DocumentState?.lines?.length > 0) {
          const lineCount = DocumentState.lines.length;
          const pages = this.distributeToPages(
            Array(lineCount).fill({}),
            null,
            this.currentSize
          );
          totalPages = pages.length;
        }
        const lang = currentGlossLanguage || 'en';
        if (totalPages === 1) {
          this.pageNumberEl.textContent = UI_LABELS['page.countOne'][lang];
        } else {
          this.pageNumberEl.textContent = UI_LABELS['page.countMany'][lang].replace('{n}', totalPages);
        }
      },
      invalidateCache() {
        this.lineHeightCache = null;
        this.lineHeightCacheHash = null;
      },
      formatRunningHeader(surname, title) {
        if (!surname && !title) return '';
        let shortTitle = title || '';
        if (shortTitle.length > 30) {
          shortTitle = shortTitle.slice(0, 27) + '...';
        }
        if (surname && shortTitle) {
          return `${surname.toUpperCase()} — ${shortTitle.toUpperCase()}`;
        }
        return (surname || shortTitle).toUpperCase();
      },
      distributeToPages(allLines, targets = null, paperSize = 'letter') {
        const { page1, subsequent } = targets || { page1: 6, subsequent: 8 };
        const pages = [];
        let cursor = 0;
        if (allLines.length > 0) {
          pages.push({
            pageNumber: 1,
            template: 'title',
            lines: allLines.slice(0, page1)
          });
          cursor = page1;
        }
        while (cursor < allLines.length) {
          pages.push({
            pageNumber: pages.length + 1,
            template: 'subsequent',
            lines: allLines.slice(cursor, cursor + subsequent)
          });
          cursor += subsequent;
        }
        if (pages.length === 0) {
          pages.push({
            pageNumber: 1,
            template: 'title',
            lines: []
          });
        }
        return pages;
      }
    };
    
    /* METADATA UTILITIES */
    function updateExportButton() {
      if (!metaExportBtn) return;
      const hasContent = DocumentState.lines.length > 0;
      metaExportBtn.disabled = !hasContent;
      metaExportBtn.title = hasContent ? 'Export transcription as PDF' : 'Transcribe text first';
    }
    function exportPDF() {
      if (DocumentState.lines.length === 0) {
        alert('Please transcribe some text first.');
        return;
      }
      const title = metaTitleInput?.value || 'Ilya Transcription';
      const originalTitle = document.title;
      document.title = title;
      window.print();
      setTimeout(() => {
        document.title = originalTitle;
      }, 1000);
    }

    /* PAPER RENDERER — Paper DOM construction and page layout */
    const PaperRenderer = {
      render(fallbackMode = false) {
        const paperStack = document.getElementById('paperStack');
        const paperSize = PaperManager.getSize();
        if (!paperStack) return;
        paperStack.innerHTML = '';
        if (!DocumentState.lines || DocumentState.lines.length === 0) {
          const emptyPage = this.createPageElement(1, 'title', [], 1, paperSize);
          paperStack.appendChild(emptyPage);
          PaperManager.updatePageCount();
          updateExportButton();
          return;
        }
        const transcribedLines = InputManager.transcribeAllLines();
        const targets = fallbackMode 
          ? { page1: 5, subsequent: 7 }
          : { page1: 6, subsequent: 8 };
        const pages = PaperManager.distributeToPages(transcribedLines, targets, paperSize);
        const totalPages = pages.length;
        pages.forEach((pageData, pageIdx) => {
          const pageElement = this.createPageElement(
            pageData.pageNumber,
            pageData.template,
            pageData.lines,
            totalPages,
            paperSize
          );
          paperStack.appendChild(pageElement);
        });
        if (!fallbackMode) {
          const hasOverflow = this.detectOverflow();
          if (hasOverflow) {
            this.render(true);
            return;
          }
        }
        PaperManager.updatePageCount();
        updateExportButton();
      },
      detectOverflow() {
        const pages = document.querySelectorAll('.paper-page');
        let hasOverflow = false;
        pages.forEach((page, idx) => {
          const pageContent = page.querySelector('.page-content');
          const footer = page.querySelector('.page-footer');
          if (!pageContent || !footer) return;
          const lastVerseLine = pageContent.querySelector('.verse-line:last-child');
          if (!lastVerseLine) return;
          const lineRect = lastVerseLine.getBoundingClientRect();
          const footerRect = footer.getBoundingClientRect();
          const lineBottom = lineRect.bottom;
          const footerTop = footerRect.top;
          if (lineBottom > footerTop - 20) {
            hasOverflow = true;
          }
        });
        return hasOverflow;
      },
      createPageElement(pageNumber, template, lines, totalPages, paperSize) {
        const page = document.createElement('article');
        page.className = 'paper-page';
        page.setAttribute('data-template', template);
        page.setAttribute('data-page', pageNumber);
        if (paperSize === 'a4') {
          page.setAttribute('data-size', 'a4');
        }
        const title = metaTitleInput?.value || UI_LABELS['paper.songTitle'][currentGlossLanguage || 'en'];
        const opus = metaOpusInput?.value || '';
        const formatNameForDisplay = (item) => {
          if (!item) return '';
          const name = item.latin || '';
          const dates = item.dates || '';
          const parts = name.split(',').map(p => p.trim());
          const displayName = parts.length > 1 ? `${parts[1]} ${parts[0]}` : name;
          return dates ? `${displayName} (${dates})` : displayName;
        };
        const composerDisplay = formatNameForDisplay(metaComposerSelect?.selectedValue);
        const poetDisplay = formatNameForDisplay(metaPoetSelect?.selectedValue);
        const composerSurname = metaComposerSelect?.selectedValue?.latin?.split(',')[0]?.trim() || '';
        let headerHTML = '';
        if (template === 'title') {
          headerHTML = `
            <div class="page-logo">
              <span class="bracket">[</span>
              <span class="logo-name">Ilya</span>
              <span class="bracket">]</span>
            </div>
            <header class="page-header-title">
              <h1 class="page-title">${title}</h1>
              <div class="page-metadata">
                ${composerDisplay ? `<span>${composerDisplay}</span>` : ''}
                ${composerDisplay && opus ? '<span class="divider">│</span>' : ''}
                ${opus ? `<span>${opus}</span>` : ''}
              </div>
              ${poetDisplay ? `<div class="page-metadata"><span>Text by ${poetDisplay}</span></div>` : ''}
              <hr class="page-metadata-rule">
            </header>
          `;
        } else {
          const runningHeader = PaperManager.formatRunningHeader(composerSurname, title);
          headerHTML = `
            <header class="page-header-running">
              <span class="running-title">${runningHeader}</span>
            </header>
          `;
        }
        let contentHTML = '';
        if (lines.length === 0 && template === 'title') {
          contentHTML = `
            <main class="page-content empty">
              <span class="page-ghost-text">
                Click here to open the drawer interface where you can type or paste Cyrillic Russian text.<br>
                Cliquez ici pour ouvrir le tiroir où vous pouvez coller ou saisir votre texte russe en cyrillique.
              </span>
            </main>
          `;
        } else {
          const linesHTML = lines.map(line => this.renderVerseLine(line)).join('');
          contentHTML = `
            <main class="page-content">
              <div class="verse-container">${linesHTML}</div>
            </main>
          `;
        }
        const storedName = DocumentState.userName;
        const hasName = storedName && storedName.trim() !== '';
        const canadaFlag = `<svg xmlns="http://www.w3.org/2000/svg" width="1.5em" height="0.75em" viewBox="0 0 9600 4800" style="vertical-align: middle; margin-left: 0.25em;"><path fill="#f00" d="m0 0h2400l99 99h4602l99-99h2400v4800h-2400l-99-99h-4602l-99 99H0z"/><path fill="#fff" d="m2400 0h4800v4800h-4800zm2490 4430-45-863a95 95 0 0 1 111-98l859 151-116-320a65 65 0 0 1 20-73l941-762-212-99a65 65 0 0 1-34-79l186-572-542 115a65 65 0 0 1-73-38l-105-247-423 454a65 65 0 0 1-111-57l204-1052-327 189a65 65 0 0 1-91-27l-332-652-332 652a65 65 0 0 1-91 27l-327-189 204 1052a65 65 0 0 1-111 57l-423-454-105 247a65 65 0 0 1-73 38l-542-115 186 572a65 65 0 0 1-34 79l-212 99 941 762a65 65 0 0 1 20 73l-116 320 859-151a95 95 0 0 1 111 98l-45 863z"/></svg>`;
        const footerText = currentGlossLanguage === 'fr' ? {
          para1: hasName 
            ? `Cette transcription a été réalisée par ${storedName} à l'aide d'<em>Ilya</em> v1.0, qui met en œuvre la <em>Russian Lyric Diction</em> du Dr Craig Grayson (Université de Washington, 2012). Données d'accentuation (1,3 million de mots) et gloses de traduction issues des Wiktionnaires anglais et français via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`
            : `Transcription par [non attribué] réalisée à l'aide d'<em>Ilya</em> v1.0, qui met en œuvre la <em>Russian Lyric Diction</em> du Dr Craig Grayson (Université de Washington, 2012). Données d'accentuation (1,3 million de mots) et gloses de traduction issues des Wiktionnaires anglais et français via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`,
          para2: `<em>Ilya</em> est un outil pédagogique libre et gratuit destiné au personnel enseignant et aux artistes interprètes : ni <em>Ilya</em> ni ses transcriptions ne peuvent être redistribués ou vendus. Conçu avec amour au Canada.${canadaFlag}`,
          pagination: `Page ${pageNumber} sur ${totalPages}`
        } : {
          para1: hasName
            ? `This transcription was created by ${storedName} using <em>Ilya</em> v1.0, which operationalizes Dr. Craig Grayson's <em>Russian Lyric Diction</em> (University of Washington, 2012). 1.3M-word stress data and translation glosses from English and French Wiktionary via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`
            : `Transcription by [unattributed] using <em>Ilya</em> v1.0, which operationalizes Dr. Craig Grayson's <em>Russian Lyric Diction</em> (University of Washington, 2012). 1.3M-word stress data and translation glosses from English and French Wiktionary via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`,
          para2: `<em>Ilya</em> is a free, open-source scholarly tool for teachers and performing artists: neither it nor its transcriptions may be repackaged or sold. Made with love in Canada.${canadaFlag}`,
          pagination: `Page ${pageNumber} of ${totalPages}`
        };
        const footerHTML = `
          <footer class="page-footer">
            <div class="footer-attribution">
              <p>${footerText.para1}</p>
              <p>${footerText.para2}</p>
            </div>
            <div class="footer-pagination">
              ${footerText.pagination}
            </div>
          </footer>
        `;
        page.innerHTML = headerHTML + contentHTML + footerHTML;
        return page;
      },
      renderVerseLine(transcribedWords) {
        if (!transcribedWords || !transcribedWords.length) return '';
        const wordStacksHTML = transcribedWords.map((tw, wordIdx) => {
          const classes = ['word-stack'];
          if (tw.isProclitic) classes.push('proclitic');
          if (tw.isEnclitic) classes.push('enclitic');
          if (tw.isVowellessClitic) classes.push('vowelless-clitic');
          const isInferred = tw.wordData?.stressSource === 'inferred';
          const dataAttrs = `
            data-word-id="${tw.lineIdx}-${tw.wordIdx}"
            data-line-index="${tw.lineIdx}"
            data-word-index="${tw.wordIdx}"
            data-cyrillic="${tw.cleanWord}"
            data-ipa="${tw.ipaSurface}"
            data-ipa-underlying="${tw.ipaUnderlying}"
            data-gloss="${typeof tw.wordData?.gloss === 'object' ? extractGloss(tw.wordData.gloss) : (tw.wordData?.gloss || '')}"
            data-pos="${tw.wordData?.pos || ''}"
            data-lemma="${tw.wordData?.lemma || ''}"
            data-punctuation="${tw.punct}"
            data-syllables='${JSON.stringify(tw.syllables)}'
            data-is-proclitic="${tw.isProclitic}"
            data-is-enclitic="${tw.isEnclitic}"
            data-is-o_-interjection="${tw.isO_Interjection || false}"
            data-is-first-word="${tw.isFirstWord || false}"
            data-line-ends-with-question="${tw.lineEndsWithQuestion || false}"
            data-proclitic-position="${tw.procliticPosition || ''}"
            data-has-yo="${tw.hasYo}"
            data-stress-source="${tw.wordData?.stressSource || ''}"
            data-right-boundary="${tw.rightBoundary || ''}"
            data-boundary-source="${tw.boundarySource || ''}"
            data-transcription-log='${JSON.stringify(tw.transcriptionLog || [])}'
            data-original-input="${tw.wordData?.originalInput || ''}"
            data-dictionary-form="${tw.wordData?.dictionaryForm || ''}"
            data-yo-source="${tw.wordData?.yoSource || ''}"
          `;
          const wordStackHTML = `
            <div class="${classes.join(' ')}" tabindex="0" ${dataAttrs}>
              <span class="ipa">${tw.ipaDisplay}</span>
              <span class="cyrillic">${addStressMarkToCyrillic(tw.cleanWord, tw.syllables)}<span class="punct">${tw.punct}</span></span>
              <span class="gloss">${tw.isProclitic || tw.isEnclitic 
                ? extractGloss(GraysonEngine.cliticData.get(tw.cleanWord.toLowerCase())?.gloss)
                : formatGlossForDisplay(tw.wordData?.gloss, tw.wordData?.pos, tw.wordData?.lemma, tw.cleanWord)}</span>
            </div>
          `;
          if (isInferred) {
            return `
              <div class="stress-unverified-container" data-word="${tw.cleanWord}">
                <span class="stress-unverified-label">${UI_LABELS['paper.verify'][currentGlossLanguage || 'en']}</span>
                ${wordStackHTML}
              </div>
            `;
          }
          return wordStackHTML;
        }).join('');
        return `<div class="verse-line" role="row">${wordStacksHTML}</div>`;
      }
    };

    /* INPUT MANAGER — Text input, transcription orchestration, and OCR */
    const InputManager = {
      textInput: null,
      clearBtn: null,
      charCounter: null,
      ocrScanBtn: null,
      ocrFileInput: null,
      ocrStatus: null,
      ocrStatusText: null,
      init() {
        this.textInput = document.getElementById('drawerTextInput');
        this.clearBtn = document.getElementById('drawerClearBtn');
        this.charCounter = document.getElementById('drawerCharCounter');
        this.ocrScanBtn = document.getElementById('drawerOcrBtn');
        this.ocrFileInput = document.getElementById('drawerOcrFileInput');
        this.ocrStatus = document.getElementById('drawerOcrStatus');
        this.ocrStatusText = this.ocrStatus?.querySelector('.ocr-status-text');
        this.initOCR();
        this.textInput?.addEventListener('input', () => this.updateCharCounter());
        this.clearBtn?.addEventListener('click', () => this.clear());
      },
      updateCharCounter() {
        if (!this.charCounter || !this.textInput) return;
        const len = this.textInput.value.length;
        if (len > 0) {
          this.charCounter.textContent = `${len} ${UI_LABELS['counter.chars'][currentGlossLanguage || 'en']}`;
          this.charCounter.classList.add('visible');
          this.charCounter.classList.toggle('warning', len > 5000);
          this.charCounter.classList.toggle('error', len > 10000);
        } else {
          this.charCounter.classList.remove('visible');
        }
      },
      clear() {
        if (DocumentState.lines.length > 0) {
          const msg = currentGlossLanguage === 'fr'
            ? 'Effacer la transcription ? Cette action est irréversible.'
            : 'Clear transcription? This cannot be undone.';
          if (!confirm(msg)) {
            return;
          }
        }
        if (this.textInput) this.textInput.value = '';
        this.updateCharCounter();
        DocumentState.lines = [];
        PaperRenderer.render();
        this.textInput?.focus();
      },
      async transcribe() {
        const text = this.textInput?.value?.trim() || '';
        if (!text) {
          this.textInput?.focus();
          return;
        }
        if (_supplementLoadPromise) {
          await _supplementLoadPromise;
        }
        const lines = text.split('\n').filter(line => line.trim());
        PaperManager.invalidateCache();
        DocumentState.lines = lines.map(line => {
          const words = line.trim().split(/\s+/)
            .filter(word => {
              const cleaned = word.replace(/[.,!?;:"""''–—\-]/g, '');
              return cleaned.length > 0;
            });
          return words.map(word => {
            const lookup = GraysonEngine.lookupStress(word);
            let displayWord = word;
            let wasYoRestored = false;
            let dictionaryForm = null;
            if (lookup?.source === 'yo-restored' && lookup.canonicalForm) {
              displayWord = GraysonEngine.applyCasePattern(word, lookup.canonicalForm);
              dictionaryForm = displayWord;
              wasYoRestored = true;
            }
            const yoSyllable = GraysonEngine.findYoSyllable(displayWord);
            let stress, stressSource, yoSource;
            if (yoSyllable !== -1) {
              stress = yoSyllable;
              stressSource = wasYoRestored ? 'yo-restored' : 'yo-rule';
              yoSource = wasYoRestored ? 'yo-restored' : null;
            } else if (lookup) {
              stress = lookup.stress;
              stressSource = lookup.source;
              yoSource = null;
            } else {
              stress = 0;
              stressSource = 'inferred';
              yoSource = null;
            }
            return {
              cyrillic: displayWord,
              stress: stress,
              gloss: lookup ? lookup.gloss : '',
              pos: lookup ? lookup.pos : '',
              lemma: lookup ? lookup.lemma : '',
              isHomograph: lookup ? lookup.isHomograph : false,
              originalStress: stress,
              stressSource: stressSource,
              hasYo: yoSyllable !== -1,
              originalInput: wasYoRestored ? word : null,
              dictionaryForm: dictionaryForm,
              yoSource: yoSource,
              rightBoundary: null,
              boundarySource: null
            };
          });
        }).filter(line => line.length > 0);
        DocumentState.lines.forEach(line => {
          GraysonEngine.autoDetectBoundaries(line);
        });
        PaperRenderer.render();
        DrawerState.close();
      },
      transcribeAllLines() {
        return DocumentState.lines.map((line, lineIdx) => {
          const transcribedWords = line.map((wordData, wordIdx) => {
            const trailingPunctMatch = wordData.cyrillic.match(/[.,!?;:"""'']+$/);
            const punct = trailingPunctMatch ? trailingPunctMatch[0] : '';
            const cleanWord = wordData.cyrillic
              .replace(/[.,!?;:"""'']+$/, '')
              .replace(/[-–—]/g, '');
            const lineText = line.map(w => w.cyrillic).join(' ');
            const lineEndsWithQuestion = /\?$/.test(lineText.trim());
            const isFirstWord = wordIdx === 0;
            const isO_Word = cleanWord.toLowerCase() === 'о';
            const hasFollowingPunct = /[,!]/.test(punct);
            const isO_Interjection = isO_Word && (
              hasFollowingPunct ||
              (isFirstWord && !lineEndsWithQuestion)
            );
            const isProclitic = !isO_Interjection && GraysonEngine.proclitics.has(cleanWord.toLowerCase());
            const isEnclitic = GraysonEngine.enclitics.has(cleanWord.toLowerCase());
            const hasYo = GraysonEngine.hasYo(cleanWord);
            let procliticPosition = null;
            if (isProclitic && wordIdx < line.length - 1) {
              const nextWord = line[wordIdx + 1];
              const nextStress = nextWord.stress;
              procliticPosition = (nextStress === 0) ? 'pretonic' : 'remote';
            }
            const cliticStress = (isProclitic || isEnclitic) ? -1 : wordData.stress;
            const result = GraysonEngine.transcribe(cleanWord, cliticStress, isProclitic || isEnclitic, procliticPosition);
            return {
              wordData,
              wordIdx,
              lineIdx,
              cleanWord,
              punct,
              isProclitic,
              isEnclitic,
              isO_Interjection,
              isFirstWord,
              lineEndsWithQuestion,
              procliticPosition,
              hasYo,
              syllables: result.syllables,
              ipaUnderlying: result.ipaUnderlying,
              transcriptionLog: result.transcriptionLog,
              ipaSurface: null,
              skipFinalDevoicing: false,
              rightBoundary: wordData.rightBoundary,
              boundarySource: wordData.boundarySource
            };
          });
          GraysonEngine.applyCrossWordAssimilation(transcribedWords);
          transcribedWords.forEach(tw => {
            if (tw.ipaSurface !== tw.ipaUnderlying && tw.syllables.length > 0) {
              const lastSyl = tw.syllables[tw.syllables.length - 1];
              const underlyingConcat = tw.syllables.map(s => s.ipa).join('');
              const surfaceClean = tw.ipaSurface.replace(/[ˈ\s]+/g, '');
              const prefixLen = underlyingConcat.length - lastSyl.ipa.length;
              if (surfaceClean.length >= prefixLen) {
                const newLastSylIpa = surfaceClean.slice(prefixLen);
                lastSyl.ipa = newLastSylIpa;
                if (tw.transcriptionLog && tw.transcriptionLog.length > 0) {
                  for (let i = tw.transcriptionLog.length - 1; i >= 0; i--) {
                    const entry = tw.transcriptionLog[i];
                    if (entry.features && entry.features.type === 'consonant') {
                      const devoicingMap = GraysonEngine.voicedToVoiceless;
                      if (devoicingMap[entry.ipa]) {
                        entry.ipa = devoicingMap[entry.ipa];
                        entry.features.finalDevoicing = true;
                      }
                      break;
                    }
                  }
                }
              }
            }
            let ipaCore;
            if (tw.ipaSurface !== tw.ipaUnderlying) {
              ipaCore = tw.ipaSurface;
            } else {
              ipaCore = tw.syllables.map(s => {
                return s.isStressed ? 'ˈ' + s.ipa : s.ipa;
              }).join(' ');
            }
            tw.ipaContent = ipaCore;
            tw.ipaDisplay = ipaCore;
          });
          const cyrillicVowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                                          'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
          const hasVowel = (word) => {
            return Array.from(word).some(char => cyrillicVowels.has(char));
          };
          transcribedWords.forEach((tw, idx) => {
            if (tw.isProclitic || tw.isEnclitic) {
              const isVowelless = !hasVowel(tw.cleanWord);
              if (isVowelless) {
                if (tw.ipaSurface !== tw.ipaUnderlying) {
                  tw.ipaContent = tw.ipaSurface;
                } else {
                  const cliticInfo = GraysonEngine.cliticData.get(tw.cleanWord.toLowerCase());
                  tw.ipaContent = cliticInfo?.canonicalIpa || tw.ipaContent || '';
                }
              }
            }
            if (tw.isProclitic) {
              const nextWord = transcribedWords[idx + 1];
              const isVowelless = !hasVowel(tw.cleanWord);
              if (isVowelless) {
                tw.ipaDisplay = '→';
                tw.isVowellessClitic = true;
                if (nextWord && !nextWord.isProclitic) {
                  if (nextWord.ipaDisplay.startsWith('ˈ')) {
                    nextWord.ipaDisplay = 'ˈ' + tw.ipaContent + nextWord.ipaDisplay.slice(1);
                  } else {
                    nextWord.ipaDisplay = tw.ipaContent + nextWord.ipaDisplay;
                  }
                }
              } else {
                tw.ipaDisplay = '→';
                tw.isVowellessClitic = false;
                if (nextWord && !nextWord.isProclitic) {
                  nextWord.ipaDisplay = tw.ipaContent + ' ' + nextWord.ipaDisplay;
                }
              }
            } else if (tw.isEnclitic) {
              const prevWord = transcribedWords[idx - 1];
              const isVowelless = !hasVowel(tw.cleanWord);
              if (isVowelless) {
                tw.ipaDisplay = '←';
                tw.isVowellessClitic = true;
                if (prevWord && !prevWord.isEnclitic) {
                  prevWord.ipaDisplay = prevWord.ipaDisplay + tw.ipaContent;
                }
              } else {
                tw.ipaDisplay = '←';
                tw.isVowellessClitic = false;
                if (prevWord && !prevWord.isEnclitic) {
                  prevWord.ipaDisplay = prevWord.ipaDisplay + ' ' + tw.ipaContent;
                }
              }
            }
          });
          return transcribedWords;
        });
      },
      async initOCR() {
        if (!OCRModule.isSupported()) {
          if (this.ocrScanBtn) this.ocrScanBtn.style.display = 'none';
          return;
        }
        OCRModule.onError((msg) => {
          this.showOCRStatus('error', msg);
        });
        this.ocrScanBtn?.addEventListener('click', () => {
          if (this.ocrScanBtn && !this.ocrScanBtn.disabled) {
            this.ocrFileInput?.click();
          }
        });
        this.ocrFileInput?.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          await this.processOCRFile(file);
          if (this.ocrFileInput) this.ocrFileInput.value = '';
        });
        try {
          const loaded = await OCRModule.init();
          if (loaded && this.ocrScanBtn) {
            this.ocrScanBtn.disabled = false;
            this.ocrScanBtn.title = 'Import Russian text from image';
          }
        } catch (err) {
          if (this.ocrScanBtn) this.ocrScanBtn.title = 'OCR unavailable';
        }
      },
      async processOCRFile(file) {
        this.charCounter?.classList.remove('visible');
        const statusMessages = {
          'loading tesseract': 'Loading recognition engine...',
          'loading language': 'Loading Russian dictionary...',
          'loading eng+rus traineddata': 'Loading Russian dictionary...',
          'loaded eng+rus traineddata': 'Dictionary loaded.',
          'processing': 'Analyzing image...',
          'recognizing text': 'Reading Cyrillic text...',
          'recognizing': 'Reading Cyrillic text...',
          'cleaning': 'Cleaning up results...'
        };
        try {
          const text = await OCRModule.processImage(file, (status, progress) => {
            const message = statusMessages[status] || status;
            this.showOCRStatus('processing', message);
          });
          if (text && this.textInput) {
            const existingText = this.textInput.value.trim();
            if (existingText) {
              this.textInput.value = existingText + '\n\n' + text;
            } else {
              this.textInput.value = text;
            }
            this.updateCharCounter();
            this.showOCRStatus('success', 'Import complete');
            setTimeout(() => this.hideOCRStatus(), 3000);
          }
        } catch (err) {
          this.showOCRStatus('error', err.message || 'Failed to read image');
          setTimeout(() => this.hideOCRStatus(), 5000);
        }
      },
      showOCRStatus(type, message) {
        if (!this.ocrStatus) return;
        this.ocrStatus.style.display = 'flex';
        this.ocrStatus.className = 'ocr-status ' + type;
        if (this.ocrStatusText) {
          this.ocrStatusText.textContent = message;
        }
        const spinner = this.ocrStatus.querySelector('.spinner');
        if (spinner) {
          spinner.style.display = type === 'processing' ? 'block' : 'none';
        }
      },
      hideOCRStatus() {
        if (this.ocrStatus) {
          this.ocrStatus.style.display = 'none';
        }
      }
    };


    /* LOOKUP TABLES: Composers and Poets */
    const COMPOSERS = [
      { latin: 'Rachmaninoff, Sergei', cyrillic: 'Рахманинов, Сергей', dates: '1873–1943' },
      { latin: 'Tchaikovsky, Pyotr', cyrillic: 'Чайковский, Пётр', dates: '1840–1893' },
      { latin: 'Mussorgsky, Modest', cyrillic: 'Мусоргский, Модест', dates: '1839–1881' },
      { latin: 'Rimsky-Korsakov, Nikolai', cyrillic: 'Римский-Корсаков, Николай', dates: '1844–1908' },
      { latin: 'Glinka, Mikhail', cyrillic: 'Глинка, Михаил', dates: '1804–1857' },
      { latin: 'Borodin, Alexander', cyrillic: 'Бородин, Александр', dates: '1833–1887' },
      { latin: 'Cui, César', cyrillic: 'Кюи, Цезарь', dates: '1835–1918' },
      { latin: 'Dargomyzhsky, Alexander', cyrillic: 'Даргомыжский, Александр', dates: '1813–1869' },
      { latin: 'Arensky, Anton', cyrillic: 'Аренский, Антон', dates: '1861–1906' },
      { latin: 'Medtner, Nikolai', cyrillic: 'Метнер, Николай', dates: '1880–1951' },
      { latin: 'Taneyev, Sergei', cyrillic: 'Танеев, Сергей', dates: '1856–1915' },
      { latin: 'Gretchaninov, Alexander', cyrillic: 'Гречанинов, Александр', dates: '1864–1956' },
      { latin: 'Glazunov, Alexander', cyrillic: 'Глазунов, Александр', dates: '1865–1936' },
      { latin: 'Rubinstein, Anton', cyrillic: 'Рубинштейн, Антон', dates: '1829–1894' },
      { latin: 'Balakirev, Mily', cyrillic: 'Балакирев, Милий', dates: '1837–1910' },
      { latin: 'Prokofiev, Sergei', cyrillic: 'Прокофьев, Сергей', dates: '1891–1953' },
      { latin: 'Shostakovich, Dmitri', cyrillic: 'Шостакович, Дмитрий', dates: '1906–1975' },
      { latin: 'Stravinsky, Igor', cyrillic: 'Стравинский, Игорь', dates: '1882–1971' },
      { latin: 'Scriabin, Alexander', cyrillic: 'Скрябин, Александр', dates: '1872–1915' },
      { latin: 'Kabalevsky, Dmitri', cyrillic: 'Кабалевский, Дмитрий', dates: '1904–1987' },
      { latin: 'Sviridov, Georgy', cyrillic: 'Свиридов, Георгий', dates: '1915–1998' },
      { latin: 'Varlamov, Alexander', cyrillic: 'Варламов, Александр', dates: '1801–1848' },
      { latin: 'Gurilev, Alexander', cyrillic: 'Гурилёв, Александр', dates: '1803–1858' },
      { latin: 'Bulakhov, Pyotr', cyrillic: 'Булахов, Пётр', dates: '1822–1885' },
      { latin: 'Titov, Nikolai', cyrillic: 'Титов, Николай', dates: '1800–1875' }
    ];

    const POETS = [
      { latin: 'Pushkin, Alexander', cyrillic: 'Пушкин, Александр', dates: '1799–1837' },
      { latin: 'Lermontov, Mikhail', cyrillic: 'Лермонтов, Михаил', dates: '1814–1841' },
      { latin: 'Tyutchev, Fyodor', cyrillic: 'Тютчев, Фёдор', dates: '1803–1873' },
      { latin: 'Fet, Afanasy', cyrillic: 'Фет, Афанасий', dates: '1820–1892' },
      { latin: 'Tolstoy, Alexei K.', cyrillic: 'Толстой, Алексей К.', dates: '1817–1875' },
      { latin: 'Nekrasov, Nikolai', cyrillic: 'Некрасов, Николай', dates: '1821–1878' },
      { latin: 'Koltsov, Alexei', cyrillic: 'Кольцов, Алексей', dates: '1809–1842' },
      { latin: 'Maykov, Apollon', cyrillic: 'Майков, Аполлон', dates: '1821–1897' },
      { latin: 'Pleshcheyev, Alexei', cyrillic: 'Плещеев, Алексей', dates: '1825–1893' },
      { latin: 'Polonsky, Yakov', cyrillic: 'Полонский, Яков', dates: '1819–1898' },
      { latin: 'Mey, Lev', cyrillic: 'Мей, Лев', dates: '1822–1862' },
      { latin: 'Apukhtin, Alexei', cyrillic: 'Апухтин, Алексей', dates: '1840–1893' },
      { latin: 'Rathaus, Daniil', cyrillic: 'Ратгауз, Даниил', dates: '1868–1937' },
      { latin: 'Galina, Glafira', cyrillic: 'Галина, Глафира', dates: '1870–1942' },
      { latin: 'Balmont, Konstantin', cyrillic: 'Бальмонт, Константин', dates: '1867–1942' },
      { latin: 'Bryusov, Valery', cyrillic: 'Брюсов, Валерий', dates: '1873–1924' },
      { latin: 'Blok, Alexander', cyrillic: 'Блок, Александр', dates: '1880–1921' },
      { latin: 'Akhmatova, Anna', cyrillic: 'Ахматова, Анна', dates: '1889–1966' },
      { latin: 'Tsvetaeva, Marina', cyrillic: 'Цветаева, Марина', dates: '1892–1941' },
      { latin: 'Yesenin, Sergei', cyrillic: 'Есенин, Сергей', dates: '1895–1925' },
      { latin: 'Mandelstam, Osip', cyrillic: 'Мандельштам, Осип', dates: '1891–1938' },
      { latin: 'Pasternak, Boris', cyrillic: 'Пастернак, Борис', dates: '1890–1960' },
      { latin: 'Zhukovsky, Vasily', cyrillic: 'Жуковский, Василий', dates: '1783–1852' },
      { latin: 'Baratynsky, Yevgeny', cyrillic: 'Баратынский, Евгений', dates: '1800–1844' },
      { latin: 'Delvig, Anton', cyrillic: 'Дельвиг, Антон', dates: '1798–1831' },
      { latin: 'Khomyakov, Alexei', cyrillic: 'Хомяков, Алексей', dates: '1804–1860' },
      { latin: 'Golenishchev-Kutuzov, Arseny', cyrillic: 'Голенищев-Кутузов, Арсений', dates: '1848–1913' },
      { latin: 'Merezhkovsky, Dmitry', cyrillic: 'Мережковский, Дмитрий', dates: '1865–1941' },
      { latin: 'Gippius, Zinaida', cyrillic: 'Гиппиус, Зинаида', dates: '1869–1945' },
      { latin: 'Sologub, Fyodor', cyrillic: 'Сологуб, Фёдор', dates: '1863–1927' },
      { latin: 'Bely, Andrei', cyrillic: 'Белый, Андрей', dates: '1880–1934' },
      { latin: 'Bunin, Ivan', cyrillic: 'Бунин, Иван', dates: '1870–1953' },
      { latin: 'Shevchenko, Taras', cyrillic: 'Шевченко, Тарас', dates: '1814–1861' },
      { latin: 'Heine, Heinrich', cyrillic: 'Гейне, Генрих', dates: '1797–1856' },
      { latin: 'Goethe, Johann Wolfgang', cyrillic: 'Гёте, Иоганн Вольфганг', dates: '1749–1832' }
    ];

    /* STRESS DICTIONARY (OpenRussian, 51,644 words) — CC-BY-SA-4.0 License */
;

    /* GRAYSON ENGINE */
    const GraysonEngine = {
      
      inventory: Object.freeze({
        vowels_stressed: {
          'а': 'ɑ', 'а_interpalatal': 'a',
          'о': 'o',
          'е': 'ɛ', 'е_interpalatal': 'e',
          'ё': 'o',
          'и': 'i',
          'ы': 'ɨ',
          'у': 'u',
          'ю': 'u',
          'я': 'ɑ', 'я_interpalatal': 'a',
          'э': 'ɛ'
        },
        vowels_unstressed: {
          'а_pretonic': 'ɑ', 'а_remote': 'ʌ',
          'о_pretonic': 'ɑ', 'о_remote': 'ʌ',
          'е_unstressed': 'ɪ',
          'и': 'i',
          'ы_unstressed': 'ɨ',
          'у_unstressed': 'u',
          'ю_unstressed': 'u',
          'я_unstressed': 'ɪ',
          'э_unstressed': 'ɪ'
        },
        consonants: {
          'б': 'b', 'п': 'p',
          'в': 'v', 'ф': 'f',
          'д': 'd', 'т': 't',
          'г': 'ɡ', 'к': 'k',
          'з': 'z', 'с': 's',
          'ж': 'ʒ', 'ш': 'ʃ',
          'х': 'x',
          'ц': 'ts',
          'ч': 'tʃʲ',
          'щ': 'ʃʲʃʲ',
          'л': 'l', 'л_hard': 'ɫ', 'л_soft': 'lʲ',
          'м': 'm',
          'н': 'n', 'н_soft': 'ɲ',
          'р': 'r',
          'й': 'j'
        },
        markers: {
          'palatalization': 'ʲ',
          'stress': 'ˈ'
        }
      }),
      
      vowels: new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я']),
      consonants: new Set(['б', 'в', 'г', 'д', 'ж', 'з', 'й', 'к', 'л', 'м', 'н', 'п', 'р', 'с', 'т', 'ф', 'х', 'ц', 'ч', 'ш', 'щ']),
      alwaysSoft: new Set(['ч', 'щ', 'й']),
      alwaysHard: new Set(['ж', 'ш', 'ц']),
      
      // Clitic data with canonical IPA for isolated forms (Grayson p. 248-257)
      // Canonical forms use pretonic reduction for proclitics, posttonic for enclitics
      cliticData: new Map([
        // Proclitics - canonical form assumes pretonic position
        // Short glosses curated for PDF display (v5.11.10)
        ['в', { type: 'proclitic', canonicalIpa: 'v', gloss: { en: 'in/into', fr: 'dans/en' } }],
        ['во', { type: 'proclitic', canonicalIpa: 'vɑ', gloss: { en: 'in/into', fr: 'dans/en' } }],
        ['к', { type: 'proclitic', canonicalIpa: 'k', gloss: { en: 'to/toward', fr: 'vers/à' } }],
        ['ко', { type: 'proclitic', canonicalIpa: 'kɑ', gloss: { en: 'to/toward', fr: 'vers/à' } }],
        ['с', { type: 'proclitic', canonicalIpa: 's', gloss: { en: 'with/from', fr: 'avec/de' } }],
        ['со', { type: 'proclitic', canonicalIpa: 'sɑ', gloss: { en: 'with/from', fr: 'avec/de' } }],
        ['о', { type: 'proclitic', canonicalIpa: 'ɑ', gloss: { en: 'about', fr: 'de/sur' } }],
        ['об', { type: 'proclitic', canonicalIpa: 'ɑb', gloss: { en: 'about', fr: 'de/sur' } }],
        ['обо', { type: 'proclitic', canonicalIpa: 'ɑbɑ', gloss: { en: 'about', fr: 'de/sur' } }],
        ['у', { type: 'proclitic', canonicalIpa: 'u', gloss: { en: 'at/by', fr: 'chez/près de' } }],
        ['на', { type: 'proclitic', canonicalIpa: 'nɑ', gloss: { en: 'on/onto', fr: 'sur' } }],
        ['за', { type: 'proclitic', canonicalIpa: 'zɑ', gloss: { en: 'behind/for', fr: 'derrière/pour' } }],
        ['по', { type: 'proclitic', canonicalIpa: 'pɑ', gloss: { en: 'along/by', fr: 'le long de/par' } }],
        ['до', { type: 'proclitic', canonicalIpa: 'dɑ', gloss: { en: 'until/to', fr: "jusqu'à" } }],
        ['из', { type: 'proclitic', canonicalIpa: 'iz', gloss: { en: 'from/out of', fr: 'de/hors de' } }],
        ['изо', { type: 'proclitic', canonicalIpa: 'izɑ', gloss: { en: 'from/out of', fr: 'de/hors de' } }],
        ['от', { type: 'proclitic', canonicalIpa: 'ɑt', gloss: { en: 'from', fr: 'de' } }],
        ['ото', { type: 'proclitic', canonicalIpa: 'ɑtɑ', gloss: { en: 'from', fr: 'de' } }],
        ['без', { type: 'proclitic', canonicalIpa: 'bʲɪz', gloss: { en: 'without', fr: 'sans' } }],
        ['не', { type: 'proclitic', canonicalIpa: 'ɲɪ', gloss: { en: 'not', fr: 'ne… pas' } }],
        ['ни', { type: 'proclitic', canonicalIpa: 'ɲi', gloss: { en: 'nor/not', fr: 'ni' } }],
        ['над', { type: 'proclitic', canonicalIpa: 'nɑt', gloss: { en: 'above', fr: 'au-dessus de' } }],
        ['надо', { type: 'proclitic', canonicalIpa: 'nɑdɑ', gloss: { en: 'above', fr: 'au-dessus de' } }],
        ['под', { type: 'proclitic', canonicalIpa: 'pɑt', gloss: { en: 'under', fr: 'sous' } }],
        ['подо', { type: 'proclitic', canonicalIpa: 'pɑdɑ', gloss: { en: 'under', fr: 'sous' } }],
        ['при', { type: 'proclitic', canonicalIpa: 'prʲi', gloss: { en: 'at/near', fr: 'près de/en présence de' } }],
        ['про', { type: 'proclitic', canonicalIpa: 'prɑ', gloss: { en: 'about', fr: 'au sujet de' } }],
        ['для', { type: 'proclitic', canonicalIpa: 'dlʲɑ', gloss: { en: 'for', fr: 'pour' } }],
        ['через', { type: 'proclitic', canonicalIpa: 'tʃʲɪrʲɪz', gloss: { en: 'through', fr: 'à travers' } }],
        ['перед', { type: 'proclitic', canonicalIpa: 'pʲɪrʲɪt', gloss: { en: 'before', fr: 'devant' } }],
        ['передо', { type: 'proclitic', canonicalIpa: 'pʲɪrʲɪdɑ', gloss: { en: 'before', fr: 'devant' } }],
        // Enclitics - canonical form assumes posttonic position
        ['ли', { type: 'enclitic', canonicalIpa: 'lʲi', gloss: { en: '(question)', fr: '(question)' } }],
        ['ль', { type: 'enclitic', canonicalIpa: 'lʲ', gloss: { en: '(question)', fr: '(question)' } }],
        ['же', { type: 'enclitic', canonicalIpa: 'ʒɨ', gloss: { en: '(emphasis)', fr: '(emphase)' } }],
        ['бы', { type: 'enclitic', canonicalIpa: 'bɨ', gloss: { en: 'would', fr: '(conditionnel)' } }],
        ['б', { type: 'enclitic', canonicalIpa: 'b', gloss: { en: 'would', fr: '(conditionnel)' } }],
        ['то', { type: 'enclitic', canonicalIpa: 'tɑ', gloss: { en: '(then)', fr: '(alors)' } }],
        ['ка', { type: 'enclitic', canonicalIpa: 'kɑ', gloss: { en: '(urging)', fr: '(exhortation)' } }],
        ['таки', { type: 'enclitic', canonicalIpa: 'tɑkʲi', gloss: { en: 'after all', fr: 'tout de même' } }],
      ]),
      
      // Derived Sets for backwards compatibility (computed once, not on every access)
      proclitics: null, // Initialized below
      enclitics: null,  // Initialized below
      
      // Regressive palatalization categorical restrictions (Grayson p. 209; Derwing & Priestly pp. 76-87)
      // These consonants BLOCK regressive palatalization — consonants before them do not soften
      // NOTE: Grayson's example сестрёнка /sʲtʲrʲ/ appears to be an error; D&P pp. 85-87 confirms
      // that р blocks regressive palatalization. <em>Ilya</em> follows D&P: сестрёнка → /strʲ/
      regressivePalatalizationBlockers: new Set(['р', 'л']), // р and л block regressive palatalization (except doubled)
      
      // Categorical restrictions for regressive palatalization (Grayson p. 209)
      // Velars only palatalize before palatalized velars
      velars: new Set(['к', 'г', 'х']),
      // Labials only palatalize before palatalized labials
      labials: new Set(['б', 'п', 'в', 'ф', 'м']),
      // Dentals palatalize more freely
      dentals: new Set(['т', 'д', 'с', 'з', 'н', 'ц']),
      // н only palatalizes before palatalized н or dental
      
      // Special consonant clusters (Grayson p. 225-247)
      // These are detected and transcribed as units before letter-by-letter processing
      specialClusters: {
        'сч': 'ʃʲʃʲ',   // Same as щ (p. 230-231)
        'зч': 'ʃʲʃʲ',   // Same as щ (p. 230-231)
        // Sibilant mergers (Grayson pp. 235-236)
        'сш': 'ʃː',     // с + ш → long unvoiced postalveolar (p. 235)
        'зш': 'ʃː',     // з + ш → long unvoiced postalveolar (devoices, p. 235)
        'сж': 'ʒː',     // с + ж → long voiced postalveolar (voices, p. 236)
        'зж': 'ʒː',     // з + ж → long voiced postalveolar (p. 236)
      },
      
      // Reflexive verb suffix clusters (Grayson p. 237-238)
      // "The clusters -тс-/-дс- and -тьс-/-дьс- resemble /ts/ but have an elongated stop"
      // These are ONLY checked at word end (suffix position)
      reflexiveSuffixes: {
        'ться': 'tːsʌ',  // купаться → /kuˈpɑtːsʌ/
        'тся': 'tːsʌ',   // боится → /bɑˈitːsʌ/
      },
      
      // Word-specific cluster overrides (p. 239-240)
      wordSpecificClusters: {
        'конечно': { 'чн': 'ʃn' },
        'скучно': { 'чн': 'ʃn' },
        'скучный': { 'чн': 'ʃn' },
        'нарочно': { 'чн': 'ʃn' },
        'яичница': { 'чн': 'ʃn' },
        'что': { 'чт': 'ʃt' },
        'чтоб': { 'чт': 'ʃt' },
        'чтобы': { 'чт': 'ʃt' },
        'ничто': { 'чт': 'ʃt' },
        // русский exception (Grayson p. 233): single /s/, not geminate
        // Also overrides Old Muscovite -кий rule — uses modern soft кʲ
        'русский': { 'сс': 's' },
        'русская': { 'сс': 's' },
        'русское': { 'сс': 's' },
        'русские': { 'сс': 's' },
        'русского': { 'сс': 's' },
        'русскому': { 'сс': 's' },
        'русским': { 'сс': 's' },
        'русскими': { 'сс': 's' },
        'русской': { 'сс': 's' },
        'русских': { 'сс': 's' },
        'русскую': { 'сс': 's' },
        'русском': { 'сс': 's' },
        // Silent consonant exceptions (Grayson p. 235-236)
        // сердце family: рдц → рц (д silent)
        'сердце': { 'рдц': 'rts' },
        'сердца': { 'рдц': 'rts' },
        'сердцу': { 'рдц': 'rts' },
        'сердцем': { 'рдц': 'rts' },
        // солнце family: лнц → нц (л silent)
        'солнце': { 'лнц': 'nts' },
        'солнца': { 'лнц': 'nts' },
        'солнцу': { 'лнц': 'nts' },
        'солнцем': { 'лнц': 'nts' },
        // здравствуй family: вств → ств (first в silent)
        'здравствуй': { 'вств': 'stv' },
        'здравствуйте': { 'вств': 'stv' },
        'здравствуют': { 'вств': 'stv' },
        // чувство family: вств → ств (first в silent)
        'чувство': { 'вств': 'stv' },
        'чувства': { 'вств': 'stv' },
        'чувствам': { 'вств': 'stv' },
        'чувствами': { 'вств': 'stv' },
        'чувствах': { 'вств': 'stv' },
        'чувствую': { 'вств': 'stv' },
        'чувствует': { 'вств': 'stv' },
        'чувствовать': { 'вств': 'stv' },
        // бесчувственный family: вств → ств (first в silent)
        'бесчувственный': { 'вств': 'stv' },
        'бесчувственная': { 'вств': 'stv' },
        'бесчувственное': { 'вств': 'stv' },
        'бесчувственные': { 'вств': 'stv' },
        'бесчувственного': { 'вств': 'stv' },
        'бесчувственной': { 'вств': 'stv' },
        'бесчувственному': { 'вств': 'stv' },
        'бесчувственным': { 'вств': 'stv' },
        'бесчувственными': { 'вств': 'stv' },
        'бесчувственных': { 'вств': 'stv' },
        'бесчувственную': { 'вств': 'stv' },
        'бесчувственном': { 'вств': 'stv' },
        // Silent т in стн cluster (Grayson p. 235)
        // честный family (honest)
        'честный': { 'стн': 'sn' },
        'честная': { 'стн': 'sn' },
        'честное': { 'стн': 'sn' },
        'честные': { 'стн': 'sn' },
        'честного': { 'стн': 'sn' },
        'честной': { 'стн': 'sn' },
        'честному': { 'стн': 'sn' },
        'честным': { 'стн': 'sn' },
        'честными': { 'стн': 'sn' },
        'честных': { 'стн': 'sn' },
        'честную': { 'стн': 'sn' },
        'честном': { 'стн': 'sn' },
        'честно': { 'стн': 'sn' },
        // известный family (famous)
        'известный': { 'стн': 'sn' },
        'известная': { 'стн': 'sn' },
        'известное': { 'стн': 'sn' },
        'известные': { 'стн': 'sn' },
        'известного': { 'стн': 'sn' },
        'известной': { 'стн': 'sn' },
        'известному': { 'стн': 'sn' },
        'известным': { 'стн': 'sn' },
        'известными': { 'стн': 'sn' },
        'известных': { 'стн': 'sn' },
        'известную': { 'стн': 'sn' },
        'известном': { 'стн': 'sn' },
        'известно': { 'стн': 'sn' },
        // грустный family (sad)
        'грустный': { 'стн': 'sn' },
        'грустная': { 'стн': 'sn' },
        'грустное': { 'стн': 'sn' },
        'грустные': { 'стн': 'sn' },
        'грустного': { 'стн': 'sn' },
        'грустной': { 'стн': 'sn' },
        'грустному': { 'стн': 'sn' },
        'грустным': { 'стн': 'sn' },
        'грустными': { 'стн': 'sn' },
        'грустных': { 'стн': 'sn' },
        'грустную': { 'стн': 'sn' },
        'грустном': { 'стн': 'sn' },
        'грустно': { 'стн': 'sn' },
        // местный family (local)
        'местный': { 'стн': 'sn' },
        'местная': { 'стн': 'sn' },
        'местное': { 'стн': 'sn' },
        'местные': { 'стн': 'sn' },
        'местного': { 'стн': 'sn' },
        'местной': { 'стн': 'sn' },
        'местному': { 'стн': 'sn' },
        'местным': { 'стн': 'sn' },
        'местными': { 'стн': 'sn' },
        'местных': { 'стн': 'sn' },
        'местную': { 'стн': 'sn' },
        'местном': { 'стн': 'sn' },
        // частный family (private)
        'частный': { 'стн': 'sn' },
        'частная': { 'стн': 'sn' },
        'частное': { 'стн': 'sn' },
        'частные': { 'стн': 'sn' },
        'частного': { 'стн': 'sn' },
        'частной': { 'стн': 'sn' },
        'частному': { 'стн': 'sn' },
        'частным': { 'стн': 'sn' },
        'частными': { 'стн': 'sn' },
        'частных': { 'стн': 'sn' },
        'частную': { 'стн': 'sn' },
        'частном': { 'стн': 'sn' },
        'частно': { 'стн': 'sn' },
        // прелестный family (lovely)
        'прелестный': { 'стн': 'sn' },
        'прелестная': { 'стн': 'sn' },
        'прелестное': { 'стн': 'sn' },
        'прелестные': { 'стн': 'sn' },
        'прелестного': { 'стн': 'sn' },
        'прелестной': { 'стн': 'sn' },
        'прелестному': { 'стн': 'sn' },
        'прелестным': { 'стн': 'sn' },
        'прелестными': { 'стн': 'sn' },
        'прелестных': { 'стн': 'sn' },
        'прелестную': { 'стн': 'sn' },
        'прелестном': { 'стн': 'sn' },
        // Silent д in здн cluster (Grayson p. 235)
        // поздно family (late)
        'поздно': { 'здн': 'zn' },
        'поздний': { 'здн': 'zn' },
        'поздняя': { 'здн': 'zn' },
        'позднее': { 'здн': 'zn' },
        'поздние': { 'здн': 'zn' },
        'позднего': { 'здн': 'zn' },
        'поздней': { 'здн': 'zn' },
        'позднему': { 'здн': 'zn' },
        'поздним': { 'здн': 'zn' },
        'поздними': { 'здн': 'zn' },
        'поздних': { 'здн': 'zn' },
        'позднюю': { 'здн': 'zn' },
        'позднем': { 'здн': 'zn' },
        // праздник family (holiday)
        'праздник': { 'здн': 'zn' },
        'праздника': { 'здн': 'zn' },
        'праздникам': { 'здн': 'zn' },
        'праздниками': { 'здн': 'zn' },
        'праздниках': { 'здн': 'zn' },
        'праздники': { 'здн': 'zn' },
        'праздников': { 'здн': 'zn' },
        'праздником': { 'здн': 'zn' },
        'праздникам': { 'здн': 'zn' },
        'праздниках': { 'здн': 'zn' },
        'праздничный': { 'здн': 'zn' },
        'праздничная': { 'здн': 'zn' },
        'праздничное': { 'здн': 'zn' },
        'праздничные': { 'здн': 'zn' },
        'праздничного': { 'здн': 'zn' },
        'праздничной': { 'здн': 'zn' },
        'праздничному': { 'здн': 'zn' },
        'праздничным': { 'здн': 'zn' },
        'праздничными': { 'здн': 'zn' },
        'праздничных': { 'здн': 'zn' },
        'праздничную': { 'здн': 'zn' },
        'праздничном': { 'здн': 'zn' },
        // звёздный family (starry) - also has здн
        'звёздный': { 'здн': 'zn' },
        'звёздная': { 'здн': 'zn' },
        'звёздное': { 'здн': 'zn' },
        'звёздные': { 'здн': 'zn' },
        'звёздного': { 'здн': 'zn' },
        'звёздной': { 'здн': 'zn' },
        'звёздному': { 'здн': 'zn' },
        'звёздным': { 'здн': 'zn' },
        'звёздными': { 'здн': 'zn' },
        'звёздных': { 'здн': 'zn' },
        'звёздную': { 'здн': 'zn' },
        'звёздном': { 'здн': 'zn' },
      },
      
      // Exception words where normal phonological rules don't apply (Grayson Appendix F)
      exceptionWords: {
        'счастье': { vowelOverrides: { 2: 'ɑ' } },
        'счастья': { vowelOverrides: { 2: 'ɑ' } },
        'счастлив': { vowelOverrides: { 2: 'ɑ' } },
        'счастливый': { vowelOverrides: { 2: 'ɑ' } },
        // русский exception (Grayson p. 233): uses modern -кий (soft), not Old Muscovite
        'русский': { skipVelarAdjectival: true },
        'русская': { skipVelarAdjectival: true },
        'русское': { skipVelarAdjectival: true },
        'русские': { skipVelarAdjectival: true },
        'русского': { skipVelarAdjectival: true },
        'русскому': { skipVelarAdjectival: true },
        'русским': { skipVelarAdjectival: true },
        'русскими': { skipVelarAdjectival: true },
        'русской': { skipVelarAdjectival: true },
        'русских': { skipVelarAdjectival: true },
        'русскую': { skipVelarAdjectival: true },
        'русском': { skipVelarAdjectival: true },
      },
      
      // Find special clusters in a word
      findSpecialClusters(word) {
        const cleanWord = word.toLowerCase();
        const clusters = [];
        
        // Check word-specific clusters first (higher priority)
        const wordOverrides = this.wordSpecificClusters[cleanWord];
        if (wordOverrides) {
          for (const [cluster, ipa] of Object.entries(wordOverrides)) {
            let idx = cleanWord.indexOf(cluster);
            while (idx !== -1) {
              clusters.push({ 
                startIndex: idx, 
                endIndex: idx + cluster.length - 1,
                cluster: cluster, 
                ipa: ipa 
              });
              idx = cleanWord.indexOf(cluster, idx + 1);
            }
          }
        }
        
        // Check reflexive suffixes (only at word end)
        for (const [suffix, ipa] of Object.entries(this.reflexiveSuffixes)) {
          if (cleanWord.endsWith(suffix)) {
            const startIdx = cleanWord.length - suffix.length;
            clusters.push({
              startIndex: startIdx,
              endIndex: cleanWord.length - 1,
              cluster: suffix,
              ipa: ipa
            });
            break; // Only one reflexive suffix per word
          }
        }
        
        // Check universal clusters
        for (const [cluster, ipa] of Object.entries(this.specialClusters)) {
          let idx = cleanWord.indexOf(cluster);
          while (idx !== -1) {
            // Skip if already covered
            const alreadyCovered = clusters.some(c => 
              (idx >= c.startIndex && idx <= c.endIndex) ||
              (idx + cluster.length - 1 >= c.startIndex && idx + cluster.length - 1 <= c.endIndex)
            );
            if (!alreadyCovered) {
              clusters.push({ 
                startIndex: idx, 
                endIndex: idx + cluster.length - 1,
                cluster: cluster, 
                ipa: ipa 
              });
            }
            idx = cleanWord.indexOf(cluster, idx + 1);
          }
        }
        
        return clusters.sort((a, b) => a.startIndex - b.startIndex);
      },
      
      // Check for vowel override in exception words
      getVowelOverride(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const exception = this.exceptionWords[cleanWord];
        if (exception?.vowelOverrides?.[charIndex] !== undefined) {
          return exception.vowelOverrides[charIndex];
        }
        return null;
      },
      
      // Check for -ая/-яя suffix exception (Grayson p. 124)
      // Feminine adjective endings are ALWAYS sung as /ɑjɑ/, never reduced
      isAyaSuffixVowel(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Check if word ends in -ая or -яя
        if (len >= 2) {
          const ending = cleanWord.slice(-2);
          if (ending === 'ая' || ending === 'яя') {
            // Check if this charIndex is one of the two final vowels
            if (charIndex === len - 2 || charIndex === len - 1) {
              return true;
            }
          }
        }
        return false;
      },
      
      // Check for Old Muscovite adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
      // When profile is 'stage': velars stay hard, и → [ɨ], й → [j]
      // Returns: { isVelarAdjectival: bool, charRole: 'velar'|'i'|'j'|null }
      checkVelarAdjectival(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Check if this word is an exception (e.g., русский uses modern -кий)
        const exception = this.exceptionWords[cleanWord];
        if (exception?.skipVelarAdjectival) {
          return { isVelarAdjectival: false, charRole: null };
        }
        
        // Check if word ends in -кий, -гий, or -хий
        if (len >= 3) {
          const ending = cleanWord.slice(-3);
          const velars = ['кий', 'гий', 'хий'];
          
          if (velars.includes(ending)) {
            const suffixStart = len - 3;
            
            // Check which part of the suffix this charIndex is
            if (charIndex === suffixStart) {
              return { isVelarAdjectival: true, charRole: 'velar' };
            } else if (charIndex === suffixStart + 1) {
              return { isVelarAdjectival: true, charRole: 'i' };
            } else if (charIndex === suffixStart + 2) {
              return { isVelarAdjectival: true, charRole: 'j' };
            }
          }
        }
        return { isVelarAdjectival: false, charRole: null };
      },
      
      // Check for genitive ending -ого/-его where г → /v/ (Grayson p. 243)
      // Exception: много, строго, etc. where -ого is NOT a genitive ending
      checkGenitiveEnding(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Exceptions: words where -ого/-его is NOT a genitive ending
        const exceptions = new Set([
          'много', 'немного', 'строго', 'нестрого', 'убого', 
          'отлого', 'полого', 'дорого', 'недорого', 'другого' // 'другого' IS genitive, but listed in some sources
        ]);
        
        // Remove другого from exceptions - it IS a genitive form
        exceptions.delete('другого');
        
        if (exceptions.has(cleanWord)) {
          return false;
        }
        
        // Check if word ends in -ого or -его
        if (len >= 3) {
          const ending3 = cleanWord.slice(-3);
          if (ending3 === 'ого' || ending3 === 'его') {
            // The г is at position len - 2 (second to last character)
            const gPosition = len - 2;
            return charIndex === gPosition;
          }
        }
        
        return false;
      },
      
      // Look up stress from dictionary
      // Handles both old format and new kaikki format (including homographs)
      lookupStress(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // Helper to normalize entry format
        const normalizeEntry = (entry, source = 'dictionary') => {
          if (!entry) return null;
          
          // Handle homographs (arrays) - return first match for now, mark as homograph
          if (Array.isArray(entry)) {
            const firstEntry = entry[0];
            const rawGloss = firstEntry.gloss ?? firstEntry.g;
            return {
              stress: firstEntry.stress ?? firstEntry.s,
              gloss: rawGloss,
              pos: firstEntry.pos ?? firstEntry.p ?? '',
              lemma: firstEntry.lemma ?? firstEntry.l ?? '',
              source: source,
              isHomograph: true,
              allEntries: entry,
              canonicalForm: cleanWord
            };
          }
          
          // Single entry
          const rawGloss = entry.gloss ?? entry.g;
          return {
            stress: entry.stress ?? entry.s,
            gloss: rawGloss,
            pos: entry.pos ?? entry.p ?? '',
            lemma: entry.lemma ?? entry.l ?? '',
            source: entry.source || source,
            isHomograph: false,
            canonicalForm: cleanWord
          };
        };
        
        // Phase 1: Check SINGER_SUPPLEMENT first (authoritative overrides)
        // This catches critical corrections like и→"and" (not "the tenth letter")
        const supplementEntry = SINGER_SUPPLEMENT[cleanWord];
        if (supplementEntry) {
          return normalizeEntry(supplementEntry, 'supplement');
        }
        
        // Phase 1b: Try dictionary lookup
        const exactEntry = STRESS_DICTIONARY[cleanWord];
        if (exactEntry) {
          return normalizeEntry(exactEntry, 'dictionary');
        }
        
        // Phase 2: Word not found — try ё-restoration
        // Russian publishers often omit the dieresis, printing ⟨е⟩ where ⟨ё⟩ should appear
        const chars = [...cleanWord];
        for (let i = 0; i < chars.length; i++) {
          if (chars[i] === 'е') {
            // Try substituting this е with ё
            const candidate = [...chars];
            candidate[i] = 'ё';
            const candidateWord = candidate.join('');
            
            const restoredEntry = STRESS_DICTIONARY[candidateWord] || SINGER_SUPPLEMENT[candidateWord];
            if (restoredEntry) {
              const result = normalizeEntry(restoredEntry, 'yo-restored');
              if (result) {
                result.canonicalForm = candidateWord;
                result.originalInput = cleanWord;
              }
              return result;
            }
          }
        }
        
        // Phase 2b: Try ё→е normalization
        // Some dictionaries store the е-form even when ё is correct
        // If user types ёлка but dictionary has елка, try that
        if (cleanWord.includes('ё')) {
          const normalizedWord = cleanWord.replace(/ё/g, 'е');
          const normalizedEntry = STRESS_DICTIONARY[normalizedWord] || SINGER_SUPPLEMENT[normalizedWord];
          if (normalizedEntry) {
            const result = normalizeEntry(normalizedEntry, 'yo-normalized');
            if (result) {
              result.canonicalForm = cleanWord; // Keep the ё form as canonical
              result.originalInput = cleanWord;
            }
            return result;
          }
        }
        
        // Phase 3: No match found
        return null;
      },
      
      // Apply the case pattern from original word to canonical form
      // Preserves uppercase/lowercase pattern when restoring ё
      applyCasePattern(original, canonical) {
        // Strip punctuation from original to get just letters
        const origLetters = original.replace(/[.,!?;:"""''–—]/g, '');
        const canonLetters = canonical;
        
        // If lengths don't match, just return canonical (shouldn't happen with е→ё)
        if (origLetters.length !== canonLetters.length) {
          return canonical;
        }
        
        // Apply case from original to canonical, character by character
        const result = [];
        for (let i = 0; i < canonLetters.length; i++) {
          const origChar = origLetters[i];
          const canonChar = canonLetters[i];
          
          // Check if original was uppercase
          if (origChar === origChar.toUpperCase() && origChar !== origChar.toLowerCase()) {
            // Original was uppercase — apply to canonical
            result.push(canonChar.toUpperCase());
          } else {
            result.push(canonChar.toLowerCase());
          }
        }
        
        // Re-append any trailing punctuation from original
        const trailingPunct = original.match(/[.,!?;:"""''–—]+$/);
        return result.join('') + (trailingPunct ? trailingPunct[0] : '');
      },
      
      isVowel(char) {
        return this.vowels.has(char?.toLowerCase());
      },
      
      isConsonant(char) {
        return this.consonants.has(char?.toLowerCase());
      },
      
      isPalatalized(char, nextChar) {
        char = char?.toLowerCase();
        nextChar = nextChar?.toLowerCase();
        
        if (this.alwaysSoft.has(char)) return true;
        if (this.alwaysHard.has(char)) return false;
        if (nextChar === 'ь') return true;
        if (['е', 'ё', 'и', 'ю', 'я'].includes(nextChar)) return true;
        
        return false;
      },
      
      // COMPLETE PALATALIZATION MAP (Grayson p. 207-209; D&P pp. 76-87)
      // Computes ALL palatalization sources upfront, before any transcription.
      // This ensures vowel interpalatal detection knows about progressive palatalization.
      // Architecture per Kimi's spec: single source of truth for vowels AND consonants.
      //
      // Pass 1: Direct palatalization (consonants before front vowels/ь)
      // Pass 2: Regressive chain through consonant clusters
      // Pass 3: Progressive palatalization of р (Grayson p. 209, footnote 277)
      //
      // Returns a Map of character indices that should be palatalized.
      computeCompletePalatalizationMap(word, syllables, stressIndex) {
        const chars = [...word.toLowerCase()];
        const softIndices = new Map(); // index -> true if should be palatalized
        
        // Compute syllable boundaries: which char indices are in each syllable
        const syllableBoundaries = []; // Array of { start, end, isStressed }
        let charPos = 0;
        syllables.forEach((syl, sylIdx) => {
          const start = charPos;
          const end = charPos + syl.length - 1;
          syllableBoundaries.push({
            start,
            end,
            isStressed: sylIdx === stressIndex
          });
          charPos += syl.length;
        });
        
        // Helper: check if character index is in the stressed syllable
        const isInStressedSyllable = (index) => {
          const boundary = syllableBoundaries.find(b => index >= b.start && index <= b.end);
          return boundary ? boundary.isStressed : false;
        };
        
        // PASS 1: Mark directly palatalized consonants (before indicator letters or ь)
        for (let i = 0; i < chars.length; i++) {
          if (this.isConsonant(chars[i])) {
            if (this.isPalatalized(chars[i], chars[i + 1])) {
              softIndices.set(i, true);
            }
          }
        }
        
        // PASS 2: Process regressive palatalization right-to-left through clusters
        // Working backwards, check if palatalization can step through
        for (let i = chars.length - 2; i >= 0; i--) {
          const char = chars[i];
          const nextChar = chars[i + 1];
          
          if (!this.isConsonant(char)) continue;
          if (softIndices.has(i)) continue; // Already soft
          
          // Check if next consonant is soft
          const nextIsSoft = softIndices.has(i + 1);
          if (!nextIsSoft) continue;
          
          // Check for blockers (Grayson p. 209; D&P pp. 85-87)
          // р and л block regressive palatalization (confirmed by D&P)
          if (this.regressivePalatalizationBlockers.has(nextChar)) {
            continue; // Blocked - don't palatalize through р or л
          }
          
          // Check categorical restrictions (Grayson p. 209)
          if (!this.canRegressivelyPalatalize(char, nextChar)) {
            continue; // Categorical mismatch
          }
          
          // Check for boundaries
          if (this.alwaysHard.has(char)) continue; // ж, ш, ц never palatalize
          if (chars[i + 1] === 'ъ') continue; // Hard sign blocks (except в, с, з - handled separately)
          
          // This consonant can be regressively palatalized
          softIndices.set(i, true);
        }
        
        // PASS 3: Progressive palatalization of р (Grayson p. 209, footnote 277)
        // "Do not regressively palatalize /r/ within a cluster except...
        // directly following -и-, -е-, or -э- (in the stressed syllable only)"
        // Examples: смерть /sʲmʲerʲtʲ/, терпеть /tʲirʲˈpʲetʲ/, кирпич /kʲirʲˈpʲitʃʲ/
        // NOTE: Applies only when р is in a CLUSTER (followed by consonant).
        // Word-final р after front vowel does NOT palatalize: мир /mʲir/ not /mʲirʲ/
        const progressiveFrontVowels = new Set(['и', 'е', 'э']);
        
        for (let i = 0; i < chars.length; i++) {
          if (chars[i] !== 'р') continue;
          if (softIndices.has(i)) continue; // Already soft from Pass 1 or 2
          if (!isInStressedSyllable(i)) continue; // Must be in stressed syllable
          
          const prevChar = chars[i - 1];
          if (!prevChar || !progressiveFrontVowels.has(prevChar)) continue; // Must follow front vowel
          
          // Find what follows р (skip ь/ъ)
          let charAfterR = null;
          for (let j = i + 1; j < chars.length; j++) {
            if (chars[j] === 'ь' || chars[j] === 'ъ') continue;
            charAfterR = chars[j];
            break;
          }
          
          // Cluster requirement: р must be followed by a consonant
          if (charAfterR && this.isConsonant(charAfterR)) {
            softIndices.set(i, true); // Progressive palatalization
          }
        }
        
        return softIndices;
      },
      
      // Legacy wrapper for any code still calling the old function name
      analyzeRegressivePalatalization(word) {
        // Fallback: treat as single stressed syllable (conservative)
        return this.computeCompletePalatalizationMap(word, [word], 0);
      },
      
      // Check if consonant can regressively palatalize before another consonant (Grayson p. 209)
      canRegressivelyPalatalize(consonant, triggerConsonant) {
        consonant = consonant?.toLowerCase();
        triggerConsonant = triggerConsonant?.toLowerCase();
        
        // Always-hard consonants never palatalize
        if (this.alwaysHard.has(consonant)) return false;
        
        // л: only regressively palatalizes when doubled (лль)
        // (Grayson p. 209 rule 1)
        if (consonant === 'л') {
          return triggerConsonant === 'л'; // Only before another л
        }
        
        // р: never regressively palatalizes except when doubled (ррь)
        // (Grayson p. 209 rule 2; D&P pp. 85-87)
        // NOTE: Progressive palatalization (after front vowel in cluster) is handled separately
        if (consonant === 'р') {
          return triggerConsonant === 'р'; // Only before another р
        }
        
        // н: only before palatalized н or dental (Grayson p. 209 rule 3)
        if (consonant === 'н') {
          return triggerConsonant === 'н' || this.dentals.has(triggerConsonant);
        }
        
        // Velars (к, г, х): only before palatalized velar (Grayson p. 209 rule 4)
        if (this.velars.has(consonant)) {
          return this.velars.has(triggerConsonant);
        }
        
        // Labials (б, п, в, ф, м): only before palatalized labial (Grayson p. 209 rule 5)
        if (this.labials.has(consonant)) {
          return this.labials.has(triggerConsonant);
        }
        
        // Dentals (т, д, с, з): only before palatalized dental (Grayson p. 209)
        // Dentals do NOT palatalize before labials (e.g., д before в in дверь stays hard)
        if (this.dentals.has(consonant)) {
          return this.dentals.has(triggerConsonant);
        }
        
        // Others: can palatalize more freely
        return true;
      },
      
      // Check if a consonant at given index is palatalized (considering regressive)
      isConsonantPalatalized(word, index, softIndices) {
        if (softIndices && softIndices.has(index)) {
          return true;
        }
        const chars = [...word.toLowerCase()];
        return this.isPalatalized(chars[index], chars[index + 1]);
      },
      
      // Protected suffixes that must stay together as syllable units (Grayson p. 237-238)
      // Format: { cyrillic: 'suffix', placeholder: '◊' }
      // The placeholder replaces consonants, keeping the vowel visible for syllable counting
      protectedSuffixes: [
        { suffix: 'ться', consonants: 'ться', placeholder: '◊', vowelKept: 'я' }, // купаться
        { suffix: 'тся', consonants: 'тс', placeholder: '◊', vowelKept: 'я' },   // боится
      ],
      
      // Main syllabification entry point
      // Wraps the open-syllable logic with morphological exception handling
      syllabify(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // STEP 1: Check for protected suffixes and replace with placeholders
        let processedWord = cleanWord;
        let activeProtection = null;
        
        for (const protection of this.protectedSuffixes) {
          if (cleanWord.endsWith(protection.suffix)) {
            // Replace the consonant portion with placeholder, keep vowel
            // e.g., "боится" → "бои◊я" (тс replaced with ◊, я kept)
            const suffixStart = cleanWord.length - protection.suffix.length;
            const beforeSuffix = cleanWord.slice(0, suffixStart);
            processedWord = beforeSuffix + protection.placeholder + protection.vowelKept;
            activeProtection = { ...protection, startIndex: suffixStart };
            break; // Only one suffix per word
          }
        }
        
        // STEP 2: Apply open-syllable rules to processed word
        const rawSyllables = this.syllabifyOpenSyllable(processedWord);
        
        // STEP 3: Restore protected suffix in final syllable
        if (activeProtection) {
          const lastIdx = rawSyllables.length - 1;
          // Replace placeholder+vowel back to original suffix
          rawSyllables[lastIdx] = rawSyllables[lastIdx].replace(
            activeProtection.placeholder + activeProtection.vowelKept,
            activeProtection.suffix
          );
        }
        
        return rawSyllables;
      },
      
      // Core open-syllable logic (Maximum Onset Principle)
      // This is the original syllabify, now renamed and called by the wrapper
      syllabifyOpenSyllable(word) {
        const chars = [...word];
        const syllables = [];
        let current = '';
        
        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];
          current += char;
          
          if (this.isVowel(char)) {
            let j = i + 1;
            // Advance through consonants AND soft/hard signs (they attach to consonants)
            while (j < chars.length && !this.isVowel(chars[j])) {
              j++;
            }
            
            // If we've reached the end of the word, attach all remaining chars to this syllable
            if (j >= chars.length) {
              current += chars.slice(i + 1).join('');
              syllables.push(current);
              break;
            }
            
            // We have consonants between this vowel and the next
            const cluster = chars.slice(i + 1, j);
            if (cluster.length === 0) {
              // No consonants between vowels (e.g., two vowels in a row)
              syllables.push(current);
              current = '';
            } else if (cluster.length === 1) {
              // Single consonant goes with next syllable (CV.CV pattern)
              syllables.push(current);
              current = '';
            } else {
              // Multiple consonants: keep last one for next syllable, rest stay with current
              // But soft/hard signs always stay with preceding consonant
              let splitPoint = cluster.length - 1;
              // If the last char is a soft/hard sign, move split point back
              while (splitPoint > 0 && (cluster[splitPoint] === 'ь' || cluster[splitPoint] === 'ъ')) {
                splitPoint--;
              }
              // Keep at least one consonant for the next syllable (unless it's all signs)
              if (splitPoint === cluster.length - 1) {
                splitPoint = Math.max(1, cluster.length - 1);
              }
              current += cluster.slice(0, splitPoint).join('');
              syllables.push(current);
              current = '';
              i = i + splitPoint;
            }
          }
        }
        
        if (current && !syllables.includes(current)) {
          syllables.push(current);
        }
        
        return syllables.length > 0 ? syllables : [word];
      },
      
      countVowels(word) {
        return [...word.toLowerCase()].filter(c => this.isVowel(c)).length;
      },
      
      // Detect if word contains ё and return its syllable index
      // ё always carries stress in Russian — this is non-negotiable
      findYoSyllable(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const syllables = this.syllabify(cleanWord);
        for (let i = 0; i < syllables.length; i++) {
          if (syllables[i].includes('ё')) {
            return i;
          }
        }
        return -1; // No ё found
      },
      
      // Check if word contains ё (for UI decisions)
      hasYo(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        return cleanWord.includes('ё');
      },
      
      getSyllablePosition(index, stressIndex, total) {
        if (index === stressIndex) return 'stressed';
        if (stressIndex === -1) return 'unstressed';
        if (index === stressIndex - 1) return 'pretonic';
        // Grayson p. 266, fn. 306: immediate post-tonic а stays /ɑ/ to distinguish from о
        if (index === stressIndex + 1) return 'posttonic-immediate';
        return 'remote';
      },
      
      // Transcribe vowel based on position and palatal context
      // Grayson Ch. 3: Fronting to [a] or [e] requires INTERPALATAL position
      // (sandwiched between two palatalized consonants or followed by й)
      transcribeVowel(vowel, position, isPrecededByPalatalized, isFollowedByPalatalized, precedingConsonant) {
        vowel = vowel.toLowerCase();
        
        // Interpalatal = preceded by soft C AND followed by soft C (Grayson p. 207)
        // Note: For word-initial position, the /j/ glide counts as "preceded by soft"
        const isInterpalatal = isPrecededByPalatalized && isFollowedByPalatalized;
        
        // Always-hard consonants ж, ш, ц (Grayson p. 102-103)
        const isAfterAlwaysHard = ['ж', 'ш', 'ц'].includes(precedingConsonant);
        
        if (position === 'stressed') {
          // а → [a] only when interpalatal (Grayson p. 104)
          if (vowel === 'а') return isInterpalatal ? 'a' : 'ɑ';
          if (vowel === 'о') return 'o';
          
          // RULE B: -е- requires INTERPALATAL for [e] (Grayson p. 207)
          // "е and its cluster /jɛ/ shift to [e]/[je] when interpalatal 
          // (between two palatalized consonants or palatalizing agents)"
          if (vowel === 'е') return isInterpalatal ? 'e' : 'ɛ';
          
          if (vowel === 'ё') return 'o';
          // и after ж/ш/ц → ɨ (Grayson p. 93-95)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у') return 'u';
          if (vowel === 'ю') return 'u';
          // я → [a] only when interpalatal (Grayson p. 104)
          if (vowel === 'я') return isInterpalatal ? 'a' : 'ɑ';
          
          // RULE A: -э- only checks FOLLOWING consonant for [e] (Grayson p. 207)
          // "-э- shifts from /ɛ/ to [e] when followed by a palatalized consonant"
          // (Note: -э- cannot follow soft consonants orthographically)
          if (vowel === 'э') return isFollowedByPalatalized ? 'e' : 'ɛ';
        } else if (position === 'pretonic') {
          if (vowel === 'а' || vowel === 'о') return 'ɑ';
          // е after ж/ш/ц → ɨ (Grayson p. 102-103)
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'я' || vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          // и after ж/ш/ц → ɨ (Grayson p. 102)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        } else if (position === 'posttonic-immediate') {
          // Grayson p. 266, footnote 306: "This guide suggests that -а- in 
          // the immediate-post-stress position be read as /ɑ/ in order to 
          // aurally differentiate from words that have the letter -о- in 
          // the same position."
          // Example: блюдa /ˈblʲu dɑ/ (platters) vs блюдо /ˈblʲu dʌ/ (a platter)
          if (vowel === 'а') return 'ɑ';
          if (vowel === 'я') return 'ɑ';  // я follows а pattern (underlying /ja/)
          if (vowel === 'о') return 'ʌ';
          // Other vowels follow remote patterns
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        } else {
          // Remote unstressed positions (Grayson p. 109-112)
          if (vowel === 'а') return 'ʌ';
          if (vowel === 'о') return 'ʌ';
          // е after ж/ш/ц → ɨ (Grayson p. 102-103)
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'я' || vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          // и after ж/ш/ц → ɨ (Grayson p. 102)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        }
        
        return vowel;
      },
      
      transcribeConsonant(consonant, nextChar, prevChar, isStressedSyllable, isSoftFromRegressive = false, nextCharInWord = null) {
        consonant = consonant.toLowerCase();
        prevChar = prevChar?.toLowerCase();
        // Combine direct palatalization with regressive palatalization analysis
        const softDirect = this.isPalatalized(consonant, nextChar);
        const soft = softDirect || isSoftFromRegressive;
        const base = this.inventory.consonants[consonant] || consonant;
        
        // Progressive palatalization of р (Grayson p. 209, footnote 277)
        // "Do not regressively palatalize /r/ within a cluster except... 
        // directly following -и-, -е-, or -э- (in the stressed syllable only)"
        // Examples: смерть /sʲmʲerʲtʲ/, терпеть /tʲirʲˈpʲetʲ/, кирпич /kʲirʲˈpʲitʃʲ/
        // NOTE: This applies only when р is IN A CLUSTER (followed by consonant)
        // Word-final р after front vowel does NOT palatalize: мир /mʲir/ not /mʲirʲ/
        // v5.11.21: Use nextCharInWord to check across syllable boundaries
        if (consonant === 'р' && isStressedSyllable) {
          const frontVowels = ['и', 'е', 'э'];
          // Check both syllable-local nextChar AND word-level nextCharInWord
          const effectiveNextChar = nextChar || nextCharInWord;
          const nextIsConsonant = effectiveNextChar && this.consonants.has(effectiveNextChar.toLowerCase());
          if (frontVowels.includes(prevChar) && nextIsConsonant) {
            return 'rʲ'; // Progressive palatalization in cluster only
          }
        }
        
        if (consonant === 'л') {
          return soft ? 'lʲ' : 'ɫ';
        }
        if (consonant === 'н' && soft) {
          return 'ɲ';
        }
        
        if (soft && !this.alwaysSoft.has(consonant)) {
          return base + 'ʲ';
        }
        
        return base;
      },
      
      // Final consonant devoicing (Grayson Ch. 4 Sec. 4, pp. 199-202)
      // "In Russian, as in German, final consonants are generally unvoiced, 
      // regardless of spelling. This does not apply to sonorants."
      voicedToVoiceless: Object.freeze({
        'b': 'p',    // б → п (p. 199-200)
        'bʲ': 'pʲ',  // бь → пь
        'v': 'f',    // в → ф (p. 200)
        'vʲ': 'fʲ',  // вь → фь
        'd': 't',    // д → т (p. 201)
        'dʲ': 'tʲ',  // дь → ть
        'ɡ': 'k',    // г → к (p. 201) — note: гь does not occur
        'z': 's',    // з → с (p. 202)
        'zʲ': 'sʲ',  // зь → сь
        'ʒ': 'ʃ'     // ж → ш (p. 202) — ж never palatalizes, so жь also → ш
      }),
      
      // Reverse mapping for voicing (voiceless → voiced)
      voicelessToVoiced: Object.freeze({
        'p': 'b',    // п → б
        'pʲ': 'bʲ',  // пь → бь
        'f': 'v',    // ф → в
        'fʲ': 'vʲ',  // фь → вь
        't': 'd',    // т → д
        'tʲ': 'dʲ',  // ть → дь
        'k': 'ɡ',    // к → г
        's': 'z',    // с → з
        'sʲ': 'zʲ',  // сь → зь
        'ʃ': 'ʒ'     // ш → ж
      }),
      
      // Sets for classification (Grayson Ch. 6 Sec. 1, pp. 213-214)
      // Sonorants: "do not influence the voicing of preceding, unvoiced consonants 
      // and are never devoiced themselves in lyric diction"
      sonorantIPA: new Set(['ɫ', 'lʲ', 'm', 'mʲ', 'n', 'nʲ', 'ɲ', 'r', 'rʲ', 'j']),
      
      // Voiced obstruents (can trigger voicing of preceding consonants)
      voicedObstruents: new Set(['b', 'bʲ', 'd', 'dʲ', 'ɡ', 'z', 'zʲ', 'ʒ']),
      
      // Voiceless obstruents (can trigger devoicing of preceding consonants)
      voicelessObstruents: new Set(['p', 'pʲ', 't', 'tʲ', 'k', 's', 'sʲ', 'ʃ', 'x', 'ts', 'tʃ', 'ʃtʃ']),
      
      // /v/ phonemes: "has no assimilative voicing influence of its own, 
      // but is influenced by most other consonants" (Grayson p. 214)
      vPhonemes: new Set(['v', 'vʲ', 'f', 'fʲ']),
      
      // Regressive voicing assimilation within words (Grayson Ch. 6 Sec. 1, pp. 214-224)
      // "The baseline approach to consonant clusters in Russian is to pronounce each 
      // consonant member in the cluster and to determine the voicing of all the 
      // consonants based upon the status of the last member of the cluster."
      applyRegressiveVoicing(ipa) {
        // Parse IPA into segments (consonants may be multi-char like tʃ, ʃtʃ, or have ʲ)
        const segments = this.parseIPASegments(ipa);
        if (segments.length < 2) return ipa;
        
        // Process clusters: find sequences of consonants
        // Note: stress marks (ˈ) can appear mid-cluster and must be preserved
        let result = [];
        let i = 0;
        
        while (i < segments.length) {
          const seg = segments[i];
          
          // If it's a vowel, just add it
          if (this.isIPAVowel(seg)) {
            result.push(seg);
            i++;
            continue;
          }
          
          // If it's a stress mark at start (before any consonant), just add it
          if (seg === 'ˈ') {
            result.push(seg);
            i++;
            continue;
          }
          
          // Found a consonant - collect the cluster (including any stress marks)
          let cluster = [seg];
          let stressPositions = []; // Track where stress marks appear in cluster
          let j = i + 1;
          while (j < segments.length && !this.isIPAVowel(segments[j])) {
            if (segments[j] === 'ˈ') {
              // Record position and skip for now (will reinsert after assimilation)
              stressPositions.push(cluster.length);
            } else {
              cluster.push(segments[j]);
            }
            j++;
          }
          
          // Apply voicing assimilation to this cluster (consonants only)
          if (cluster.length > 1) {
            cluster = this.assimilateClusterVoicing(cluster);
          }
          
          // Reinsert stress marks at their original positions
          for (let k = stressPositions.length - 1; k >= 0; k--) {
            cluster.splice(stressPositions[k], 0, 'ˈ');
          }
          
          result.push(...cluster);
          i = j;
        }
        
        return result.join('');
      },
      
      // Parse IPA string into segments (handling multi-char consonants)
      parseIPASegments(ipa) {
        const segments = [];
        let i = 0;
        
        while (i < ipa.length) {
          // Check for multi-char consonants first (longest match)
          if (ipa.slice(i, i + 3) === 'ʃtʃ') {
            segments.push('ʃtʃ');
            i += 3;
          } else if (ipa.slice(i, i + 2) === 'tʃ') {
            segments.push('tʃ');
            i += 2;
          } else if (ipa.slice(i, i + 2) === 'ts') {
            segments.push('ts');
            i += 2;
          } else if (ipa[i + 1] === 'ʲ' && ipa[i + 2] === 'ː') {
            // Consonant + palatalization + length (e.g., ʃʲː)
            segments.push(ipa.slice(i, i + 3));
            i += 3;
          } else if (ipa[i + 1] === 'ʲ') {
            // Consonant + palatalization marker
            segments.push(ipa.slice(i, i + 2));
            i += 2;
          } else if (ipa[i + 1] === 'ː') {
            // Consonant + length marker (e.g., ʃː, ʒː)
            segments.push(ipa.slice(i, i + 2));
            i += 2;
          } else {
            segments.push(ipa[i]);
            i++;
          }
        }
        
        return segments;
      },
      
      // Check if IPA segment is a vowel
      isIPAVowel(seg) {
        const ipaVowels = new Set(['ɑ', 'a', 'o', 'ɛ', 'e', 'i', 'ɪ', 'ɨ', 'u', 'ʊ', 'ʌ']);
        return ipaVowels.has(seg);
      },
      
      // Assimilate voicing within a consonant cluster (Grayson p. 214-215)
      // "the voicing of the entire cluster is that of the final member"
      assimilateClusterVoicing(cluster) {
        // Find the last non-sonorant, non-/v/ consonant - this is the "agent"
        let agentIndex = -1;
        for (let i = cluster.length - 1; i >= 0; i--) {
          const seg = cluster[i];
          if (this.sonorantIPA.has(seg)) continue;
          if (this.vPhonemes.has(seg)) continue;
          agentIndex = i;
          break;
        }
        
        // No agent found (all sonorants or /v/) - no assimilation
        if (agentIndex === -1) return cluster;
        
        const agent = cluster[agentIndex];
        const agentIsVoiced = this.voicedObstruents.has(agent);
        
        // Apply voicing/devoicing backwards from agent — sonorants block the chain
        const result = [...cluster];
        for (let i = agentIndex - 1; i >= 0; i--) {
          const seg = result[i];
          
          // Sonorants block assimilation — stop here (Grayson p. 213-214)
          if (this.sonorantIPA.has(seg)) break;
          
          if (agentIsVoiced) {
            // Voice the consonant if it's voiceless
            if (this.voicelessToVoiced[seg]) {
              result[i] = this.voicelessToVoiced[seg];
            }
          } else {
            // Devoice the consonant if it's voiced
            if (this.voicedToVoiceless[seg]) {
              result[i] = this.voicedToVoiceless[seg];
            }
          }
        }
        
        return result;
      },
      
      // Apply final devoicing to IPA string
      applyFinalDevoicing(ipa) {
        // Find the final consonant segment (may include palatalization marker)
        // Sonorants (ɫ, lʲ, m, mʲ, n, ɲ, r, rʲ, j) are never devoiced
        const sonorantPattern = /[ɫmnrj]ʲ?$/;
        if (sonorantPattern.test(ipa)) {
          return ipa; // Sonorants don't devoice
        }
        
        // Remove any trailing spaces for matching
        const trimmedIpa = ipa.trimEnd();
        
        // Check for voiced consonants at end and replace
        for (const [voiced, voiceless] of Object.entries(this.voicedToVoiceless)) {
          if (trimmedIpa.endsWith(voiced)) {
            return trimmedIpa.slice(0, -voiced.length) + voiceless;
          }
        }
        
        return ipa;
      },
      
      transcribe(word, stressIndex = -1, isClitic = false, procliticPosition = null) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // Check for isolated clitic — use canonical form from registry
        // (Phrase-context clitics have procliticPosition set by the caller)
        const cliticInfo = this.cliticData.get(cleanWord);
        if (cliticInfo && isClitic && !procliticPosition && this.countVowels(cleanWord) === 0) {
          // Return canonical citation form for isolated clitic
          return {
            ipa: cliticInfo.canonicalIpa,
            ipaUnderlying: cliticInfo.canonicalIpa,
            syllables: [{
              cyrillic: cleanWord,
              ipa: cliticInfo.canonicalIpa,
              isStressed: false
            }],
            transcriptionLog: [{
              cyrillic: cleanWord,
              ipa: cliticInfo.canonicalIpa,
              source: 'isolated-clitic',
              note: 'Canonical citation form — contextual pronunciation varies'
            }],
            source: 'isolated-clitic'
          };
        }
        
        const syllables = this.syllabify(cleanWord);
        const vowelCount = this.countVowels(cleanWord);
        
        // Find special clusters (e.g., сч → /ʃʲʃʲ/)
        const specialClusters = this.findSpecialClusters(cleanWord);
        
        // ё always carries stress — override any other stress assignment
        const yoSyllable = this.findYoSyllable(cleanWord);
        let effectiveStress;
        if (yoSyllable !== -1) {
          // ё found: stress is locked to that syllable
          effectiveStress = yoSyllable;
        } else if (vowelCount === 1 && !isClitic) {
          // Monosyllable (non-clitic): stress on only syllable
          effectiveStress = 0;
        } else {
          // Normal case: use provided stress index
          effectiveStress = stressIndex;
        }
        
        // Compute COMPLETE palatalization map for the whole word (Grayson p. 207-209)
        // This includes regressive AND progressive palatalization (for р after front vowels)
        // Architecture: single source of truth computed BEFORE any transcription
        const softIndices = this.computeCompletePalatalizationMap(cleanWord, syllables, effectiveStress);
        
        // Build a map of character position in full word to track palatalization
        let charIndexInWord = 0;
        
        let ipa = '';
        let syllableData = [];
        let transcriptionLog = [];  // Phase 1: Phoneme Ribbon data
        
        syllables.forEach((syl, sylIdx) => {
          // For proclitics with host-stress-aware reduction, use procliticPosition
          // This overrides the default 'unstressed' position for accurate vowel reduction
          let position;
          if (isClitic && procliticPosition) {
            position = procliticPosition;  // 'pretonic' or 'remote' based on host word stress
          } else {
            position = this.getSyllablePosition(sylIdx, effectiveStress, syllables.length);
          }
          let sylIpa = '';
          const chars = [...syl];
          
          // v5.11.45: Always add stress mark for stressed syllables
          // Previously only polysyllables got marks in underlying IPA, causing
          // monosyllables to lose their mark after cross-word assimilation
          if (position === 'stressed') {
            sylIpa += 'ˈ';
          }
          
          for (let i = 0; i < chars.length; i++) {
            const char = chars[i];
            const nextChar = chars[i + 1];
            const globalIndex = charIndexInWord + i; // Position in full word
            
            // Log soft/hard signs before skipping
            if (char === 'ь' || char === 'ъ') {
              transcriptionLog.push({
                char: char,
                ipa: '',  // Signs produce no sound of their own (v5.11.1)
                features: {
                  type: 'sign',
                  signType: char === 'ь' ? 'soft' : 'hard',
                  silent: true  // Mark as silent for ribbon display
                },
                syllableIndex: sylIdx,
                position: globalIndex
              });
              continue;
            }
            
            // Check if this character is part of a special cluster
            const clusterInfo = specialClusters.find(c => 
              globalIndex >= c.startIndex && globalIndex <= c.endIndex
            );
            
            if (clusterInfo) {
              // First char of cluster outputs the IPA and logs the cluster
              if (globalIndex === clusterInfo.startIndex) {
                sylIpa += clusterInfo.ipa;
                
                transcriptionLog.push({
                  char: clusterInfo.cluster,
                  ipa: clusterInfo.ipa,
                  features: {
                    type: 'cluster',
                    clusterChars: clusterInfo.cluster.length
                  },
                  syllableIndex: sylIdx,
                  position: globalIndex
                });
              }
              continue;
            }
            
            if (this.isVowel(char)) {
              const prevCharInSyllable = chars[i - 1];
              // Use word-level previous char for j-glide and interpalatal detection
              const prevCharInWord = cleanWord[globalIndex - 1];
              
              // Standard j-glide: iotated vowels at word-initial or after vowel/ъ/ь
              let needsGlide = ['е', 'ё', 'ю', 'я'].includes(char) && 
                               (globalIndex === 0 || this.isVowel(prevCharInWord) || prevCharInWord === 'ь' || prevCharInWord === 'ъ');
              
              // EXCEPTION: -ии suffix (Grayson p. 89, 120)
              // The suffix -ии is pronounced /i ji/ for singing clarity.
              // This is an exception to the rule that и after vowels doesn't get a j-glide.
              // Example: странствии → /ˈstrɑnst vʲi ji/, в здании → /v ˈzdɑ ɲi ji/
              const isIiSuffix = char === 'и' && prevCharInWord === 'и' && globalIndex === cleanWord.length - 1;
              if (isIiSuffix) {
                needsGlide = true;
              }
              
              // Add j-glide to IPA and log it
              if (needsGlide) {
                sylIpa += 'j';
                
                // Determine j-glide source for ribbon display
                let jGlideSource = 'iotated';  // default: iotated vowel
                if (isIiSuffix) {
                  jGlideSource = 'ii-suffix';
                } else if (prevCharInWord === 'ь') {
                  jGlideSource = 'after-sign';
                } else if (prevCharInWord === 'ъ') {
                  jGlideSource = 'after-sign';
                } else if (this.isVowel(prevCharInWord)) {
                  jGlideSource = 'after-vowel';
                } else if (globalIndex === 0) {
                  jGlideSource = 'word-initial';
                }
                
                // Log j-glide for Phoneme Ribbon
                transcriptionLog.push({
                  char: '',  // No Cyrillic character - it's implicit
                  ipa: 'j',
                  features: {
                    type: 'glide',
                    source: jGlideSource,
                    triggeredBy: char  // The vowel that triggered the glide
                  },
                  syllableIndex: sylIdx,
                  position: globalIndex - 0.5  // Position between prev and current char
                });
              }
              
              // Initialize vowel tracking
              let vowelIpa = null;
              let vowelFeatures = {
                type: 'vowel',
                position: position,
                interpalatal: false,
                afterHard: false,
                exception: null
              };
              
              // Check for exception word vowel override
              const vowelOverride = this.getVowelOverride(cleanWord, globalIndex);
              if (vowelOverride !== null) {
                vowelIpa = vowelOverride;
                vowelFeatures.exception = 'word-override';
              }
              
              // Check for -ая/-яя suffix exception (Grayson p. 124)
              // These endings are ALWAYS /ɑjɑ/, never reduced
              if (vowelIpa === null && this.isAyaSuffixVowel(cleanWord, globalIndex)) {
                vowelIpa = 'ɑ';
                vowelFeatures.exception = 'aya-suffix';
              }
              
              // Check for Old Muscovite velar adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
              // When profile adjectival='stage': и → [ɨ] after hard velar
              const profileParams = ProfileController.getParams();
              const velarAdj = this.checkVelarAdjectival(cleanWord, globalIndex);
              if (vowelIpa === null && velarAdj.isVelarAdjectival && velarAdj.charRole === 'i' && profileParams.adjectival === 'stage') {
                vowelIpa = 'ɨ';
                vowelFeatures.exception = 'velar-adjectival';
              }
              
              // Normal vowel transcription (if no exception applied)
              if (vowelIpa === null) {
                // Check preceding consonant palatalization (using regressive analysis)
                // Use word-level previous char, not within-syllable
                const prevConsonant = this.isConsonant(prevCharInWord) ? prevCharInWord : null;
                const prevGlobalIndex = globalIndex - 1;
                
                // Check if preceded by a special cluster (for interpalatal)
                const prevCluster = specialClusters.find(c => c.endIndex === prevGlobalIndex);
                
                // Iotated vowels at word-initial or after vowel/ъ/ь produce /j/ glide
                // The /j/ glide counts as a palatalizing agent (Grayson p. 125)
                const iotatedVowels = ['е', 'ё', 'ю', 'я'];
                const isIotated = iotatedVowels.includes(char);
                const isWordInitialOrAfterVowel = globalIndex === 0 || 
                  this.isVowel(prevCharInWord) || prevCharInWord === 'ъ' || prevCharInWord === 'ь';
                const precededByJGlide = isIotated && isWordInitialOrAfterVowel;
                
                const isPrecededByPal = prevCluster ?
                  prevCluster.ipa.includes('ʲ') :
                  (prevConsonant ? 
                    (softIndices.has(prevGlobalIndex) || this.isPalatalized(prevConsonant, char)) : 
                    precededByJGlide);  // Word-initial iotated → preceded by /j/
                
                // Check following consonant palatalization (Grayson p. 104, 106: interpalatal requires BOTH)
                // Find the next consonant after this vowel - must search in FULL WORD, not just current syllable
                let followingConsonant = null;
                let followingConsonantGlobalIndex = -1;
                let charAfterFollowingC = null;
                const wordChars = [...cleanWord];
                for (let j = globalIndex + 1; j < wordChars.length; j++) {
                  if (wordChars[j] === 'ь' || wordChars[j] === 'ъ') continue;
                  if (this.isConsonant(wordChars[j])) {
                    followingConsonant = wordChars[j];
                    followingConsonantGlobalIndex = j;
                    charAfterFollowingC = wordChars[j + 1];
                    break;
                  }
                  if (this.isVowel(wordChars[j])) break; // Hit another vowel first
                }
                
                // Check if the following consonant is part of a special cluster
                // If so, check the cluster's IPA for palatalization, not the Cyrillic letter
                const followingCluster = followingConsonant ? 
                  specialClusters.find(c => 
                    followingConsonantGlobalIndex >= c.startIndex && 
                    followingConsonantGlobalIndex <= c.endIndex
                  ) : null;
                
                let isFollowedByPal = false;
                if (followingConsonant === 'й') {
                  // й always counts as palatalized
                  isFollowedByPal = true;
                } else if (followingCluster) {
                  // Check the cluster's IPA output for palatalization
                  // e.g., чн→/ʃn/ starts with /ʃ/ which is hard (no ʲ at start)
                  // But сч→/ʃʲʃʲ/ starts with /ʃʲ/ which is soft
                  const clusterIPA = followingCluster.ipa;
                  // The first sound in the cluster is what follows the vowel
                  isFollowedByPal = clusterIPA.length > 1 && clusterIPA[1] === 'ʲ';
                } else if (followingConsonant) {
                  // Normal case: check the Cyrillic consonant
                  isFollowedByPal = softIndices.has(followingConsonantGlobalIndex) || 
                    this.isPalatalized(followingConsonant, charAfterFollowingC);
                } else {
                  // No following consonant found - check if next vowel is iotated
                  // Iotated vowels (е, ё, ю, я) produce /j/ glide which is a palatalizing agent
                  // This handles cases like её where /j/-[vowel]-/j/ is interpalatal
                  const iotatedVowels = ['е', 'ё', 'ю', 'я'];
                  for (let j = globalIndex + 1; j < wordChars.length; j++) {
                    if (wordChars[j] === 'ь' || wordChars[j] === 'ъ') continue;
                    if (this.isVowel(wordChars[j])) {
                      isFollowedByPal = iotatedVowels.includes(wordChars[j]);
                      break;
                    }
                    if (this.isConsonant(wordChars[j])) break;
                  }
                }
                
                // Capture interpalatal and afterHard features
                const prevConsonantForFeatures = this.isConsonant(prevCharInWord) ? prevCharInWord : null;
                vowelFeatures.interpalatal = isPrecededByPal && isFollowedByPal;
                vowelFeatures.afterHard = ['ж', 'ш', 'ц'].includes(prevConsonantForFeatures);
                
                vowelIpa = this.transcribeVowel(char, position, isPrecededByPal, isFollowedByPal, prevConsonantForFeatures);
              }
              
              sylIpa += vowelIpa;
              
              // Populate transcriptionLog for vowel
              transcriptionLog.push({
                char: char,
                ipa: vowelIpa,
                features: vowelFeatures,
                syllableIndex: sylIdx,
                position: globalIndex
              });
            } else if (this.isConsonant(char)) {
              const prevChar = chars[i - 1];
              const nextCharInWord = cleanWord[globalIndex + 1]; // For cross-syllable checks
              const isStressedSyl = (position === 'stressed');
              // Pass regressive palatalization info
              let isSoftFromRegressive = softIndices.has(globalIndex);
              
              // Check for Old Muscovite velar adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
              // When profile adjectival='stage': velar stays HARD (not palatalized)
              const profileParams = ProfileController.getParams();
              const velarAdj = this.checkVelarAdjectival(cleanWord, globalIndex);
              
              // Check for genitive ending -ого/-его: г → /v/ (Grayson p. 243)
              const isGenitiveG = (char === 'г') && this.checkGenitiveEnding(cleanWord, globalIndex);
              
              let consonantIpa;
              if (isGenitiveG) {
                // Genitive г → /v/
                consonantIpa = 'v';
              } else if (velarAdj.isVelarAdjectival && velarAdj.charRole === 'velar' && profileParams.adjectival === 'stage') {
                // Force hard velar: output base consonant without palatalization
                consonantIpa = this.inventory.consonants[char] || char;
              } else {
                consonantIpa = this.transcribeConsonant(char, nextChar, prevChar, isStressedSyl, isSoftFromRegressive, nextCharInWord);
              }
              sylIpa += consonantIpa;
              
              // Populate transcriptionLog for consonant
              const isSoft = consonantIpa.includes('ʲ') || consonantIpa === 'ɲ';
              let softTrigger = null;
              if (isSoft) {
                // Priority: direct triggers first, then regressive
                // A consonant before a front vowel is soft because of the vowel, not regressive assimilation
                if (nextChar === 'ь') {
                  softTrigger = 'ь';
                } else if (['е', 'ё', 'ю', 'я', 'и'].includes(nextChar)) {
                  softTrigger = nextChar;
                } else if (isSoftFromRegressive) {
                  softTrigger = 'regressive';
                }
              }
              
              transcriptionLog.push({
                char: char,
                ipa: consonantIpa,
                features: {
                  type: 'consonant',
                  soft: isSoft,
                  softTrigger: softTrigger,
                  genitiveEnding: isGenitiveG
                },
                syllableIndex: sylIdx,
                position: globalIndex
              });
            }
          }
          
          charIndexInWord += syl.length;
          
          syllableData.push({
            cyrillic: syl,
            ipa: sylIpa.replace(/^ˈ/, ''),
            isStressed: position === 'stressed'
          });
          
          ipa += sylIpa;
        });
        
        // Step 2 (Grayson p. 247): Apply regressive voicing assimilation
        ipa = this.applyRegressiveVoicing(ipa);
        
        // Sync syllable IPAs with word-level assimilation (v5.10.20)
        // Cross-syllable clusters (e.g., кз in вок-зал) are only caught at word level
        // Re-split the assimilated word IPA back into syllables
        const assimilatedSegments = this.parseIPASegments(ipa.replace(/ˈ/g, ''));
        let segmentIdx = 0;
        syllableData.forEach(syl => {
          // Count how many segments this syllable originally had
          const originalSegments = this.parseIPASegments(syl.ipa);
          const segmentCount = originalSegments.length;
          
          // Extract that many segments from the assimilated word
          const newSegments = assimilatedSegments.slice(segmentIdx, segmentIdx + segmentCount);
          syl.ipa = newSegments.join('');
          segmentIdx += segmentCount;
        });
        
        // Sync transcriptionLog to match surface IPA after voicing assimilation (v5.10.20)
        // The log was built before assimilation, so consonant entries may have stale IPA
        transcriptionLog.forEach(entry => {
          if (entry.features?.type === 'consonant') {
            const originalIpa = entry.ipa;
            // Check if this consonant was devoiced
            if (this.voicedToVoiceless[originalIpa]) {
              // Look at what's in the syllable data to see if it changed
              const sylData = syllableData[entry.syllableIndex];
              if (sylData && !sylData.ipa.includes(originalIpa)) {
                // The original voiced consonant is not in the syllable anymore
                // Check if the devoiced version is there
                const devoiced = this.voicedToVoiceless[originalIpa];
                if (sylData.ipa.includes(devoiced)) {
                  entry.ipa = devoiced;
                  entry.features.voicingAssimilation = true;
                  entry.features.devoiced = true;
                }
              }
            }
            // Check if this consonant was voiced
            if (this.voicelessToVoiced[originalIpa]) {
              const sylData = syllableData[entry.syllableIndex];
              if (sylData && !sylData.ipa.includes(originalIpa)) {
                const voiced = this.voicelessToVoiced[originalIpa];
                if (sylData.ipa.includes(voiced)) {
                  entry.ipa = voiced;
                  entry.features.voicingAssimilation = true;
                  entry.features.voiced = true;
                }
              }
            }
          }
        });
        
        // Step 3-4 will be special clusters and palatalization (future phases)
        
        // Final consonant devoicing (Grayson Ch. 4 Sec. 4, pp. 199-202)
        // For clitics, devoicing is deferred to cross-word stage (boundary-dependent)
        // For standalone words, apply devoicing now
        let ipaSurface = ipa;
        if (!isClitic) {
          // Exception: бог → /box/ (Grayson p. 242) — г becomes /x/ not /k/
          // This is a Church Slavonic preservation
          if (cleanWord === 'бог' && ipa.endsWith('ɡ')) {
            ipaSurface = ipa.slice(0, -1) + 'x';
            // Update syllable data to show /x/ not /ɡ/
            const lastSyl = syllableData[syllableData.length - 1];
            if (lastSyl && lastSyl.ipa.endsWith('ɡ')) {
              lastSyl.ipa = lastSyl.ipa.slice(0, -1) + 'x';
            }
            // Update transcriptionLog for the final г
            const lastConsonantEntry = transcriptionLog.findLast(e => e.char === 'г');
            if (lastConsonantEntry) {
              lastConsonantEntry.ipa = 'x';
              lastConsonantEntry.features.bogException = true;
              lastConsonantEntry.features.finalDevoicing = false; // Not standard devoicing
            }
          } else {
            ipaSurface = this.applyFinalDevoicing(ipa);
          }
        }
        
        return { ipa: ipaSurface, ipaUnderlying: ipa, syllables: syllableData, transcriptionLog };
      },
      
      /**
       * Auto-detect boundary types for a line of words.
       * Called after initial transcription, before cross-word assimilation.
       * 
       * Rules (in priority order):
       * 1. User-set boundaries are never overwritten
       * 2. Final word → always 'hard'
       * 3. Punctuation after word → 'hard'
       * 4. Current word is proclitic → 'clitic'
       * 5. Next word is enclitic → 'clitic'
       * 6. Otherwise → 'hard' (conservative default)
       */
      autoDetectBoundaries(words) {
        const punctuationRegex = /[.,!?;:"""''–—]$/;
        
        words.forEach((word, i) => {
          // Rule 1: Preserve user-set boundaries
          if (word.boundarySource === 'user') return;
          
          const isLastWord = (i === words.length - 1);
          const cleanWord = word.cyrillic.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
          const hasPunctuation = punctuationRegex.test(word.cyrillic);
          const isProclitic = this.proclitics.has(cleanWord);
          
          // Check if next word is enclitic
          const nextWord = words[i + 1];
          const nextCleanWord = nextWord 
            ? nextWord.cyrillic.replace(/[.,!?;:"""''–—]/g, '').toLowerCase() 
            : null;
          const nextIsEnclitic = nextCleanWord && this.enclitics.has(nextCleanWord);
          
          // Apply rules in priority order
          if (isLastWord) {
            word.rightBoundary = 'hard';
            word.boundarySource = 'auto';
          } else if (hasPunctuation) {
            word.rightBoundary = 'hard';
            word.boundarySource = 'punctuation';
          } else if (isProclitic) {
            word.rightBoundary = 'clitic';
            word.boundarySource = 'auto';
          } else if (nextIsEnclitic) {
            word.rightBoundary = 'clitic';
            word.boundarySource = 'auto';
          } else {
            // Default: SOFT — assimilation happens automatically
            // User can insert barriers when music has rests
            word.rightBoundary = 'soft';
            word.boundarySource = 'auto';
          }
        });
      },
      
      // --- CROSS-WORD BOUNDARY ASSIMILATION — Grayson p. 248-257 ---
      // Voiceless → Voiced (for cross-boundary voicing)
      crossWordVoicingMap: {
        'p': 'b', 'pʲ': 'bʲ',
        'f': 'v', 'fʲ': 'vʲ',
        't': 'd', 'tʲ': 'dʲ',
        's': 'z', 'sʲ': 'zʲ',
        'ʃ': 'ʒ',
        'k': 'ɡ', 'kʲ': 'ɡʲ',
        'x': 'ɣ', 'xʲ': 'ɣʲ',      // Cross-boundary allophone
        'ts': 'dz',                 // Cross-boundary allophone
        'tʃʲ': 'dʒʲ'                // Cross-boundary allophone
      },
      
      // Voiced → Voiceless (for cross-boundary devoicing)
      crossWordDevoicingMap: {
        'b': 'p', 'bʲ': 'pʲ',
        'v': 'f', 'vʲ': 'fʲ',
        'd': 't', 'dʲ': 'tʲ',
        'z': 's', 'zʲ': 'sʲ',
        'ʒ': 'ʃ',
        'ɡ': 'k', 'ɡʲ': 'kʲ',
        'g': 'k', 'gʲ': 'kʲ'        // Handle both ɡ and g
      },
      
      // Consonant sets for cross-word assimilation
      crossWordVoicelessSet: new Set(['p', 'pʲ', 'f', 'fʲ', 't', 'tʲ', 's', 'sʲ', 'ʃ', 'ʃʲ', 'k', 'kʲ', 'x', 'xʲ', 'ts', 'tʃʲ', 'ʃʲʃʲ']),
      crossWordVoicedObstruentSet: new Set(['b', 'bʲ', 'd', 'dʲ', 'g', 'gʲ', 'ɡ', 'ɡʲ', 'z', 'zʲ', 'ʒ', 'ʒʲ']),
      crossWordSonorantSet: new Set(['m', 'mʲ', 'n', 'nʲ', 'ɲ', 'l', 'lʲ', 'ɫ', 'r', 'rʲ', 'j']),
      crossWordVSet: new Set(['v', 'vʲ']),
      
      /**
       * Extract final consonant(s) from IPA string.
       * Returns null if word ends in vowel.
       */
      getFinalConsonant(ipa) {
        // Remove stress marks first
        const clean = ipa.replace(/[ˈˌ]/g, '');
        // Match final consonant cluster (including affricates and palatalization)
        // Order matters: try longer sequences first
        const patterns = [
          'ʃʲʃʲ', 'tʃʲ', 'dʒʲ', 'ts', 'dz',  // Affricates
          'bʲ', 'pʲ', 'vʲ', 'fʲ', 'dʲ', 'tʲ', 'gʲ', 'ɡʲ', 'kʲ', 'zʲ', 'sʲ', 'ʒʲ', 'ʃʲ', 'xʲ', 'mʲ', 'nʲ', 'lʲ', 'rʲ',  // Palatalized
          'b', 'p', 'v', 'f', 'd', 't', 'g', 'ɡ', 'k', 'z', 's', 'ʒ', 'ʃ', 'x', 'm', 'n', 'ɲ', 'l', 'ɫ', 'r', 'j'  // Plain
        ];
        
        for (const pat of patterns) {
          if (clean.endsWith(pat)) {
            return pat;
          }
        }
        return null;
      },
      
      /**
       * Extract initial consonant(s) from IPA string.
       * Returns null if word starts with vowel.
       */
      getInitialConsonant(ipa) {
        // Remove stress marks first
        const clean = ipa.replace(/[ˈˌ]/g, '');
        // Match initial consonant cluster
        const patterns = [
          'ʃʲʃʲ', 'tʃʲ', 'dʒʲ', 'ts', 'dz',
          'bʲ', 'pʲ', 'vʲ', 'fʲ', 'dʲ', 'tʲ', 'gʲ', 'ɡʲ', 'kʲ', 'zʲ', 'sʲ', 'ʒʲ', 'ʃʲ', 'xʲ', 'mʲ', 'nʲ', 'lʲ', 'rʲ',
          'b', 'p', 'v', 'f', 'd', 't', 'g', 'ɡ', 'k', 'z', 's', 'ʒ', 'ʃ', 'x', 'm', 'n', 'ɲ', 'l', 'ɫ', 'r', 'j'
        ];
        
        for (const pat of patterns) {
          if (clean.startsWith(pat)) {
            return pat;
          }
        }
        return null;
      },
      
      /**
       * Check if consonant is voiceless.
       */
      isVoicelessConsonant(c) {
        return this.crossWordVoicelessSet.has(c);
      },
      
      /**
       * Check if consonant is voiced obstruent (can trigger voicing).
       */
      isVoicedObstruent(c) {
        return this.crossWordVoicedObstruentSet.has(c);
      },
      
      /**
       * Check if consonant is sonorant (neutral for voicing).
       */
      isSonorantConsonant(c) {
        return this.crossWordSonorantSet.has(c);
      },
      
      /**
       * Check if consonant is /v/ (special: no assimilative influence per Grayson).
       */
      isVPhoneme(c) {
        return this.crossWordVSet.has(c);
      },
      
      /**
       * Apply voicing to final consonant of IPA string.
       */
      applyVoicingToFinal(ipa, finalC) {
        const voiced = this.crossWordVoicingMap[finalC];
        if (!voiced) return ipa;
        return ipa.slice(0, -finalC.length) + voiced;
      },
      
      /**
       * Apply devoicing to final consonant of IPA string.
       */
      applyDevoicingToFinal(ipa, finalC) {
        const devoiced = this.crossWordDevoicingMap[finalC];
        if (!devoiced) return ipa;
        return ipa.slice(0, -finalC.length) + devoiced;
      },
      
      /**
       * Apply cross-word voicing assimilation to a line of words.
       * Modifies word objects in place, setting ipaSurface.
       * 
       * Grayson p. 248-257:
       * - Voicing determined by RIGHTMOST consonant (regressive)
       * - Only crosses 'soft' or 'clitic' boundaries
       * - Sonorants and /v/ are neutral (don't trigger, but DO undergo)
       */
      applyCrossWordAssimilation(words) {
        // Initialize: copy ipaUnderlying to ipaSurface, set skipFinalDevoicing
        words.forEach(word => {
          word.ipaSurface = word.ipaUnderlying;
          word.skipFinalDevoicing = false;
        });
        
        // Process each boundary
        for (let i = 0; i < words.length - 1; i++) {
          const leftWord = words[i];
          const rightWord = words[i + 1];
          
          // Skip hard boundaries
          if (leftWord.rightBoundary === 'hard') continue;
          
          const leftFinal = this.getFinalConsonant(leftWord.ipaSurface);
          const rightInitial = this.getInitialConsonant(rightWord.ipaSurface);
          
          // Skip if either word lacks consonant at boundary
          if (!leftFinal || !rightInitial) continue;
          
          // Skip if right initial is sonorant or /v/ (no assimilative influence)
          if (this.isSonorantConsonant(rightInitial) || this.isVPhoneme(rightInitial)) continue;
          
          // SIBILANT MERGERS (Grayson pp. 235-236)
          // с/з + ш → /ʃː/, с/з + ж → /ʒː/
          // These take priority over voicing assimilation (complete merger, not just voicing change)
          const sibilantMergers = {
            's':  { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'z':  { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'sʲ': { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'zʲ': { 'ʃ': 'ʃː', 'ʒ': 'ʒː' }
          };
          
          if (sibilantMergers[leftFinal]?.[rightInitial]) {
            // Complete merger: delete left final, geminate right initial
            // Example: с шумом → /ʃːumʌm/ (not /s ʃumʌm/)
            const geminate = sibilantMergers[leftFinal][rightInitial];
            leftWord.ipaSurface = leftWord.ipaSurface.slice(0, -leftFinal.length);
            
            // Handle stress marks: getInitialConsonant strips stress marks before matching,
            // but ipaSurface may start with ˈ or ˌ. Preserve stress position.
            const rightSurface = rightWord.ipaSurface;
            const stressMatch = rightSurface.match(/^[ˈˌ]+/);
            const stressPrefix = stressMatch ? stressMatch[0] : '';
            const afterStress = rightSurface.slice(stressPrefix.length);
            const afterConsonant = afterStress.slice(rightInitial.length);
            rightWord.ipaSurface = stressPrefix + geminate + afterConsonant;
            
            leftWord.skipFinalDevoicing = true;
            continue; // Skip voicing assimilation - merger already handled
          }
          
          // Determine assimilation direction
          if (this.isVoicedObstruent(rightInitial) && this.isVoicelessConsonant(leftFinal)) {
            // Voice the left final: слух был → sɫuɣ bɨɫ
            leftWord.ipaSurface = this.applyVoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;
          } else if (this.isVoicelessConsonant(rightInitial) && this.isVoicedObstruent(leftFinal)) {
            // Devoice the left final: друг там → druk tam
            leftWord.ipaSurface = this.applyDevoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;  // Already handled
          } else if (this.isVoicelessConsonant(rightInitial) && this.isVPhoneme(leftFinal)) {
            // Special case: /v/ devoices before voiceless consonants (в шутку → f ʃutku)
            // Grayson: /v/ doesn't TRIGGER voicing, but DOES UNDERGO devoicing
            leftWord.ipaSurface = this.applyDevoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;
          }
        }
        
        // Apply final devoicing to words that didn't undergo cross-word assimilation
        words.forEach((word, i) => {
          const isLastWord = (i === words.length - 1);
          const hasHardBoundary = (word.rightBoundary === 'hard');
          
          if ((isLastWord || hasHardBoundary) && !word.skipFinalDevoicing) {
            word.ipaSurface = this.applyFinalDevoicing(word.ipaSurface);
          }
        });
      }
    };
    
    // Initialize derived clitic Sets from cliticData (DRY - single source of truth)
    GraysonEngine.proclitics = new Set(
      [...GraysonEngine.cliticData.entries()]
        .filter(([_, d]) => d.type === 'proclitic')
        .map(([k, _]) => k)
    );
    GraysonEngine.enclitics = new Set(
      [...GraysonEngine.cliticData.entries()]
        .filter(([_, d]) => d.type === 'enclitic')
        .map(([k, _]) => k)
    );

    /* OCR MODULE - Russian Text Recognition — Lazy-loads Tesseract.js for image-to-text */
    const OCRModule = {
      // Configuration
      TESSERACT_VERSION: '5',
      CDN_PRIMARY: 'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js',
      CDN_FALLBACK: 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js',
      INIT_TIMEOUT: 60000, // OCR can be slow
      MAX_IMAGE_WIDTH: 1200,
      CONFIDENCE_SKIP: 40,
      CONFIDENCE_DUBIOUS: 80,
      
      // State
      isLoaded: false,
      isProcessing: false,
      
      // Callbacks
      _onProgress: null,
      _onError: null,
      
      /**
       * Check if OCR is supported in this browser
       */
      isSupported() {
        return !!(
          window.Worker &&
          window.Blob &&
          window.URL &&
          window.FileReader &&
          HTMLCanvasElement.prototype.toBlob
        );
      },
      
      /**
       * Load external script with promise
       */
      loadScript(url) {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = url;
          script.async = true;
          script.onload = resolve;
          script.onerror = () => reject(new Error(`Failed to load: ${url}`));
          document.head.appendChild(script);
        });
      },
      
      /**
       * Initialize - just load the Tesseract.js library
       */
      async init() {
        if (this.isLoaded) return true;
        if (!this.isSupported()) {
          this._onError?.('OCR not supported in this browser');
          return false;
        }
        
        try {
          // Load Tesseract.js library with fallback
          if (!window.Tesseract) {
            try {
              await this.loadScript(this.CDN_PRIMARY);
            } catch (e) {
              await this.loadScript(this.CDN_FALLBACK);
            }
          }
          
          this.isLoaded = true;
          return true;
        } catch (err) {
          this.isLoaded = false;
          this._onError?.('OCR unavailable. Please type or paste text.');
          return false;
        }
      },
      
      /**
       * Resize image to max width while preserving aspect ratio
       */
      async resizeImage(file) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const url = URL.createObjectURL(file);
          
          img.onload = () => {
            URL.revokeObjectURL(url); // Free memory immediately
            
            let { width, height } = img;
            
            // Only downscale, never upscale
            if (width > this.MAX_IMAGE_WIDTH) {
              const ratio = this.MAX_IMAGE_WIDTH / width;
              width = this.MAX_IMAGE_WIDTH;
              height = Math.round(height * ratio);
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            resolve(canvas);
          };
          
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
          };
          
          img.src = url;
        });
      },
      
      /**
       * Preprocess canvas for better OCR (grayscale + contrast)
       */
      preprocessCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Convert to grayscale and boost contrast
        for (let i = 0; i < data.length; i += 4) {
          // Grayscale using luminance formula
          const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
          
          // Simple contrast boost (stretch to 0-255)
          const contrast = Math.min(255, Math.max(0, (gray - 128) * 1.5 + 128));
          
          data[i] = data[i + 1] = data[i + 2] = contrast;
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
      },
      
      /**
       * Fix common OCR errors and filter non-Russian content
       */
      cleanRussianText(text) {
        if (!text) return '';
        
        // Helper: calculate Cyrillic density of a string (0-1)
        const cyrillicDensity = (str) => {
          const letters = str.match(/[a-zA-Zа-яА-ЯёЁ]/g) || [];
          if (letters.length === 0) return 0;
          const cyrillic = str.match(/[а-яА-ЯёЁ]/g) || [];
          return cyrillic.length / letters.length;
        };
        
        // Helper: detect garbage patterns (garbled English→Cyrillic)
        const isGarbage = (str) => {
          // Contains $ or multiple punctuation mixed with letters
          if (/\$/.test(str)) return true;
          if (/[!?]{2,}/.test(str)) return true;
          // Parentheses with mostly non-Cyrillic inside
          if (/\([^)]*\)/.test(str)) {
            const parenContent = str.match(/\(([^)]*)\)/)?.[1] || '';
            if (cyrillicDensity(parenContent) < 0.3) return true;
          }
          // Backslash (common OCR error)
          if (/\\/.test(str)) return true;
          return false;
        };
        
        let result = text;
        
        // Filter lines: keep only those with >50% Cyrillic letters
        result = result.split('\n').filter(line => {
          const trimmed = line.trim();
          if (!trimmed) return false;
          
          // Skip garbage patterns
          if (isGarbage(trimmed)) {
            return false;
          }
          
          // Check Cyrillic density
          const density = cyrillicDensity(trimmed);
          if (density < 0.5) {
            return false;
          }
          
          return true;
        }).join('\n');
        
        // Latin→Cyrillic fixes (only between Cyrillic chars)
        const latinToCyrillic = [
          [/(?<=[а-яА-ЯёЁ])3(?=[а-яА-ЯёЁ])/g, 'з'],
          [/(?<=[а-яА-ЯёЁ])e(?=[а-яА-ЯёЁ])/gi, 'е'],
          [/(?<=[а-яА-ЯёЁ])c(?=[а-яА-ЯёЁ])/gi, 'с'],
          [/(?<=[а-яА-ЯёЁ])o(?=[а-яА-ЯёЁ])/gi, 'о'],
          [/(?<=[а-яА-ЯёЁ])p(?=[а-яА-ЯёЁ])/gi, 'р'],
          [/(?<=[а-яА-ЯёЁ])x(?=[а-яА-ЯёЁ])/gi, 'х'],
          [/(?<=[а-яА-ЯёЁ])a(?=[а-яА-ЯёЁ])/gi, 'а'],
          [/(?<=[а-яА-ЯёЁ])y(?=[а-яА-ЯёЁ])/gi, 'у'],
          [/(?<=[а-яА-ЯёЁ])H(?=[а-яА-ЯёЁ])/g, 'Н'],
          [/(?<=[а-яА-ЯёЁ])B(?=[а-яА-ЯёЁ])/g, 'В'],
          [/(?<=[а-яА-ЯёЁ])K(?=[а-яА-ЯёЁ])/g, 'К'],
          [/(?<=[а-яА-ЯёЁ])M(?=[а-яА-ЯёЁ])/g, 'М'],
        ];
        
        for (const [pattern, replacement] of latinToCyrillic) {
          result = result.replace(pattern, replacement);
        }
        
        // Filter out garbage words within lines
        result = result.split('\n').map(line => {
          return line.split(/\s+/).filter(word => {
            // Keep if word contains at least one Cyrillic letter
            if (/[а-яА-ЯёЁ]/.test(word)) return true;
            // Filter out pure numbers (page numbers like "219")
            if (/^\d+$/.test(word)) return false;
            // Filter out single non-Cyrillic characters
            if (word.length === 1 && !/[а-яА-ЯёЁ]/.test(word)) return false;
            // Keep punctuation
            if (/^[.,!?;:\-—–]+$/.test(word)) return true;
            return false;
          }).join(' ');
        }).filter(line => line.trim()).join('\n');
        
        // Structural cleanup
        result = result
          .replace(/[ \t]+/g, ' ')           // Collapse spaces
          .replace(/\n{3,}/g, '\n\n')        // Max 2 newlines
          .replace(/^\s+|\s+$/gm, '');       // Trim lines
        
        return result;
      },
      
      /**
       * Main entry point: process image file → Russian text
       * Uses Tesseract.recognize() which handles worker lifecycle internally
       */
      async processImage(file, onProgress) {
        if (this.isProcessing) {
          return null;
        }
        
        if (!this.isLoaded) {
          const loaded = await this.init();
          if (!loaded) {
            throw new Error('OCR initialization failed');
          }
        }
        
        this.isProcessing = true;
        
        try {
          // Step 1: Resize image
          onProgress?.('processing', 0);
          const canvas = await this.resizeImage(file);
          
          // Step 2: Preprocess for better recognition
          onProgress?.('processing', 0.1);
          this.preprocessCanvas(canvas);
          
          // Step 3: Run Tesseract using simple recognize() API
          // Use rus+eng to handle mixed content (headers, metadata)
          // Then filter to keep only Cyrillic-dominant lines
          onProgress?.('recognizing text', 0.2);
          
          const result = await Tesseract.recognize(canvas, 'rus+eng', {
            logger: m => {
              if (m.status) {
                onProgress?.(m.status, m.progress);
              }
            }
          });
          
          // Step 4: Use full text (preserves line structure) instead of rebuilding from words
          onProgress?.('cleaning', 0.9);
          
          // Use data.text which preserves line breaks and layout
          let text = result.data.text || '';
          
          // Step 5: Clean up the text
          text = this.cleanRussianText(text);
          
          // Validate we got Cyrillic content
          if (!/[а-яА-ЯёЁ]{3,}/.test(text)) {
            throw new Error('No Cyrillic text found in image');
          }
          
          return text;
          
        } finally {
          this.isProcessing = false;
        }
      },
      
      /**
       * Set error callback
       */
      onError(callback) {
        this._onError = callback;
      }
    };

    /* RULE REGISTRY - Phoneme Ribbon Blurbs — Maps transcription features → educational blurbs */
    const RuleRegistry = {
      // Blurb data loaded from data/rule-registry.json
      blurbs: {},
      
      // Derive rule name from transcriptionLog features
      // Expected softTrigger values:
      // - Soft vowels: 'е', 'ё', 'ю', 'я', 'и'
      // - Soft sign: 'ь'
      // - Regressive palatalization: 'regressive'
      deriveRule(features, char) {
        if (features.type === 'vowel') {
          // Check for exception rules first
          if (features.exception) return features.exception;
          
          // Stressed vowels
          if (features.position === 'stressed') {
            return features.interpalatal ? 'stressed-interpalatal' : 'stressed';
          }
          
          // Unstressed vowels
          // afterHard only applies to и and е (which become ɨ after ж/ш/ц)
          // а is unaffected by preceding hard consonants - it still follows position rules
          const lowerChar = char?.toLowerCase();
          if (features.afterHard && (lowerChar === 'и' || lowerChar === 'е')) return 'after-hard';
          if (features.position === 'pretonic') return 'pretonic';
          if (features.position === 'initial') return 'initial';
          if (features.position === 'posttonic-immediate') return 'post-stress-immediate';
          if (features.position === 'remote') return 'remote';
          return 'unstressed';
        }
        
        if (features.type === 'consonant') {
          const lowerChar = char?.toLowerCase();
          
          // Final devoicing takes precedence (v5.5.1)
          if (features.finalDevoicing) {
            return 'final-devoicing';
          }
          
          // Always-soft consonants (ч, щ)
          if (['ч', 'щ'].includes(lowerChar)) {
            return 'always-soft';
          }
          // Always-hard consonants (ж, ш, ц)
          if (['ж', 'ш', 'ц'].includes(lowerChar)) {
            return 'always-hard';
          }
          // Glide й
          if (lowerChar === 'й') {
            return 'glide';
          }
          // Soft consonants → 'soft'
          if (features.soft) {
            return 'soft';
          }
          // Hard consonants → 'hard'
          return 'hard';
        }
        
        if (features.type === 'sign') {
          return features.signType === 'soft' ? 'soft-sign' : 'hard-sign';
        }
        
        if (features.type === 'cluster') {
          return 'cluster';
        }
        
        return 'unknown';
      },
      
      // Look up blurb data for a transcriptionLog entry
      lookupBlurb(entry) {
        const { features, char, ipa } = entry;
        
        // Check for regressive devoicing assimilation (v5.10.20)
        if (features?.voicingAssimilation && features?.devoiced) {
          const key = `${ipa}:regressive-devoicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for regressive voicing assimilation (v5.10.21)
        if (features?.voicingAssimilation && features?.voiced) {
          const key = `${ipa}:regressive-voicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for final devoicing
        if (features?.finalDevoicing) {
          const key = `${ipa}:final-devoicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for genitive ending г → /v/ (Grayson p. 243)
        if (features?.genitiveEnding) {
          const key = `${ipa}:genitive:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for бог exception г → /x/ (Grayson p. 242)
        if (features?.bogException) {
          const key = `x:exception:бог`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for j-glide entries (v5.11.44)
        if (features?.type === 'glide' && ipa === 'j') {
          const source = features.source;
          const triggeredBy = features.triggeredBy || 'е';
          
          // Map source to blurb key
          if (source === 'ii-suffix') {
            const key = 'j:ii-suffix:и';
            if (this.blurbs[key]) {
              return this.blurbs[key];
            }
          } else if (source === 'after-vowel') {
            const key = `j:after-vowel:${triggeredBy}`;
            if (this.blurbs[key]) {
              return this.blurbs[key];
            }
          } else if (source === 'after-sign') {
            const key = `j:after-sign:${triggeredBy}`;
            if (this.blurbs[key]) {
              return this.blurbs[key];
            }
          }
          
          // Default j-glide blurb
          return {
            blurb: {
              en: 'The palatal glide /j/ precedes this vowel.',
              fr: 'La glissante palatale /j/ précède cette voyelle.'
            },
            citation: 'pp. 114–124',
            notable: false
          };
        }
        
        const rule = this.deriveRule(features, char);
        
        // Signs have empty IPA - key format is just 'rule:char' (e.g., 'soft-sign:ь')
        const key = ipa ? `${ipa}:${rule}:${char}` : `${rule}:${char}`;
        
        if (this.blurbs[key]) return this.blurbs[key];
        
        // Fallback for non-reducing vowels (у, ю, и, ы): try generic 'unstressed' or 'stressed'
        if (features?.type === 'vowel' && !this.blurbs[key]) {
          const fallbackRule = features.position === 'stressed' ? 'stressed' : 'unstressed';
          const fallbackKey = `${ipa}:${fallbackRule}:${char}`;
          if (this.blurbs[fallbackKey]) return this.blurbs[fallbackKey];
        }
        
        return {
          blurb: `${char} → ${ipa}`,
          citation: null,
          notable: false
        };
      },
      
      // Build display log with blurb data (memoizable)
      // Expands cluster entries into per-character rows for educational clarity
      buildDisplayLog(transcriptionLog) {
        // Cluster breakdowns for educational display
        // Maps cluster string to array of per-character entries
        const CLUSTER_BREAKDOWNS = {
          // Silent consonant clusters (Grayson pp. 235-236)
          'рдц': [
            { char: 'р', ipa: 'r', features: { type: 'consonant', soft: false } },
            { char: 'д', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'ц', ipa: 'ts', features: { type: 'consonant', soft: false, alwaysHard: true } }
          ],
          'лнц': [
            { char: 'л', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'н', ipa: 'n', features: { type: 'consonant', soft: false } },
            { char: 'ц', ipa: 'ts', features: { type: 'consonant', soft: false, alwaysHard: true } }
          ],
          'вств': [
            { char: 'в', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'с', ipa: 's', features: { type: 'consonant', soft: false } },
            { char: 'т', ipa: 't', features: { type: 'consonant', soft: false } },
            { char: 'в', ipa: 'v', features: { type: 'consonant', soft: false } }
          ],
          // Geminate simplification (Grayson p. 233)
          'сс': [
            { char: 'с', ipa: 's', features: { type: 'consonant', soft: false } },
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, geminateSimplified: true } }
          ],
          // Assimilated clusters - TRUE MERGERS (Grayson pp. 230-231)
          // Both letters merge into ONE sound - use merged display
          'сч': {
            type: 'merged',
            mergedIpa: 'ʃʲʃʲ',
            members: [
              { char: 'с', features: { type: 'consonant', soft: true, clusterAssimilation: true } },
              { char: 'ч', features: { type: 'consonant', soft: true, alwaysSoft: true } }
            ]
          },
          'зч': {
            type: 'merged',
            mergedIpa: 'ʃʲʃʲ',
            members: [
              { char: 'з', features: { type: 'consonant', soft: true, clusterAssimilation: true } },
              { char: 'ч', features: { type: 'consonant', soft: true, alwaysSoft: true } }
            ]
          },
          // Sibilant mergers (Grayson pp. 235-236)
          'сш': [
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ш' } },
            { char: 'ш', ipa: 'ʃː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'зш': [
            { char: 'з', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ш', devoices: true } },
            { char: 'ш', ipa: 'ʃː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'сж': [
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ж', voices: true } },
            { char: 'ж', ipa: 'ʒː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'зж': [
            { char: 'з', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ж' } },
            { char: 'ж', ipa: 'ʒː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          // Word-specific чн → шн (Grayson p. 239)
          'чн': [
            { char: 'ч', ipa: 'ʃ', features: { type: 'consonant', soft: false, clusterAssimilation: true } },
            { char: 'н', ipa: 'n', features: { type: 'consonant', soft: false } }
          ],
          // Word-specific чт → шт (Grayson p. 240)
          'чт': [
            { char: 'ч', ipa: 'ʃ', features: { type: 'consonant', soft: false, clusterAssimilation: true } },
            { char: 'т', ipa: 't', features: { type: 'consonant', soft: false } }
          ]
        };
        
        const expandedLog = [];
        
        transcriptionLog.forEach(entry => {
          // Check if this is a cluster that should be expanded
          if (entry.features?.type === 'cluster' && CLUSTER_BREAKDOWNS[entry.char]) {
            const breakdown = CLUSTER_BREAKDOWNS[entry.char];
            
            // Check if this is a "merged" cluster (both letters → one sound)
            if (breakdown.type === 'merged') {
              // Get the shared blurb for this merged cluster
              const clusterBlurb = this.lookupBlurb({
                char: entry.char,
                ipa: breakdown.mergedIpa,
                features: { type: 'cluster' }
              });
              
              breakdown.members.forEach((charEntry, idx) => {
                const isFirst = idx === 0;
                const isLast = idx === breakdown.members.length - 1;
                
                expandedLog.push({
                  char: charEntry.char,
                  ipa: isFirst ? breakdown.mergedIpa : '', // Only first row shows IPA
                  features: charEntry.features,
                  syllableIndex: entry.syllableIndex,
                  position: entry.position + idx,
                  // Cluster grouping metadata
                  clusterSource: entry.char,
                  clusterMerged: true,
                  clusterStart: isFirst,
                  clusterEnd: isLast,
                  clusterContinuation: !isFirst,
                  // Blurb only on first row (will be shared visually)
                  blurbData: isFirst ? clusterBlurb : { blurb: '', citation: null, notable: false }
                });
              });
            } else {
              // Standard array format (silent letter clusters, etc.)
              breakdown.forEach((charEntry, idx) => {
                expandedLog.push({
                  char: charEntry.char,
                  ipa: charEntry.ipa,
                  features: charEntry.features,
                  syllableIndex: entry.syllableIndex,
                  position: entry.position + idx,
                  // Mark as part of cluster for potential styling
                  clusterSource: entry.char,
                  blurbData: this.lookupClusterCharBlurb(charEntry, entry.char)
                });
              });
            }
          } else {
            // Regular entry, add blurb data
            expandedLog.push({
              ...entry,
              blurbData: this.lookupBlurb(entry)
            });
          }
        });
        
        return expandedLog;
      },
      
      // Look up blurb for a character within an expanded cluster
      lookupClusterCharBlurb(charEntry, clusterSource) {
        const { char, ipa, features } = charEntry;
        
        // Silent letters get the deletion:cluster blurb
        if (features.silent && features.deletionCluster) {
          return {
            blurb: `In the cluster ⟨${clusterSource}⟩, the letter ⟨${char}⟩ is silent and not pronounced. This is one of several consonant clusters in Russian where a letter is written but has no phonetic realization.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        // Geminate simplified
        if (features.silent && features.geminateSimplified) {
          return {
            blurb: `In ⟨русский⟩ and its declensions, the doubled ⟨сс⟩ is pronounced as a single /s/, not as a geminate. This is an exception to the normal geminate rule.`,
            citation: 'p. 233',
            notable: true
          };
        }
        
        // Cluster assimilation (сч, зч → щ sound)
        if (features.clusterAssimilation && clusterSource === 'сч') {
          return {
            blurb: `The cluster ⟨сч⟩ is pronounced like ⟨щ⟩: a long soft hushing sound /ʃʲʃʲ/. The ⟨с⟩ fully assimilates to match the following ⟨ч⟩.`,
            citation: 'pp. 230–231',
            notable: true
          };
        }
        
        if (features.clusterAssimilation && clusterSource === 'зч') {
          return {
            blurb: `The cluster ⟨зч⟩ is pronounced like ⟨щ⟩: a long soft hushing sound /ʃʲʃʲ/. The ⟨з⟩ fully assimilates to match the following ⟨ч⟩.`,
            citation: 'pp. 230–231',
            notable: true
          };
        }
        
        // Sibilant mergers (Grayson pp. 235-236)
        if (features.sibilantMerger) {
          const mergeTarget = features.mergesInto;
          const voiceChange = features.voices ? ' (voicing)' : features.devoices ? ' (devoicing)' : '';
          return {
            blurb: `The ⟨${char}⟩ merges completely into the following ⟨${mergeTarget}⟩${voiceChange}, lengthening it to /ʒː/ or /ʃː/.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        if (features.receivesLength) {
          return {
            blurb: `This ⟨${char}⟩ receives length from the preceding sibilant, producing a geminate /ʒː/ or /ʃː/.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        // чн → шн assimilation
        if (features.clusterAssimilation && clusterSource === 'чн') {
          return {
            blurb: `In certain common words (⟨конечно⟩, ⟨скучно⟩, ⟨нарочно⟩, ⟨яичница⟩), the cluster ⟨чн⟩ is pronounced /ʃn/ rather than /tʃn/. This is a historical pronunciation retained in everyday speech.`,
            citation: 'p. 239',
            notable: true
          };
        }
        
        // чт → шт assimilation
        if (features.clusterAssimilation && clusterSource === 'чт') {
          return {
            blurb: `In ⟨что⟩, ⟨чтобы⟩, and ⟨ничто⟩, the cluster ⟨чт⟩ is pronounced /ʃt/ rather than /tʃt/. This is one of the most common pronunciation exceptions in Russian.`,
            citation: 'p. 240',
            notable: true
          };
        }
        
        // Default: look up regular blurb
        return this.lookupBlurb({ char, ipa, features });
      }
    };

    /* IPA TOKENIZER — Parses IPA strings into draggable atomic units — Affricates and palatalized consonants travel as single tokens */
    const IpaTokenizer = {
      // Affricates that must travel as single units (longest first for matching)
      AFFRICATES: ['ʃtʃ', 'tʃ', 'ts', 'dʒ'],
      
      // IPA vowels (including variants)
      VOWELS: new Set([
        'a', 'ɑ', 'æ', 'e', 'ɛ', 'i', 'ɪ', 'o', 'ɔ', 'u', 'ʊ', 'ɨ', 'ə', 'ʌ'
      ]),
      
      // Modifiers that attach to preceding consonant
      MODIFIERS: new Set(['ʲ', 'ʷ', 'ˠ', 'ː']),
      
      // Check if character is a vowel
      isVowel(char) {
        return this.VOWELS.has(char);
      },
      
      /**
       * Tokenize an IPA string into atomic units
       * Each token: { symbol: string, isVowel: boolean, isGeminate: boolean }
       * 
       * Example: 'krɐsá' → ['k', 'r', 'ɐ', 's', 'á']
       * Example: 'vʲjotːsʌ' → ['vʲ', 'j', 'o', 'tː', 's', 'ʌ']
       * Example: 'tʃajtʃ' → ['tʃ', 'a', 'j', 'tʃ']
       */
      tokenize(ipa) {
        // Strip stress marks for tokenization (they stay with vowels)
        const clean = ipa.replace(/[ˈˌ]/g, '');
        const tokens = [];
        let i = 0;
        
        while (i < clean.length) {
          // Check for affricates first (longest match wins)
          let foundAffricate = false;
          for (const affricate of this.AFFRICATES) {
            if (clean.slice(i, i + affricate.length) === affricate) {
              let symbol = affricate;
              i += affricate.length;
              
              // Check for following modifiers (palatalization, length)
              while (i < clean.length && this.MODIFIERS.has(clean[i])) {
                symbol += clean[i];
                i++;
              }
              
              tokens.push({
                symbol,
                isVowel: false,
                isGeminate: symbol.includes('ː')
              });
              foundAffricate = true;
              break;
            }
          }
          if (foundAffricate) continue;
          
          // Check for vowels
          if (this.isVowel(clean[i])) {
            tokens.push({
              symbol: clean[i],
              isVowel: true,
              isGeminate: false
            });
            i++;
            continue;
          }
          
          // Consonant - collect following modifiers
          let symbol = clean[i];
          i++;
          
          while (i < clean.length && this.MODIFIERS.has(clean[i])) {
            symbol += clean[i];
            i++;
          }
          
          tokens.push({
            symbol,
            isVowel: false,
            isGeminate: symbol.includes('ː')
          });
        }
        
        return tokens;
      },
      
      /**
       * Parse tokens into onset/nucleus/coda structure
       * Returns: { onset: [...], nucleus: token, coda: [...] }
       */
      parseSegments(tokens) {
        const vowelIdx = tokens.findIndex(t => t.isVowel);
        
        if (vowelIdx === -1) {
          // No vowel (edge case - shouldn't happen in valid syllables)
          return { onset: tokens, nucleus: null, coda: [] };
        }
        
        return {
          onset: tokens.slice(0, vowelIdx),
          nucleus: tokens[vowelIdx],
          coda: tokens.slice(vowelIdx + 1)
        };
      },
      
      /**
       * Reconstruct IPA string from tokens
       */
      join(tokens) {
        return tokens.map(t => t.symbol).join('');
      }
    };

    /* BOUNDARY STACK — Manages display-only syllable boundary offsets — Source data is NEVER mutated - only cut points change */
    const BoundaryStack = {
      // Storage: Map of wordId → array of boundary offsets
      // Positive offset = stole consonant from right
      // Negative offset = gave consonant to right
      _offsets: new Map(),
      
      /**
       * Get boundary offsets for a word (creates default if none)
       */
      getOffsets(wordId, syllableCount) {
        if (!this._offsets.has(wordId)) {
          // Default: all offsets are 0 (no adjustment)
          this._offsets.set(wordId, new Array(syllableCount).fill(0));
        }
        return this._offsets.get(wordId);
      },
      
      /**
       * Shift a boundary (move consonant between syllables)
       * direction: 'left' (steal from right) or 'right' (give to right)
       * boundaryIdx: which boundary (0 = between syl0 and syl1)
       */
      shiftBoundary(wordId, boundaryIdx, direction, syllableCount) {
        const offsets = this.getOffsets(wordId, syllableCount);
        
        if (direction === 'left') {
          offsets[boundaryIdx]++;  // Steal one consonant from right syllable
        } else {
          offsets[boundaryIdx]--;  // Give one consonant to right syllable
        }
        
        return offsets;
      },
      
      /**
       * Reset all boundaries for a word to default
       */
      reset(wordId) {
        this._offsets.delete(wordId);
      },
      
      /**
       * Check if word has any custom boundaries
       */
      hasCustomBoundaries(wordId) {
        const offsets = this._offsets.get(wordId);
        return offsets && offsets.some(o => o !== 0);
      },
      
      /**
       * Clear all stored offsets (session reset)
       */
      clearAll() {
        this._offsets.clear();
      },
      
      /**
       * Apply boundary offsets to render display syllables
       * Takes the original syllable data and returns adjusted display syllables
       * 
       * CRITICAL: This NEVER mutates source data
       * It only computes where to visually cut the token stream
       */
      applyOffsets(wordId, originalSyllables) {
        const syllableCount = originalSyllables.length;
        const offsets = this.getOffsets(wordId, syllableCount);
        
        // If no custom boundaries, return original
        if (!offsets.some(o => o !== 0)) {
          return originalSyllables;
        }
        
        // Flatten all syllables into one token stream (preserving order)
        const allTokens = [];
        const originalBoundaries = [0]; // Indices where each syllable starts
        
        originalSyllables.forEach((syl, idx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          if (idx > 0) {
            originalBoundaries.push(allTokens.length);
          }
          allTokens.push(...tokens);
        });
        originalBoundaries.push(allTokens.length); // End marker
        
        // Calculate adjusted boundaries
        const adjustedBoundaries = originalBoundaries.map((boundary, idx) => {
          if (idx === 0 || idx === originalBoundaries.length - 1) {
            return boundary; // First and last boundaries don't move
          }
          return boundary + offsets[idx - 1];
        });
        
        // Clamp boundaries to valid range
        for (let i = 1; i < adjustedBoundaries.length - 1; i++) {
          adjustedBoundaries[i] = Math.max(
            adjustedBoundaries[i - 1] + 1, // Must have at least 1 token
            Math.min(adjustedBoundaries[i], adjustedBoundaries[i + 1] - 1)
          );
        }
        
        // Build display syllables from adjusted boundaries
        const displaySyllables = [];
        for (let i = 0; i < syllableCount; i++) {
          const start = adjustedBoundaries[i];
          const end = adjustedBoundaries[i + 1];
          const tokens = allTokens.slice(start, end);
          
          displaySyllables.push({
            ...originalSyllables[i],
            ipa: IpaTokenizer.join(tokens),
            displayTokens: tokens,
            isModified: start !== originalBoundaries[i] || end !== originalBoundaries[i + 1]
          });
        }
        
        return displaySyllables;
      }
    };

    const DocumentState = {
      lines: [],
      userName: '',  // Empty = [unattributed] in footer; populated from localStorage on init
      metadata: {
        composer: '',
        composerDates: '',
        title: '',
        opus: '',
        poet: '',
        poetDates: ''
      },
      
      updateStress(lineIndex, wordIndex, newStress) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].stress = newStress;
          // Attribution is a deliberate scholarly act — don't auto-set source
        }
      },
      
      updateStressSource(lineIndex, wordIndex, source) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].stressSource = source;
        }
      },
      
      updateGloss(lineIndex, wordIndex, newGloss) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].gloss = { en: newGloss, fr: newGloss };
        }
      }
    };

    /* RIBBON RENDERER — Phoneme ribbon HTML construction and syllable index calculation */
    const RibbonRenderer = {
      renderRibbon(wordData, targetContainer = null) {
        const container = targetContainer;
        if (!container) return;
        
        const log = wordData.transcriptionLog || [];
        if (log.length === 0) {
          container.innerHTML = '<div style="color: var(--ink-tertiary); font-size: 0.85rem; padding: 1rem; text-align: center;">No transcription data available</div>';
          return;
        }
        
        // Build displayLog with blurb data (memoized per Kimi's optimization)
        const displayLog = RuleRegistry.buildDisplayLog(log);
        
        // Get boundary-adjusted syllables (v5.10.25)
        const wordId = `${wordData.lineIndex}-${wordData.wordIndex}`;
        const originalSyllables = wordData.syllables;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, originalSyllables);
        const hasCustomBoundaries = BoundaryStack.hasCustomBoundaries(wordId);
        
        // Recalculate syllable assignments if boundaries were adjusted
        let adjustedDisplayLog = displayLog;
        if (hasCustomBoundaries) {
          adjustedDisplayLog = this.recalculateSyllableIndices(displayLog, originalSyllables, displaySyllables);
        }
        
        // Group by (adjusted) syllable
        const syllableGroups = new Map();
        adjustedDisplayLog.forEach(entry => {
          const sylIdx = entry.adjustedSyllableIndex ?? entry.syllableIndex ?? 0;
          if (!syllableGroups.has(sylIdx)) {
            syllableGroups.set(sylIdx, []);
          }
          syllableGroups.get(sylIdx).push(entry);
        });
        
        // Get stressed syllable index
        const syllables = wordData.syllables;
        const stressedIdx = syllables.findIndex(s => s.isStressed);
        
        // Build vertical ribbon HTML
        let html = '';
        let isFirstSyllable = true;
        
        // Clitic detection (v6.0.17 - arrows replace tie bar)
        const isProclitic = wordData.isProclitic === 'true' || wordData.isProclitic === true;
        const isEnclitic = wordData.isEnclitic === 'true' || wordData.isEnclitic === true;
        
        // Proclitic blurb (approved by Dann, Feb 3 2026)
        const procliticBlurb = `Some short words — prepositions like "в" and "на," the negation "не" — don't carry their own stress. Instead, they lean forward and attach to the word that follows, forming a single unit of pronunciation. Voicing and palatalization flow right through the boundary as if it were one word. The arrow marks this forward binding.`;
        const procliticCitation = `Grayson (2012), pp. 248–255`;
        
        // Enclitic blurb (approved by Dann, Feb 3 2026)
        const encliticBlurb = `Certain particles — "ли" (question), "же" (emphasis), "бы" (conditional) — attach backward to the word before them. They're unstressed and form a single phonological unit with their host. The same assimilation rules apply across this bond as within any word. The arrow marks this backward binding.`;
        const encliticCitation = `Grayson (2012), pp. 248–255`;
        
        syllableGroups.forEach((entries, sylIdx) => {
          const isStressed = sylIdx === stressedIdx;
          
          // Wrap stressed syllable in tinted region
          if (isStressed) {
            html += `<div class="stressed-syllable-region">`;
          }
          
          // Process entries, grouping merged clusters with two-layer architecture (v5.11.30)
          let i = 0;
          while (i < entries.length) {
            const entry = entries[i];
            const blurb = entry.blurbData;
            const isFirstInSyllable = i === 0;
            const syllableStart = isFirstInSyllable && !isFirstSyllable && !isStressed;
            const isSilent = entry.features?.silent || entry.ipa === '';
            
            // Check if this starts a merged cluster
            if (entry.clusterMerged && entry.clusterStart) {
              // Collect all cluster members
              const clusterMembers = [entry];
              let j = i + 1;
              while (j < entries.length && entries[j].clusterSource === entry.clusterSource) {
                clusterMembers.push(entries[j]);
                j++;
              }
              
              // Generate unique ID for this cluster group
              const clusterId = `cluster-${entry.clusterSource}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              
              // Build cluster orthography string for aria-label
              const clusterOrthography = clusterMembers.map(m => m.char).join('');
              
              // Render cluster group with two-layer architecture (v5.11.31)
              // Per Kimi: rubric always visible, details accordion below
              const syllableAttr = syllableStart ? ' data-syllable-start="true"' : '';
              html += `
                <div class="cluster-group" id="${clusterId}"${syllableAttr}
                     role="group"
                     aria-label="Consonant cluster: ${clusterOrthography}"
                     aria-expanded="false"
                     data-cluster-ipa="${entry.ipa}"
                     data-cluster-source="${entry.clusterSource}">
                  <div class="cluster-perimeter" 
                       tabindex="0" 
                       role="button"
                       aria-label="Show details for ${clusterOrthography} cluster"></div>
                  ${clusterMembers.map(m => `
                    <div class="phoneme-row cluster-member"
                         data-cluster-id="${clusterId}">
                      <div class="phoneme-mapping">
                        <span class="phoneme-cyr">${m.char}</span>
                        <span class="phoneme-arrow">›</span>
                        <span class="phoneme-ipa">${entry.ipa}</span>
                      </div>
                    </div>
                  `).join('')}
                  <div class="cluster-overlay-container">
                    <div class="cluster-rubric-row">
                      <div class="cluster-connector"></div>
                      <div class="cluster-rubric" role="button" tabindex="0">
                        <span class="cluster-formula-ortho">${clusterOrthography}</span>
                        <span class="cluster-formula-arrow">→</span>
                        <span class="cluster-formula-ipa">/${entry.ipa}/</span>
                      </div>
                    </div>
                    <div class="cluster-details">
                      <div class="cluster-details-content">
                        <div class="cluster-blurb-text">${extractBlurbText(blurb)}</div>
                        ${blurb.citation ? `<div class="cluster-blurb-citation">${blurb.citation}</div>` : ''}
                      </div>
                    </div>
                  </div>
                </div>
              `;
              
              // Skip past all cluster members
              i = j;
              continue;
            }
            
            // Regular entry (non-cluster)
            let rowClasses = 'phoneme-row';
            if (isSilent) rowClasses += ' silent-letter';
            
            const syllableAttr = syllableStart ? ' data-syllable-start="true"' : '';
            const ipaDisplay = isSilent ? '[silent]' : (entry.ipa || '∅');
            
            html += `
              <div class="${rowClasses}"${syllableAttr}
                   tabindex="0"
                   role="button"
                   aria-expanded="false"
                   aria-label="${entry.char} becomes ${entry.ipa || 'nothing'}">
                <div class="phoneme-mapping">
                  <span class="phoneme-cyr">${entry.char}</span>
                  <span class="phoneme-arrow">›</span>
                  <span class="phoneme-ipa">${ipaDisplay}</span>
                </div>
                <div class="phoneme-blurb-overlay">
                  <div class="blurb-text">${extractBlurbText(blurb)}</div>
                  ${blurb.citation ? `<div class="blurb-citation">${blurb.citation}</div>` : ''}
                </div>
              </div>
            `;
            
            i++;
          }
          
          if (isStressed) {
            html += `</div>`;
          }
          
          isFirstSyllable = false;
        });
        
        // Clitic arrow at END of ribbon (v6.0.17 - replaces tie bar)
        // Proclitic: → points forward to host
        // Enclitic: ← points backward to host
        if (isProclitic) {
          html += `
            <div class="phoneme-row clitic-arrow-row" 
                 tabindex="0"
                 role="button"
                 aria-expanded="false"
                 aria-label="Proclitic - this word attaches to the next">
              <div class="phoneme-mapping">
                <span class="arrow-symbol">→</span>
                <span class="arrow-label">proclitic</span>
              </div>
              <div class="phoneme-blurb-overlay">
                <div class="blurb-text">${procliticBlurb}</div>
                <div class="blurb-citation">${procliticCitation}</div>
              </div>
            </div>
          `;
        }
        
        if (isEnclitic) {
          html += `
            <div class="phoneme-row clitic-arrow-row" 
                 tabindex="0"
                 role="button"
                 aria-expanded="false"
                 aria-label="Enclitic - this word attaches to the previous">
              <div class="phoneme-mapping">
                <span class="arrow-symbol">←</span>
                <span class="arrow-label">enclitic</span>
              </div>
              <div class="phoneme-blurb-overlay">
                <div class="blurb-text">${encliticBlurb}</div>
                <div class="blurb-citation">${encliticCitation}</div>
              </div>
            </div>
          `;
        }
        
        // Add backdrop at end (positioned via CSS)
        html += `<div class="ribbon-backdrop"></div>`;
        
        container.innerHTML = html;
        
        // Event delegation for floating overlay (v5.5)
        // Updated v5.11.31: Universal click-outside dismiss, cluster rubric always visible
        // Only attach once per container to avoid stacking handlers
        if (!container._ribbonListenerAttached) {
          container._ribbonListenerAttached = true;
          
          container.addEventListener('click', (e) => {
            const row = e.target.closest('.phoneme-row:not(.cluster-member)');
            const clusterGroup = e.target.closest('.cluster-group');
            const clusterPerimeter = e.target.closest('.cluster-perimeter');
            const clusterRubric = e.target.closest('.cluster-rubric');
            const clusterDetails = e.target.closest('.cluster-details');
            const phonemeBlurb = e.target.closest('.phoneme-blurb-overlay');
            const backdrop = container.querySelector('.ribbon-backdrop');
            
            // UNIVERSAL DISMISS: Close any expanded blurb if clicking outside its content
            const activeRow = container.querySelector('.phoneme-row.expanded');
            const activeCluster = container.querySelector('.cluster-group.active');
            
            // If clicking inside an open phoneme blurb, do nothing (let user read)
            if (phonemeBlurb && activeRow) {
              return;
            }
            
            // If clicking inside cluster details, do nothing (let user read)
            if (clusterDetails && activeCluster) {
              return;
            }
            
            // Close active phoneme blurb if clicking anywhere else
            if (activeRow && !row?.classList.contains('expanded')) {
              activeRow.classList.remove('expanded');
              activeRow.setAttribute('aria-expanded', 'false');
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            }
            
            // Close active cluster if clicking outside the cluster region entirely
            if (activeCluster && !clusterGroup) {
              activeCluster.classList.remove('active');
              activeCluster.setAttribute('aria-expanded', 'false');
            }
            
            // Handle cluster clicks (perimeter, rubric, or connector area)
            if (clusterGroup && (clusterPerimeter || clusterRubric)) {
              e.stopPropagation();
              
              const wasActive = clusterGroup.classList.contains('active');
              
              // Close any other active cluster
              container.querySelectorAll('.cluster-group.active').forEach(c => {
                if (c !== clusterGroup) {
                  c.classList.remove('active');
                  c.setAttribute('aria-expanded', 'false');
                }
              });
              
              // Toggle clicked cluster group
              if (wasActive) {
                clusterGroup.classList.remove('active');
                clusterGroup.setAttribute('aria-expanded', 'false');
              } else {
                clusterGroup.classList.add('active');
                clusterGroup.setAttribute('aria-expanded', 'true');
              }
              return;
            }
            
            // Handle regular row clicks
            if (!row) return;
            
            // Dismiss toast on phoneme interaction (v5.11.47 lifecycle)
            DrawerState.hideYoToast();
            
            e.stopPropagation();
            const wasExpanded = row.classList.contains('expanded');
            
            // Toggle clicked row
            if (wasExpanded) {
              row.classList.remove('expanded');
              row.setAttribute('aria-expanded', 'false');
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            } else {
              row.classList.add('expanded');
              row.setAttribute('aria-expanded', 'true');
              container.classList.add('has-active-blurb');
              backdrop?.classList.add('active');
            }
          });
          
          // Keyboard accessibility (cluster perimeter/rubric + regular rows)
          container.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              const row = e.target.closest('.phoneme-row:not(.cluster-member)');
              const perimeter = e.target.closest('.cluster-perimeter');
              const rubric = e.target.closest('.cluster-rubric');
              
              if (perimeter || rubric) {
                e.preventDefault();
                (perimeter || rubric).click();
              } else if (row) {
                e.preventDefault();
                row.click();
              }
            }
            // Escape to close
            if (e.key === 'Escape') {
              const backdrop = container.querySelector('.ribbon-backdrop');
              container.querySelectorAll('.phoneme-row.expanded, .cluster-group.active').forEach(r => {
                r.classList.remove('expanded');
                r.classList.remove('active');
                r.setAttribute('aria-expanded', 'false');
              });
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            }
            
            // Phase 4D: Arrow key navigation through ribbon rows
            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
              const focusableRows = [...container.querySelectorAll('.phoneme-row:not(.cluster-member), .cluster-group, .clitic-arrow-row')];
              const currentIdx = focusableRows.findIndex(row => row.contains(e.target) || row === e.target);
              
              if (currentIdx === -1) return;
              
              e.preventDefault();
              let nextIdx;
              if (e.key === 'ArrowDown') {
                nextIdx = Math.min(currentIdx + 1, focusableRows.length - 1);
              } else {
                nextIdx = Math.max(currentIdx - 1, 0);
              }
              
              const nextRow = focusableRows[nextIdx];
              if (nextRow) {
                // For cluster groups, focus the perimeter or rubric
                const focusTarget = nextRow.querySelector('.cluster-perimeter, .cluster-rubric') || nextRow;
                focusTarget.focus();
                // Scroll into view if needed
                focusTarget.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
              }
            }
          });
        }
      },

      /**
       * Recalculate syllable indices for ribbon entries based on boundary adjustments (v5.10.25)
       * Maps each log entry to its new display syllable based on IPA token positions
       */
      recalculateSyllableIndices(displayLog, originalSyllables, displaySyllables) {
        // Build mapping: cumulative IPA token position → new syllable index
        // First, calculate original token ranges for each syllable
        const originalRanges = [];
        let tokenOffset = 0;
        originalSyllables.forEach((syl, sylIdx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          originalRanges.push({
            start: tokenOffset,
            end: tokenOffset + tokens.length,
            sylIdx
          });
          tokenOffset += tokens.length;
        });
        
        // Calculate display token ranges
        const displayRanges = [];
        let displayOffset = 0;
        displaySyllables.forEach((syl, sylIdx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          displayRanges.push({
            start: displayOffset,
            end: displayOffset + tokens.length,
            sylIdx
          });
          displayOffset += tokens.length;
        });
        
        // For each log entry, find which display syllable its IPA token(s) now fall into
        // Track cumulative token position as we iterate through entries
        let cumulativeTokenPos = 0;
        const adjustedLog = displayLog.map(entry => {
          const entryTokens = IpaTokenizer.tokenize(entry.ipa || '');
          const entryTokenCount = Math.max(1, entryTokens.length); // At least 1 for positioning
          
          // Find which display syllable contains this token position
          let newSylIdx = entry.syllableIndex ?? 0;
          for (const range of displayRanges) {
            if (cumulativeTokenPos >= range.start && cumulativeTokenPos < range.end) {
              newSylIdx = range.sylIdx;
              break;
            }
          }
          
          // Advance cumulative position
          cumulativeTokenPos += entryTokenCount;
          
          return {
            ...entry,
            adjustedSyllableIndex: newSylIdx
          };
        });
        
        return adjustedLog;
      },
    };

    /* DRAWER STATE MACHINE (v6.0) — Manages left-side drawer open/close and — Root/Drill internal state transitions. */
    const DrawerState = {
      drawer: null,
      scrim: null,
      previousFocus: null,
      currentWord: null,  // Stores selected word data for Drill state (Phase 3)
      
      // Element references for inspector
      inspectorElements: {},
      
      // Phase 4B: Drag handling state for syllable boundary editing
      _dragState: null,
      _ghostElement: null,
      _animationInProgress: false,

      // ═══════════════════════════════════════════
      // METHOD INDEX
      // ═══════════════════════════════════════════
      // DRAWER MECHANICS: init, get isOpen, get mode, open, close, switchMode
      // INSPECTOR POPULATION: updateInspector, populateControls, _extractPhonemeList
      // WORD MORPHING: _morphToNewWord, _highlightChangedPhonemes
      // STRESS CONTROLS: handleStressChange, handleStressSourceSelect, showAttributionArrow, hideAttributionArrow
      // Ё CONTROLS: handleVariantToggle, stageVariantToggle, cancelVariantToggle, applyVariantToggle, showYoLockMessage, hideYoLockMessage, showYoToast, hideYoToast, undoYoToggle
      // BOUNDARY CONTROLS: handleAssimilationToggle, _setupDragHandlers, _attemptConsonantShed, _animateConsonantGhost, _flashInvalid, _cleanupGhost, _updateSyllableDisplay, _updateCustomizedState, _pulseAllConsonants
      // REFRESH: refreshAfterChange
      // NAVIGATION: _focusFirstElement
      // SETUP: _setupSwipeToDismiss, _setupViewportListener
      // ═══════════════════════════════════════════

      // --- DRAWER MECHANICS ---

      init() {
        this.drawer = document.getElementById('ilyaDrawer');
        this.scrim = document.getElementById('drawerScrim');
        this.layout = document.querySelector('.ilya-layout');
        
        // Cache inspector elements (Phase 3B)
        this.inspectorElements = {
          backBtn: document.getElementById('drawerBackBtn'),
          wordDisplay: document.getElementById('inspectorWordDisplay'),
          syllableLabel: document.getElementById('inspectorSyllableLabel'),
          syllableHeader: document.getElementById('inspectorSyllableHeader'),
          syllableDisplay: document.getElementById('inspectorSyllableDisplay'),
          boundaryResetBtn: document.getElementById('inspectorBoundaryResetBtn'),
          cyrillic: document.getElementById('inspectorCyrillic'),
          glossInline: document.getElementById('inspectorGlossInline'),
          ribbonSection: document.getElementById('inspectorRibbonSection'),
          ribbon: document.getElementById('inspectorRibbon'),
          controls: document.getElementById('inspectorControls'),
          // Phase 3D: Control modules
          variantRow: document.getElementById('inspectorVariantRow'),
          variantLabel: document.getElementById('inspectorVariantLabel'),
          variantYo: document.getElementById('inspectorVariantYo'),
          variantYe: document.getElementById('inspectorVariantYe'),
          variantConfirm: document.getElementById('inspectorVariantConfirm'),
          variantCancel: document.getElementById('inspectorVariantCancel'),
          variantApply: document.getElementById('inspectorVariantApply'),
          assimilationRow: document.getElementById('inspectorAssimilationRow'),
          boundaryLabel: document.getElementById('inspectorBoundaryLabel'),
          assimilationLinked: document.getElementById('inspectorAssimilationLinked'),
          assimilationSeparated: document.getElementById('inspectorAssimilationSeparated'),
          stressSourceRow: document.getElementById('inspectorStressSourceRow'),
          stressSourceButtons: document.getElementById('inspectorStressSourceButtons'),
          stressDictionary: document.getElementById('inspectorStressDictionary'),
          stressComposer: document.getElementById('inspectorStressComposer'),
          stressUser: document.getElementById('inspectorStressUser'),
          stressAttributionArrow: document.getElementById('stressAttributionArrow'),
          yoToast: document.getElementById('inspectorYoToast'),
          yoToastText: document.getElementById('inspectorYoToastText'),
          yoUndoBtn: document.getElementById('inspectorYoUndoBtn'),
          yoOkBtn: document.getElementById('inspectorYoOkBtn'),
          yoLockMessage: document.getElementById('inspectorYoLockMessage')
        };
        
        // Back button returns to Root (with stopPropagation)
        this.inspectorElements.backBtn?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.switchMode('root');
        });
        
        // Gloss editing (save on blur)
        this.inspectorElements.glossInline?.addEventListener('blur', () => {
          if (this.currentWord) {
            const newGloss = this.inspectorElements.glossInline.textContent.trim();
            DocumentState.updateGloss(this.currentWord.lineIndex, this.currentWord.wordIndex, newGloss);
            PaperRenderer.render();
          }
        });
        
        // Prevent gloss click from propagating (keeps focus for editing)
        this.inspectorElements.glossInline?.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        // Phase 3D: Control event handlers
        // Variant toggle (ё/е) - stages change, shows confirmation
        this.inspectorElements.variantYo?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.stageVariantToggle('yo');
        });
        this.inspectorElements.variantYe?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.stageVariantToggle('ye');
        });
        
        // Variant confirmation actions
        this.inspectorElements.variantCancel?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.cancelVariantToggle();
        });
        this.inspectorElements.variantApply?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.applyVariantToggle();
        });
        
        // Assimilation toggle (Linked/Separated)
        this.inspectorElements.assimilationLinked?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleAssimilationToggle('soft');
        });
        this.inspectorElements.assimilationSeparated?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleAssimilationToggle('hard');
        });
        
        // Stress source selection (event delegation on parent)
        this.inspectorElements.stressSourceButtons?.addEventListener('click', (e) => {
          const segment = e.target.closest('.segment[data-source]');
          if (!segment) return;
          e.stopPropagation();
          this.handleStressSourceSelect(segment.dataset.source);
        });
        
        // Toast undo button
        this.inspectorElements.yoUndoBtn?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.undoYoToggle();
        });
        
        this.inspectorElements.yoOkBtn?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.inspectorElements.yoToast?.classList.remove('visible');
          this._yoStateBeforeToggle = null;
        });
        
        // Phase 4B: Set up syllable boundary drag handlers
        this._setupDragHandlers();
        
        // Phase 5C: Set up swipe-to-dismiss for mobile bottom sheet
        this._setupSwipeToDismiss();
        
        // Phase 5C: Viewport resize state synchronization
        this._setupViewportListener();
      },

      get isOpen() {
        return this.drawer?.dataset.state === 'open';
      },

      get mode() {
        return this.drawer?.dataset.mode || 'root';
      },

      open(mode = 'root', wordData = null) {
        if (!this.drawer) return;
        this.previousFocus = document.activeElement;
        this.drawer.dataset.state = 'open';
        this.drawer.dataset.mode = mode;
        this.layout?.classList.add('drawer-open');
        
        // If opening in inspect mode with word data, update the inspector
        if (mode === 'inspect' && wordData) {
          this.currentWord = wordData;
          this.updateInspector();
        }
        
        // Phase 4C: Focus first interactive element after transition
        setTimeout(() => {
          this._focusFirstElement(mode);
        }, 310); // After 300ms drawer animation
      },

      close() {
        if (!this.drawer) return;
        this.drawer.dataset.state = 'closed';
        this.layout?.classList.remove('drawer-open');
        this.hideAttributionArrow();
        // Return focus to triggering element
        this.previousFocus?.focus();
        this.previousFocus = null;
      },

      switchMode(mode, wordData = null) {
        if (!this.drawer) return;
        
        // Phase 4A: Detect word-to-word transition (already in inspect → new word)
        const isWordToWord = this.mode === 'inspect' && mode === 'inspect' && wordData;
        
        if (isWordToWord) {
          // Store previous phonemes for comparison
          this._previousPhonemes = this._extractPhonemeList(this.currentWord);
          
          // Trigger morph animation
          this._morphToNewWord(wordData);
        } else {
          // Standard mode switch (no morph needed)
          this.drawer.dataset.mode = mode;
          
          // Hide attribution arrow when leaving Drill
          if (mode === 'root') {
            this.hideAttributionArrow();
          }
          
          if (mode === 'inspect' && wordData) {
            this.currentWord = wordData;
            this._previousPhonemes = null; // No comparison for fresh inspection
            this.updateInspector();
          }
          
          // Phase 4C: Focus appropriate element after mode transition
          setTimeout(() => {
            this._focusFirstElement(mode);
          }, 210); // After 200ms internal transition
        }
      },
      
      // Phase 4A: Extract phoneme list from word data for comparison

      // --- INSPECTOR POPULATION ---

      updateInspector() {
        if (!this.currentWord) return;
        
        // Clear pending attribution from previous word
        this.hideAttributionArrow();
        
        // Sync Drill language pill to currentGlossLanguage (v6.0.51)
        const drillPill = document.getElementById('drillLangPill');
        if (drillPill) {
          drillPill.dataset.lang = currentGlossLanguage;
          drillPill.querySelectorAll('.lang-option').forEach(opt => {
            const isActive = opt.dataset.lang === currentGlossLanguage;
            opt.classList.toggle('active', isActive);
            opt.setAttribute('aria-checked', isActive);
          });
        }
        
        const { cyrillic, ipa, gloss, syllables, isProclitic, isEnclitic, hasYo, wordId } = this.currentWord;
        const syllableCount = syllables?.length || 0;
        const isClitic = isProclitic === 'true' || isEnclitic === 'true';
        const hasYoFlag = hasYo === 'true' || hasYo === true;
        
        // Header: Word display with stress
        const syllabifiedCyrillic = syllables?.map(s => 
          s.isStressed ? addAcuteToSyllable(s.cyrillic) : s.cyrillic
        ).join(' ') || cyrillic;
        
        if (this.inspectorElements.wordDisplay) {
          this.inspectorElements.wordDisplay.textContent = syllabifiedCyrillic;
        }
        
        // Syllable Label (monosyllable/clitic context)
        if (this.inspectorElements.syllableLabel) {
          if (syllableCount === 1) {
            const hasStress = syllables?.some(s => s.isStressed);
            const lang = currentGlossLanguage || 'en';
            if (isClitic) {
              this.inspectorElements.syllableLabel.textContent = UI_LABELS['inspector.clitic'][lang];
            } else if (hasStress) {
              this.inspectorElements.syllableLabel.textContent = UI_LABELS['inspector.stressedMono'][lang];
            } else {
              this.inspectorElements.syllableLabel.textContent = UI_LABELS['inspector.unstressedMono'][lang];
            }
          } else {
            this.inspectorElements.syllableLabel.textContent = '';
          }
        }
        
        // Syllable Buttons (interactive IPA)
        if (this.inspectorElements.syllableDisplay) {
          // Apply boundary offsets if customized
          const displaySyllables = typeof BoundaryStack !== 'undefined' && wordId
            ? BoundaryStack.applyOffsets(wordId, syllables)
            : syllables;
          
          // ё locks stress — handled in updateStress/handleStressChange guards
          
          this.inspectorElements.syllableDisplay.innerHTML = displaySyllables?.map((syl, idx) => 
            `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''}" 
                     data-syllable-index="${idx}">
              ${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}
            </button>`
          ).join('') || '';
          
          // Wire up syllable button clicks for stress reassignment
          this.inspectorElements.syllableDisplay.querySelectorAll('.syllable-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();  // Prevent drawer from closing
              if (btn.disabled) return;
              const newStressIdx = parseInt(btn.dataset.syllableIndex, 10);
              this.handleStressChange(newStressIdx);
            });
          });
        }
        
        // Cyrillic Display
        if (this.inspectorElements.cyrillic) {
          this.inspectorElements.cyrillic.textContent = syllabifiedCyrillic;
        }
        
        // Gloss (editable)
        if (this.inspectorElements.glossInline) {
          this.inspectorElements.glossInline.textContent = gloss || '';
        }
        
          if (this.inspectorElements.ribbon) {
          RibbonRenderer.renderRibbon(this.currentWord, this.inspectorElements.ribbon);
        }
        
        // Phase 4A: Reset scroll to top on every word selection
        const inspectorBody = document.querySelector('.drawer-inspector .inspector-body');
        if (inspectorBody) {
          inspectorBody.scrollTop = 0;
        }
        
          this.populateControls();
      },
      

      populateControls() {
        if (!this.currentWord) return;
        
        const { cyrillic, syllables, lineIndex, wordIndex, rightBoundary, boundarySource, stressSource } = this.currentWord;
        const syllableCount = syllables?.length || 1;
        const hasYo = cyrillic?.includes('ё') || cyrillic?.includes('Ё');
        const hasYe = cyrillic?.includes('е') || cyrillic?.includes('Е');
        
        // 1. Variant row (ё/е toggle)
        if (!hasYo && !hasYe) {
          this.inspectorElements.variantRow.style.display = 'none';
        } else {
          this.inspectorElements.variantRow.style.display = 'flex';
          
          // Contextual label: "Restore ё:" when showing е, "Restore е:" when showing ё
          if (this.inspectorElements.variantLabel) {
            this.inspectorElements.variantLabel.textContent = hasYo ? 'Restore е:' : 'Restore ё:';
          }
          
          this.inspectorElements.variantYo?.classList.toggle('active', hasYo);
          this.inspectorElements.variantYo?.classList.remove('staged');
          this.inspectorElements.variantYe?.classList.toggle('active', !hasYo && hasYe);
          this.inspectorElements.variantYe?.classList.remove('staged');
          
          // Hide confirmation row
          this.inspectorElements.variantConfirm?.classList.remove('visible');
          this._stagedVariant = null;
          
          // Store state for undo (only if toast is not showing -- preserve undo target)
          const toastVisible = this.inspectorElements.yoToast?.classList.contains('visible');
          if (!toastVisible) {
            this._yoStateBeforeToggle = hasYo ? 'yo' : 'ye';
          }
        }
        
        // 2. Assimilation row (word boundary control)
        const line = DocumentState.lines[lineIndex];
        const isLastWordInLine = wordIndex >= (line?.length || 1) - 1;
        
        if (isLastWordInLine) {
          this.inspectorElements.assimilationRow.style.display = 'none';
        } else {
          this.inspectorElements.assimilationRow.style.display = 'flex';
          
          // Build bespoke label: "Break between [x] and [y]?"
          const currentWordCyrillic = cyrillic || '—';
          const nextWord = line[wordIndex + 1];
          const nextWordCyrillic = nextWord?.cyrillic || nextWord?.originalInput || '—';
          if (this.inspectorElements.boundaryLabel) {
            const lang = currentGlossLanguage || 'en';
            const template = UI_LABELS['inspector.boundaryLabel'][lang];
            const parts = template.split('[—]');
            this.inspectorElements.boundaryLabel.textContent = parts[0] + '[' + currentWordCyrillic + ']' + parts[1] + '[' + nextWordCyrillic + ']' + parts[2];
          }
          
          // Set active state based on current boundary (No = soft, Yes = hard)
          const currentBoundary = rightBoundary || 'soft';
          this.inspectorElements.assimilationLinked?.classList.toggle('active', currentBoundary === 'soft');
          this.inspectorElements.assimilationSeparated?.classList.toggle('active', currentBoundary === 'hard');
          
          // Disable if punctuation-forced
          if (boundarySource === 'punctuation') {
            this.inspectorElements.assimilationRow.classList.add('disabled');
          } else {
            this.inspectorElements.assimilationRow.classList.remove('disabled');
          }
        }
        
        // 3. Stress source module
        // Hide when stress is locked (monosyllable or ё)
        const stressLocked = syllableCount === 1 || hasYo;
        this.inspectorElements.stressSourceRow?.classList.toggle('hidden', stressLocked);
        
        if (!stressLocked) {
          const currentSource = stressSource || 'dictionary';
          this.inspectorElements.stressDictionary?.classList.toggle('active', currentSource === 'dictionary');
          this.inspectorElements.stressComposer?.classList.toggle('active', currentSource === 'composer');
          this.inspectorElements.stressComposer?.classList.toggle('committed', currentSource === 'composer');
          this.inspectorElements.stressUser?.classList.toggle('active', currentSource === 'user');
          this.inspectorElements.stressUser?.classList.toggle('committed', currentSource === 'user');
        }
        
        // Hide toast and lock message initially
        this.inspectorElements.yoToast?.classList.remove('visible');
        this.hideYoLockMessage();
        
        // Phase 4B: Initialize reset button visibility
        this._updateCustomizedState();
      },
      

      _extractPhonemeList(wordData) {
        if (!wordData?.transcriptionLog) return [];
        return wordData.transcriptionLog.map(entry => ({
          char: entry.char,
          ipa: entry.ipa || ''
        }));
      },
      
      // Phase 4A: Morph animation to new word (250ms total)

      // --- WORD MORPHING ---

      _morphToNewWord(wordData) {
        const inspectorBody = document.querySelector('.drawer-inspector .inspector-body');
        if (!inspectorBody) {
          // Fallback: update without animation
          this.currentWord = wordData;
          this.updateInspector();
          return;
        }
        
        // Phase 1: Fade out (125ms)
        inspectorBody.classList.add('morphing');
        inspectorBody.classList.remove('morph-in');
        
        setTimeout(() => {
          // Update content while invisible
          this.currentWord = wordData;
          this.updateInspector();
          
          // Phase 2: Fade in (125ms)
          inspectorBody.classList.remove('morphing');
          inspectorBody.classList.add('morph-in');
          
          // Apply sage highlights to changed phonemes
          this._highlightChangedPhonemes();
          
          // Clean up animation class after complete
          setTimeout(() => {
            inspectorBody.classList.remove('morph-in');
          }, 125);
        }, 125);
      },
      
      // Phase 4A: Compare phonemes and highlight changes

      _highlightChangedPhonemes() {
        if (!this._previousPhonemes || !this.currentWord?.transcriptionLog) return;
        
        const currentPhonemes = this._extractPhonemeList(this.currentWord);
        const ribbonContainer = this.inspectorElements.ribbon;
        if (!ribbonContainer) return;
        
        // Get all phoneme rows and cluster groups
        const rows = ribbonContainer.querySelectorAll('.phoneme-row:not(.clitic-arrow-row), .cluster-group');
        
        rows.forEach((row, idx) => {
          const current = currentPhonemes[idx];
          const previous = this._previousPhonemes[idx];
          
          // Highlight if phoneme is new, different char, or different IPA
          const isChanged = !previous || 
                           (current && (current.char !== previous.char || current.ipa !== previous.ipa));
          
          if (isChanged) {
            row.classList.add('phoneme-changed');
            // Remove highlight class after animation completes
            setTimeout(() => {
              row.classList.remove('phoneme-changed');
            }, 400);
          }
        });
        
        // Clear stored phonemes
        this._previousPhonemes = null;
      },
      // Update inspector display with current word (Phase 3B)
      // --- STRESS CONTROLS ---

      handleStressChange(newStressIdx) {
        if (!this.currentWord) return;
        
        // Block stress changes for ё words (ё always carries stress)
        const hasYo = this.currentWord.hasYo === 'true' || this.currentWord.hasYo === true ||
                      GraysonEngine.hasYo(this.currentWord.cyrillic);
        if (hasYo) {
          this.showYoLockMessage();
          return;
        }
        
        const { lineIndex, wordIndex, syllables } = this.currentWord;
        const currentStressIdx = syllables?.findIndex(s => s.isStressed) ?? -1;
        
        // No change needed
        if (newStressIdx === currentStressIdx) return;
        
        // Update DocumentState
        DocumentState.updateStress(lineIndex, wordIndex, newStressIdx);
        
        // Re-render paper
        PaperRenderer.render();
        
        // Find the updated word element and refresh inspector data
        const wordStack = document.querySelector(`.word-stack[data-line-index="${lineIndex}"][data-word-index="${wordIndex}"]`);
        if (wordStack) {
          this.currentWord = {
            ...this.currentWord,
            syllables: JSON.parse(wordStack.dataset.syllables || '[]'),
            ipa: wordStack.dataset.ipa
          };
          this.updateInspector();
        }
        
        // Prompt for attribution (scholarly act)
        this.showAttributionArrow();
      },
      
      handleStressSourceSelect(source) {
        if (!this.currentWord) return;
        
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        if (!word) return;
        
        const currentSource = word.stressSource || 'dictionary';
        const arrowVisible = this.inspectorElements.stressAttributionArrow?.classList.contains('visible');
        
        // If clicking current state and no attribution pending, do nothing
        if (source === currentSource && !arrowVisible) return;
        
        // Update stress source
        word.stressSource = source;
        this.currentWord.stressSource = source;
        
        // Update UI
        this.inspectorElements.stressDictionary?.classList.remove('active', 'committed');
        this.inspectorElements.stressComposer?.classList.remove('active', 'committed');
        this.inspectorElements.stressUser?.classList.remove('active', 'committed');
        
        const targetBtn = source === 'dictionary' ? this.inspectorElements.stressDictionary
                        : source === 'composer' ? this.inspectorElements.stressComposer
                        : this.inspectorElements.stressUser;
        
        if (targetBtn) {
          targetBtn.classList.add('active');
          if (source !== 'dictionary') {
            targetBtn.classList.add('committed');
          }
        }
        
        // Re-render paper
        PaperRenderer.render();
        
        // Attribution fulfilled
        this.hideAttributionArrow();
      },
      
      // Attribution arrow: expand row and show the fixed overlay

      showAttributionArrow() {
        const arrow = this.inspectorElements.stressAttributionArrow;
        const row = this.inspectorElements.stressSourceRow;
        const buttons = this.inspectorElements.stressSourceButtons;
        if (!arrow || !row) return;
        
        // Expand the row first
        row.classList.add('expanded');
        
        // Position arrow after layout settles
        requestAnimationFrame(() => {
          const target = buttons || row;
          const targetRect = target.getBoundingClientRect();
          const drawer = document.getElementById('ilyaDrawer');
          const drawerRight = drawer ? drawer.getBoundingClientRect().right : 360;
          
          // Position: straddle the drawer edge, tip aligned with button row midpoint
          arrow.style.left = (drawerRight - 20) + 'px';
          arrow.style.top = (targetRect.top + targetRect.height / 2 - 38) + 'px';
          
          // Restart animation
          arrow.classList.remove('visible');
          void arrow.offsetWidth;
          arrow.classList.add('visible');
        });
      },
      
      hideAttributionArrow() {
        const arrow = this.inspectorElements.stressAttributionArrow;
        if (arrow) arrow.classList.remove('visible');
        // Collapse the row
        this.inspectorElements.stressSourceRow?.classList.remove('expanded');
      },
      
      // Show ё lock feedback message (auto-dismiss after 2s)

      // --- Ё CONTROLS ---

      handleVariantToggle(variant, skipToast) {
        if (!this.currentWord) return;
        
        const { lineIndex, wordIndex, cyrillic } = this.currentWord;
        const word = DocumentState.lines[lineIndex]?.[wordIndex];
        if (!word) return;
        
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const currentVariant = hasYo ? 'yo' : 'ye';
        
        // If clicking current state, do nothing
        if (variant === currentVariant) return;
        
        // Store for undo
        this._yoStateBeforeToggle = currentVariant;
        
        // Determine direction for toast text
        const direction = hasYo ? 'yo-to-ye' : 'ye-to-yo';
        
        // Respell the word
        let newCyrillic;
        let newYoSource;
        
        if (hasYo) {
          // Currently has ё — remove it (revert to original or convert ё→е)
          if (word.originalInput) {
            newCyrillic = word.originalInput;
          } else {
            newCyrillic = cyrillic.replace(/ё/, 'е').replace(/Ё/, 'Е');
          }
          newYoSource = 'user-yo-edit';
        } else if (word.dictionaryForm) {
          // Has е, dictionary form available — restore ё
          newCyrillic = word.dictionaryForm;
          newYoSource = 'yo-restored';
        } else {
          // Has е, no dictionary — add ё to first е
          newCyrillic = cyrillic.replace(/е/, 'ё').replace(/Е/, 'Ё');
          newYoSource = 'user-yo-edit';
        }
        
        // Update DocumentState
        word.cyrillic = newCyrillic;
        word.yoSource = newYoSource;
        
        // Check if new form has ё (for stress locking)
        const newHasYo = newCyrillic.includes('ё') || newCyrillic.includes('Ё');
        word.hasYo = newHasYo;
        
        // Re-run stress assignment
        if (newHasYo) {
          const yoSyllable = GraysonEngine.findYoSyllable(newCyrillic);
          if (yoSyllable !== -1) {
            word.stress = yoSyllable;
            word.stressSource = newYoSource;
          }
        } else {
          const lookup = GraysonEngine.lookupStress(newCyrillic);
          if (lookup) {
            word.stress = lookup.stress;
            word.stressSource = lookup.source;
          } else {
            word.stress = 0;
            word.stressSource = 'default';
          }
        }
        
        // Refresh inspector and paper
        // Save undo target -- updateInspector() would overwrite it
        const undoTarget = currentVariant;
        this.refreshAfterChange();
        this._yoStateBeforeToggle = undoTarget;
        
        // Show toast with direction (unless suppressed by undo)
        if (!skipToast) {
          this.showYoToast(direction);
        }
      },
      

      stageVariantToggle(variant) {
        if (!this.currentWord) return;
        
        const cyrillic = this.currentWord.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const currentVariant = hasYo ? 'yo' : 'ye';
        
        // If clicking current state, do nothing
        if (variant === currentVariant) return;
        
        // Stage the change
        this._stagedVariant = variant;
        
        // Update button states: remove active, add staged to target
        this.inspectorElements.variantYo?.classList.remove('active', 'staged');
        this.inspectorElements.variantYe?.classList.remove('active', 'staged');
        
        if (variant === 'yo') {
          this.inspectorElements.variantYo?.classList.add('staged');
        } else {
          this.inspectorElements.variantYe?.classList.add('staged');
        }
        
        // Show confirmation row
        this.inspectorElements.variantConfirm?.classList.add('visible');
      },
      

      cancelVariantToggle() {
        // Restore button states
        const cyrillic = this.currentWord?.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        
        this.inspectorElements.variantYo?.classList.remove('staged');
        this.inspectorElements.variantYe?.classList.remove('staged');
        this.inspectorElements.variantYo?.classList.toggle('active', hasYo);
        this.inspectorElements.variantYe?.classList.toggle('active', !hasYo);
        
        // Hide confirmation row
        this.inspectorElements.variantConfirm?.classList.remove('visible');
        this._stagedVariant = null;
      },
      

      applyVariantToggle() {
        if (!this._stagedVariant || !this.currentWord) return;
        
        const variant = this._stagedVariant;
        
        // Hide confirmation row first
        this.inspectorElements.variantConfirm?.classList.remove('visible');
        
        // Execute the toggle
        this.handleVariantToggle(variant);
        
        this._stagedVariant = null;
      },
      

      showYoLockMessage() {
        const el = this.inspectorElements.yoLockMessage;
        if (!el) return;
        
        el.classList.add('visible');
        
        clearTimeout(this._yoLockTimer);
        this._yoLockTimer = setTimeout(() => {
          el.classList.remove('visible');
        }, 2000);
      },
      
      hideYoLockMessage() {
        this.inspectorElements.yoLockMessage?.classList.remove('visible');
        clearTimeout(this._yoLockTimer);
      },
      

      showYoToast(direction) {
        // Update toast text based on direction
        if (this.inspectorElements.yoToastText) {
          const lang = currentGlossLanguage || 'en';
          const key = direction === 'yo-to-ye' ? 'inspector.yoToastYoToYe' : 'inspector.yoToastYeToYo';
          this.inspectorElements.yoToastText.textContent = UI_LABELS[key]?.[lang] ||
            (direction === 'yo-to-ye' ? 'ё → е changes pronunciation' : 'е → ё changes pronunciation');
        }
        
        this.inspectorElements.yoToast?.classList.add('visible');
      },
      

      hideYoToast() {
        this.inspectorElements.yoToast?.classList.remove('visible');
      },
      

      undoYoToggle() {
        if (!this._yoStateBeforeToggle) return;
        
        // Toggle back (suppress toast on undo)
        this.handleVariantToggle(this._yoStateBeforeToggle, true);
        
        // Hide toast
        this.inspectorElements.yoToast?.classList.remove('visible');
      },
      

      // --- BOUNDARY CONTROLS ---

      handleAssimilationToggle(boundary) {
        if (!this.currentWord) return;
        
        const currentBoundary = this.currentWord.rightBoundary || 'soft';
        
        // If clicking current state, do nothing
        if (boundary === currentBoundary) return;
        
        // Update the boundary directly
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        if (word) {
          word.rightBoundary = boundary;
          word.boundarySource = 'user';
          this.currentWord.rightBoundary = boundary;
          this.currentWord.boundarySource = 'user';
        }
        
        // Update UI
        this.inspectorElements.assimilationLinked?.classList.toggle('active', boundary === 'soft');
        this.inspectorElements.assimilationSeparated?.classList.toggle('active', boundary === 'hard');
        
        // Re-render paper
        PaperRenderer.render();
      },
      

      _setupDragHandlers() {
        const container = this.inspectorElements.syllableDisplay;
        if (!container) return;
        
        const CLICK_THRESHOLD = 10;   // px - absorbs normal jitter
        const DRAG_THRESHOLD = 40;    // px - committed horizontal drag
        
        const handlePointerDown = (e) => {
          const btn = e.target.closest('.syllable-btn');
          if (!btn || btn.disabled) return;
          
          // Only handle primary button (left click / single touch)
          if (e.button !== undefined && e.button !== 0) return;
          
          // Get pointer position (mouse or touch)
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          
          this._dragState = {
            startX: clientX,
            startY: clientY,
            syllableIdx: parseInt(btn.dataset.syllableIndex, 10),
            button: btn
          };
          
          // Prevent text selection during potential drag
          e.preventDefault();
        };
        
        const handlePointerMove = (e) => {
          if (!this._dragState) return;
          
          // Cursor feedback when exiting click zone
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const dx = Math.abs(clientX - this._dragState.startX);
          
          if (dx > CLICK_THRESHOLD) {
            this._dragState.button.style.cursor = 'grabbing';
          }
        };
        
        const handlePointerUp = (e) => {
          if (!this._dragState) return;
          
          const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
          const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
          
          const dx = clientX - this._dragState.startX;
          const dy = clientY - this._dragState.startY;
          const distance = Math.abs(dx);
          
          // Reset cursor
          this._dragState.button.style.cursor = '';
          
          if (distance < CLICK_THRESHOLD) {
            // CASE 1: Clean tap/click → reassign stress
            this.handleStressChange(this._dragState.syllableIdx);
          } 
          else if (distance >= DRAG_THRESHOLD && Math.abs(dy) < 20) {
            // CASE 2: Committed horizontal drag → shed consonant
            const direction = dx > 0 ? 'right' : 'left';
            this._attemptConsonantShed(this._dragState.syllableIdx, direction);
          }
          // CASE 3: Dead zone (10-40px) or vertical movement → silent cancel
          
          this._dragState = null;
        };
        
        // Mouse events
        container.addEventListener('mousedown', handlePointerDown);
        document.addEventListener('mousemove', handlePointerMove);
        document.addEventListener('mouseup', handlePointerUp);
        
        // Touch events (not passive because we preventDefault in pointerdown)
        container.addEventListener('touchstart', handlePointerDown, { passive: false });
        document.addEventListener('touchmove', handlePointerMove, { passive: true });
        document.addEventListener('touchend', handlePointerUp);
        
        // Phase 4D: Keyboard navigation for syllable buttons
        container.addEventListener('keydown', (e) => {
          const btn = e.target.closest('.syllable-btn');
          if (!btn) return;
          
          const buttons = [...container.querySelectorAll('.syllable-btn:not([disabled])')];
          const currentIdx = buttons.indexOf(btn);
          
          if (e.key === 'ArrowRight') {
            e.preventDefault();
            const nextIdx = Math.min(currentIdx + 1, buttons.length - 1);
            buttons[nextIdx]?.focus();
          } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            const prevIdx = Math.max(currentIdx - 1, 0);
            buttons[prevIdx]?.focus();
          } else if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            // Activate stress change (same as click)
            if (!btn.disabled) {
              const syllableIdx = parseInt(btn.dataset.syllableIndex, 10);
              this.handleStressChange(syllableIdx);
            }
          }
        });
      },
      
      /**
       * Attempt to shed a consonant from syllable in given direction
       * Uses BoundaryStack for display-only boundary adjustments
       */

      _attemptConsonantShed(syllableIdx, direction) {
        if (!this.currentWord) return;
        
        // Guard: prevent overlapping animations
        if (this._animationInProgress) return;
        
        const syllables = this.currentWord.syllables;
        const syllableCount = syllables.length;
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        
        // Clamp check: can't shed left from first syllable or right from last
        if (direction === 'left' && syllableIdx === 0) {
          this._flashInvalid(syllableIdx);
          return;
        }
        if (direction === 'right' && syllableIdx === syllableCount - 1) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // Get current syllable's tokens
        const displaySyllables = BoundaryStack.applyOffsets(wordId, syllables);
        const currentSyl = displaySyllables[syllableIdx];
        const tokens = IpaTokenizer.tokenize(currentSyl.ipa);
        const segments = IpaTokenizer.parseSegments(tokens);
        
        // Check if we can shed in this direction
        let canShed = false;
        let consonantToShed = null;
        
        if (direction === 'left') {
          // Shed leftmost onset consonant to previous syllable's coda
          if (segments.onset.length > 0) {
            canShed = true;
            consonantToShed = segments.onset[0].symbol;
          }
        } else {
          // Shed rightmost coda consonant to next syllable's onset
          if (segments.coda.length > 0) {
            canShed = true;
            consonantToShed = segments.coda[segments.coda.length - 1].symbol;
          }
        }
        
        if (!canShed) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // Get button positions for animation
        const sourceBtn = this.inspectorElements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        const targetIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx + 1;
        const targetBtn = this.inspectorElements.syllableDisplay.querySelector(`[data-syllable-index="${targetIdx}"]`);
        
        if (sourceBtn && targetBtn) {
          // Animate the ghost consonant
          this._animateConsonantGhost(consonantToShed, sourceBtn, targetBtn, direction, () => {
            // Shift the boundary after animation completes
            const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
            const shiftDir = direction === 'left' ? 'left' : 'right';
            BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
            
            // Update display (Cycle 4B-3)
            this._updateSyllableDisplay();
            this._updateCustomizedState();
          });
        } else {
          // Fallback: no animation, just update
          const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
          const shiftDir = direction === 'left' ? 'left' : 'right';
          BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
          this._updateSyllableDisplay();
          this._updateCustomizedState();
        }
      },
      
      /**
       * Animate a ghost consonant from source to target button
       */

      _animateConsonantGhost(consonant, sourceBtn, targetBtn, direction, onComplete) {
        // Set animation lock
        this._animationInProgress = true;
        
        // Get positions
        const sourceRect = sourceBtn.getBoundingClientRect();
        const targetRect = targetBtn.getBoundingClientRect();
        
        // Calculate start and end positions
        const startX = direction === 'left' 
          ? sourceRect.left 
          : sourceRect.right - 20;
        const startY = sourceRect.top + sourceRect.height / 2 - 15;
        
        const endX = direction === 'left'
          ? targetRect.right - 20
          : targetRect.left;
        const endY = targetRect.top + targetRect.height / 2 - 15;
        
        // Create ghost element
        const ghost = document.createElement('div');
        ghost.className = 'consonant-ghost';
        ghost.textContent = consonant;
        ghost.style.left = `${startX}px`;
        ghost.style.top = `${startY}px`;
        document.body.appendChild(ghost);
        this._ghostElement = ghost;
        
        // Dim the source button
        sourceBtn.classList.add('dragging');
        
        // Highlight target button
        targetBtn.classList.add('drag-target');
        
        // Trigger animation after a frame (to ensure initial position is set)
        requestAnimationFrame(() => {
          ghost.style.transition = 'left 0.25s ease-out, top 0.25s ease-out';
          ghost.style.left = `${endX}px`;
          ghost.style.top = `${endY}px`;
          ghost.classList.add('valid');
        });
        
        // Cleanup and callback after animation
        setTimeout(() => {
          sourceBtn.classList.remove('dragging');
          targetBtn.classList.remove('drag-target');
          this._cleanupGhost();
          this._animationInProgress = false;
          onComplete();
        }, 260);
      },
      
      /**
       * Flash invalid feedback on syllable button
       */

      _flashInvalid(syllableIdx) {
        const btn = this.inspectorElements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        if (btn) {
          btn.classList.add('drag-invalid');
          setTimeout(() => btn.classList.remove('drag-invalid'), 300);
        }
      },
      
      /**
       * Clean up ghost element
       */

      _cleanupGhost() {
        if (this._ghostElement) {
          this._ghostElement.remove();
          this._ghostElement = null;
        }
      },
      
      /**
       * Update syllable button display with boundary offsets applied
       * Also syncs the word stack IPA on the paper and re-renders the ribbon
       */

      _updateSyllableDisplay() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const originalSyllables = this.currentWord.syllables;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, originalSyllables);
        
        // Re-render buttons with display syllables
        const syllableCount = displaySyllables.length;
        
        this.inspectorElements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''}" 
                   data-syllable-index="${idx}">
            ${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}
          </button>`
        ).join('');
        
        // Sync word stack IPA in main document
        const wordStack = document.querySelector(
          `.word-stack[data-line-index="${this.currentWord.lineIndex}"][data-word-index="${this.currentWord.wordIndex}"]`
        );
        if (wordStack) {
          const ipaSpan = wordStack.querySelector('.ipa');
          if (ipaSpan) {
            // Build display IPA with stress marks and spaces
            let displayIPA = displaySyllables.map((syl, idx) => {
              return syl.isStressed && displaySyllables.length > 1 ? 'ˈ' + syl.ipa : syl.ipa;
            }).join(' ');
            
            // Preserve clitic tie bars
            const isProclitic = this.currentWord.isProclitic === 'true' || this.currentWord.isProclitic === true;
            const isEnclitic = this.currentWord.isEnclitic === 'true' || this.currentWord.isEnclitic === true;
            if (isProclitic) {
              displayIPA = displayIPA + '‿';
            } else if (isEnclitic) {
              displayIPA = '‿' + displayIPA;
            }
            
            ipaSpan.textContent = displayIPA;
          }
        }
        
        // Re-render ribbon with updated syllable groupings
        if (this.inspectorElements.ribbon) {
          RibbonRenderer.renderRibbon(this.currentWord, this.inspectorElements.ribbon);
        }
      },
      
      /**
       * Update customized state: show/hide reset button based on boundary modifications
       */

      _updateCustomizedState() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const hasCustom = BoundaryStack.hasCustomBoundaries(wordId);
        
        // Update header styling
        this.inspectorElements.syllableHeader?.classList.toggle('customized', hasCustom);
        
        // Show/hide the reset button
        if (this.inspectorElements.boundaryResetBtn) {
          this.inspectorElements.boundaryResetBtn.style.display = hasCustom ? 'inline-block' : 'none';
        }
        
        // Set up reset button click handler (only once)
        if (!this._resetBtnHandler && this.inspectorElements.boundaryResetBtn) {
          this._resetBtnHandler = (e) => {
            e.stopPropagation();
            if (!this.currentWord) return;
            const currentWordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
            if (BoundaryStack.hasCustomBoundaries(currentWordId)) {
              BoundaryStack.reset(currentWordId);
              this._updateSyllableDisplay();
              this._updateCustomizedState();
              this._pulseAllConsonants();
            }
          };
          this.inspectorElements.boundaryResetBtn.addEventListener('click', this._resetBtnHandler);
        }
      },
      
      /**
       * Pulse animation when resetting to default boundaries
       */

      _pulseAllConsonants() {
        const buttons = this.inspectorElements.syllableDisplay.querySelectorAll('.syllable-btn');
        buttons.forEach(btn => {
          btn.style.transition = 'transform 0.2s ease-out';
          btn.style.transform = 'scale(1.05)';
          setTimeout(() => {
            btn.style.transform = 'scale(1)';
          }, 200);
        });
      },
      
      /**
       * Phase 4C: Focus first interactive element based on mode
       * Root: textarea or first input
       * Inspect: back button
       */

      // --- REFRESH ---

      refreshAfterChange() {
        const { lineIndex, wordIndex } = this.currentWord;
        
        // Re-render paper
        PaperRenderer.render();
        
        // Find the updated word element and refresh inspector data
        const wordStack = document.querySelector(`.word-stack[data-line-index="${lineIndex}"][data-word-index="${wordIndex}"]`);
        if (wordStack) {
          this.currentWord = {
            ...this.currentWord,
            cyrillic: wordStack.dataset.cyrillic,
            ipa: wordStack.dataset.ipa,
            syllables: JSON.parse(wordStack.dataset.syllables || '[]'),
            hasYo: wordStack.dataset.hasYo,
            stressSource: wordStack.dataset.stressSource,
            rightBoundary: wordStack.dataset.rightBoundary,
            boundarySource: wordStack.dataset.boundarySource
          };
          this.updateInspector();
        }
      },
      

      // --- NAVIGATION ---

      _focusFirstElement(mode) {
        if (!this.drawer) return;
        
        let target;
        if (mode === 'root') {
          // Focus textarea first, then fall back to any input
          target = this.drawer.querySelector('.drawer-root textarea, .drawer-root input');
        } else {
          // Focus back button in inspect mode
          target = this.inspectorElements.backBtn;
        }
        
        target?.focus();
      },
      
      /**
       * Phase 5C: Set up swipe-to-dismiss for mobile bottom sheet
       * Only active when viewport ≤600px
       */

      // --- SETUP ---

      _setupSwipeToDismiss() {
        const dragHandle = document.querySelector('.drawer-drag-handle');
        if (!dragHandle) return;
        
        let startY = 0;
        let currentY = 0;
        let isDragging = false;
        
        const handleTouchStart = (e) => {
          // Only on mobile
          if (window.innerWidth > 600) return;
          if (!this.isOpen) return;
          
          startY = e.touches[0].clientY;
          currentY = startY;
          isDragging = true;
          this.drawer.style.transition = 'none';
        };
        
        const handleTouchMove = (e) => {
          if (!isDragging) return;
          
          currentY = e.touches[0].clientY;
          const deltaY = currentY - startY;
          
          // Only allow dragging down (positive deltaY)
          if (deltaY > 0) {
            this.drawer.style.transform = `translateY(${deltaY}px)`;
          }
        };
        
        const handleTouchEnd = () => {
          if (!isDragging) return;
          isDragging = false;
          
          const deltaY = currentY - startY;
          this.drawer.style.transition = '';
          
          // If dragged more than 100px down, close the drawer
          if (deltaY > 100) {
            this.close();
          } else {
            // Snap back
            this.drawer.style.transform = '';
          }
        };
        
        dragHandle.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: true });
        document.addEventListener('touchend', handleTouchEnd);
      },
      
      /**
       * Phase 5C: Viewport resize state synchronization
       * Maintains drawer state when crossing breakpoints
       */

      _setupViewportListener() {
        const mobileQuery = window.matchMedia('(max-width: 600px)');
        const tabletQuery = window.matchMedia('(min-width: 601px) and (max-width: 899px)');
        
        const handleResize = () => {
          if (!this.drawer) return;
          
          // Reset any inline transform from swipe gesture
          if (this.isOpen) {
            this.drawer.style.transform = '';
          }
          
          // The CSS handles layout changes automatically
          // This just ensures clean state after resize
        };
        
        mobileQuery.addEventListener('change', handleResize);
        tabletQuery.addEventListener('change', handleResize);
      }

    };

    /* EVENT DELEGATION */
    document.addEventListener('click', (e) => {
      // Handle word-stack clicks → open drawer in Drill mode (Phase 3A)
      const wordStack = e.target.closest('.word-stack');
      if (wordStack) {
        const data = {
          wordId: wordStack.dataset.wordId,
          lineIndex: parseInt(wordStack.dataset.lineIndex, 10),
          wordIndex: parseInt(wordStack.dataset.wordIndex, 10),
          ipa: wordStack.dataset.ipa,
          cyrillic: wordStack.dataset.cyrillic,
          gloss: wordStack.dataset.gloss,
          pos: wordStack.dataset.pos,
          lemma: wordStack.dataset.lemma,
          punctuation: wordStack.dataset.punctuation || '',
          syllables: JSON.parse(wordStack.dataset.syllables || '[]'),
          transcriptionLog: JSON.parse(wordStack.dataset.transcriptionLog || '[]'),
          isProclitic: wordStack.dataset.isProclitic,
          isEnclitic: wordStack.dataset.isEnclitic,
          hasYo: wordStack.dataset.hasYo,
          stressSource: wordStack.dataset.stressSource,
          rightBoundary: wordStack.dataset.rightBoundary,
          boundarySource: wordStack.dataset.boundarySource,
          element: wordStack
        };
        
        if (!DrawerState.isOpen) {
          // Drawer closed → open in inspect mode
          DrawerState.open('inspect', data);
        } else {
          // Drawer already open → switch to inspect mode with new word
          DrawerState.switchMode('inspect', data);
        }
        return;
      }

      // Don't process drawer zones if click is inside drawer/input
      if (e.target.closest('.ilya-drawer')) return;
      if (e.target.closest('.input-drawer')) return;

      // Scrim click → close drawer
      if (e.target.closest('.drawer-scrim')) {
        DrawerState.close();
        return;
      }

      // Paper chrome = click inside paper page area but NOT on a word
      // This means clicking white margins, headers, inter-line space on the page
      const page = e.target.closest('.paper-page');
      if (page) {
        DrawerState.open('root');
        return;
      }

      // Everything else (grey aperture background, body) = desk → close
      DrawerState.close();
    });

    // Escape key → close drawer
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && DrawerState.isOpen) {
        DrawerState.close();
        return;
      }
    });
    
    document.addEventListener('keydown', (e) => {
      
      const wordStack = e.target.closest('.word-stack');
      if (!wordStack) return;
      
      const verseLine = wordStack.closest('.verse-line');
      const allWords = [...verseLine.querySelectorAll('.word-stack')];
      const currentIndex = allWords.indexOf(wordStack);
      
      let nextElement = null;
      
      switch (e.key) {
        case 'ArrowRight':
          e.preventDefault();
          if (currentIndex < allWords.length - 1) {
            nextElement = allWords[currentIndex + 1];
          }
          break;
          
        case 'ArrowLeft':
          e.preventDefault();
          if (currentIndex > 0) {
            nextElement = allWords[currentIndex - 1];
          }
          break;
          
        case 'ArrowDown':
          e.preventDefault();
          const nextVerse = verseLine.nextElementSibling;
          if (nextVerse && nextVerse.classList.contains('verse-line')) {
            const nextWords = [...nextVerse.querySelectorAll('.word-stack')];
            nextElement = nextWords[Math.min(currentIndex, nextWords.length - 1)];
          }
          break;
          
        case 'ArrowUp':
          e.preventDefault();
          const prevVerse = verseLine.previousElementSibling;
          if (prevVerse && prevVerse.classList.contains('verse-line')) {
            const prevWords = [...prevVerse.querySelectorAll('.word-stack')];
            nextElement = prevWords[Math.min(currentIndex, prevWords.length - 1)];
          }
          break;
          
        case 'Enter':
        case ' ':
          e.preventDefault();
          wordStack.click();
          return;
      }
      
      if (nextElement) {
        nextElement.focus();
      }
    });

    /* INITIALIZATION */
    document.addEventListener('DOMContentLoaded', () => {
      DrawerState.init();
      InputManager.init();
      TabController.init();
      // Metadata, welcome flow, and export (dissolved from DashboardController in D.3)
      metaTitleInput = document.getElementById('metaTitle');
      metaOpusInput = document.getElementById('metaOpus');
      metaTranscriberInput = document.getElementById('metaTranscriber');
      metaExportBtn = document.getElementById('exportPdfBtn');
      const welcomePreface = document.getElementById('welcomePreface');
      const welcomeNameInput = document.getElementById('welcomeNameInput');
      const welcomeSaveBtn = document.getElementById('welcomeSaveBtn');
      const welcomeSkipBtn = document.getElementById('welcomeSkipBtn');
      // Load saved name
      const savedName = localStorage.getItem('ilya_transcriber_name');
      const welcomeCompleted = localStorage.getItem('ilya_welcome_completed');
      if (savedName) {
        DocumentState.userName = savedName;
        if (metaTranscriberInput) metaTranscriberInput.value = savedName;
      } else {
        DocumentState.userName = '';
      }
      if (!welcomeCompleted && welcomePreface) {
        welcomePreface.classList.remove('hidden');
      }
      // Welcome banner actions
      welcomeSaveBtn?.addEventListener('click', () => {
        const name = welcomeNameInput?.value.trim();
        if (name) {
          localStorage.setItem('ilya_transcriber_name', name);
          localStorage.setItem('ilya_welcome_completed', 'true');
          DocumentState.userName = name;
          if (metaTranscriberInput) metaTranscriberInput.value = name;
          welcomePreface?.classList.add('hidden');
          if (DocumentState.lines.length > 0) PaperRenderer.render();
        }
      });
      welcomeSkipBtn?.addEventListener('click', () => {
        localStorage.setItem('ilya_welcome_completed', 'true');
        DocumentState.userName = '';
        welcomePreface?.classList.add('hidden');
      });
      // Searchable selects
      metaComposerSelect = SearchableSelect.create({
        id: 'composer',
        trigger: document.getElementById('composerTrigger'),
        dropdown: document.getElementById('composerDropdown'),
        search: document.getElementById('composerSearch'),
        options: document.getElementById('composerOptions'),
        data: COMPOSERS,
        onSelect: () => { if (DocumentState.lines.length > 0) PaperRenderer.render(); }
      });
      metaPoetSelect = SearchableSelect.create({
        id: 'poet',
        trigger: document.getElementById('poetTrigger'),
        dropdown: document.getElementById('poetDropdown'),
        search: document.getElementById('poetSearch'),
        options: document.getElementById('poetOptions'),
        data: POETS,
        onSelect: () => { if (DocumentState.lines.length > 0) PaperRenderer.render(); }
      });
      // Metadata input listeners
      metaTitleInput?.addEventListener('input', () => {
        if (DocumentState.lines.length > 0) PaperRenderer.render();
      });
      metaOpusInput?.addEventListener('input', () => {
        if (DocumentState.lines.length > 0) PaperRenderer.render();
      });
      metaTranscriberInput?.addEventListener('input', () => {
        DocumentState.userName = metaTranscriberInput.value.trim() || '';
        if (DocumentState.lines.length > 0) PaperRenderer.render();
      });
      metaTranscriberInput?.addEventListener('blur', () => {
        const name = metaTranscriberInput.value.trim();
        if (name) {
          localStorage.setItem('ilya_transcriber_name', name);
        } else {
          localStorage.removeItem('ilya_transcriber_name');
        }
      });
      metaExportBtn?.addEventListener('click', () => exportPDF());
      updateExportButton();
      ProfileController.init();
      PaperManager.init();

      // DrawerBridge REMOVED in Phase 2C - InputManager now uses left drawer directly

      // --- PAPER GLOSS REFRESH (v6.0.54) — Re-renders all paper-surface glosses in currentGlossLanguage — without re-transcription. Called by pill handler on toggle. ---
      function refreshPaperGlosses() {
        const wordStacks = document.querySelectorAll('.word-stack');
        wordStacks.forEach(stack => {
          const glossSpan = stack.querySelector('.gloss');
          if (!glossSpan) return;

          const isClitic = stack.dataset.isProclitic === 'true' || stack.dataset.isEnclitic === 'true';
          const cyrillic = stack.dataset.cyrillic || '';
          let newGloss = '';

          if (isClitic) {
            const cliticEntry = GraysonEngine.cliticData.get(cyrillic.toLowerCase());
            newGloss = extractGloss(cliticEntry?.gloss);
          } else {
            const lineIdx = parseInt(stack.dataset.lineIndex, 10);
            const wordIdx = parseInt(stack.dataset.wordIndex, 10);
            const wordData = DocumentState.lines[lineIdx]?.[wordIdx];
            if (wordData) {
              newGloss = formatGlossForDisplay(wordData.gloss, wordData.pos, wordData.lemma, cyrillic);
            }
          }

          glossSpan.textContent = newGloss;
          stack.dataset.gloss = newGloss;
        });
      }

      // --- LANGUAGE PILL (v6.0.51, relocated v6.0.52) — Unified segmented pill — Root pill sets language only, — Drill pill swaps display language in-place ---
      function initLangPill(pillElement, mode) {
        if (!pillElement) return;
        
        const options = pillElement.querySelectorAll('.lang-option');
        
        options.forEach(option => {
          option.addEventListener('click', () => {
            const newLang = option.dataset.lang;
            if (newLang === currentGlossLanguage) return;
            
            // Update global state
            currentGlossLanguage = newLang;
            
            // Update ALL pills to stay in sync (immediate — header stays still)
            document.querySelectorAll('.lang-toggle-pill').forEach(pill => {
              pill.dataset.lang = newLang;
              pill.querySelectorAll('.lang-option').forEach(opt => {
                const isActive = opt.dataset.lang === newLang;
                opt.classList.toggle('active', isActive);
                opt.setAttribute('aria-checked', isActive);
              });
            });
            
            // Breath animation (v6.0.54 — Kimi spec: 150ms out, 250ms in)
            // Targets: drawer-body (Root), inspector-body (Drill), paper-stack (Paper)
            const drawerBody = document.querySelector('.drawer-body');
            const inspectorBody = document.querySelector('.inspector-body');
            const paperStack = document.getElementById('paperStack');
            const breathTargets = [drawerBody, inspectorBody, paperStack].filter(Boolean);
            
            // Phase 1: Breathe out (150ms)
            breathTargets.forEach(el => {
              el.classList.remove('breath-in');
              el.classList.add('breath-out');
            });
            
            // Phase 2: At midpoint, swap content
            setTimeout(() => {
              setUILanguage(newLang);
              
              // Full re-render: glosses, verify badges, and footer attribution (v6.0.54)
              PaperRenderer.render();
              
              if (mode === 'drill') {
                const word = DrawerState.currentWord;
                if (word) {
                  const docWord = DocumentState.lines[word.lineIndex]?.[word.wordIndex];
                  if (docWord) {
                    word.gloss = extractGloss(docWord.gloss);
                  }
                  
                  // Save expanded ribbon state before re-render
                  const ribbon = document.getElementById('inspectorRibbon');
                  const expandedRows = [];
                  const expandedClusters = [];
                  if (ribbon) {
                    ribbon.querySelectorAll('.phoneme-row').forEach((row, idx) => {
                      if (row.classList.contains('expanded')) expandedRows.push(idx);
                    });
                    ribbon.querySelectorAll('.cluster-group').forEach((grp, idx) => {
                      if (grp.classList.contains('expanded')) expandedClusters.push(idx);
                    });
                  }
                  
                  DrawerState.updateInspector();
                  
                  // Restore expanded rows after re-render
                  if (ribbon && (expandedRows.length || expandedClusters.length)) {
                    const rows = ribbon.querySelectorAll('.phoneme-row');
                    expandedRows.forEach(idx => {
                      if (rows[idx]) rows[idx].classList.add('expanded');
                    });
                    const clusters = ribbon.querySelectorAll('.cluster-group');
                    expandedClusters.forEach(idx => {
                      if (clusters[idx]) clusters[idx].classList.add('expanded');
                    });
                  }
                }
              }
              
              // Phase 3: Breathe in (250ms)
              breathTargets.forEach(el => {
                el.classList.remove('breath-out');
                el.classList.add('breath-in');
              });
              
              // Clean up animation classes
              setTimeout(() => {
                breathTargets.forEach(el => el.classList.remove('breath-in'));
              }, 250);
              
            }, 150);
            
          });
        });
      }
      
      // Initialize both pills
      initLangPill(document.getElementById('rootLangPill'), 'root');
      initLangPill(document.getElementById('drillLangPill'), 'drill');
      
      // --- TRANSCRIBE BUTTON (v6.0.52) — Dedicated action button — label swaps with language pill ---
      const transcribeBtn = document.getElementById('drawerTranscribeBtn');
      if (transcribeBtn) {
        transcribeBtn.addEventListener('click', () => {
          const hasText = InputManager.textInput?.value?.trim().length > 0;
          if (hasText) {
            InputManager.transcribe();
          } else {
            PaperRenderer.render();
          }
        });
      }
      
      // Render empty title page on load
      PaperRenderer.render();
    });

    // Expose for tests.html
    window.GraysonEngine = GraysonEngine;

    /**
     * DICTIONARY AUDIT DIAGNOSTIC (v5.11.20)
     * Usage: auditDictionary() to audit current document
     *        auditDictionary("Брожу ли я вдоль улиц шумных") to audit custom text
     * 
     * Returns coverage statistics and categorized misses
     */
    window.auditDictionary = function(text) {
      // Use provided text or current document
      const corpus = text || (DocumentState.lines || []).map(l => l.text).join('\n');
      
      if (!corpus) {
        return;
      }
      
      // Extract words (Cyrillic only, normalized)
      const wordPattern = /[а-яёА-ЯЁ]+/g;
      const rawWords = corpus.match(wordPattern) || [];
      
      // Count word frequencies
      const wordFreq = new Map();
      rawWords.forEach(w => {
        const lower = w.toLowerCase();
        wordFreq.set(lower, (wordFreq.get(lower) || 0) + 1);
      });
      
      // Categorize each unique word
      const results = {
        found: [],
        notInDictionary: [],
        isClitic: [],
        total: wordFreq.size,
        totalTokens: rawWords.length
      };
      
      wordFreq.forEach((freq, word) => {
        // Check if it's a clitic (handled separately)
        if (GraysonEngine.proclitics.has(word) || GraysonEngine.enclitics.has(word)) {
          results.isClitic.push({ word, freq });
          return;
        }
        
        // Check curated glosses
        if (CURATED_GLOSSES.has(word)) {
          results.found.push({ word, freq, source: 'curated' });
          return;
        }
        
        // Check main dictionary
        if (typeof window.russianDictionary !== 'undefined' && window.russianDictionary.has(word)) {
          results.found.push({ word, freq, source: 'dictionary' });
          return;
        }
        
        // Not found
        results.notInDictionary.push({ word, freq });
      });
      
      // Sort misses by frequency (highest first)
      results.notInDictionary.sort((a, b) => b.freq - a.freq);
      
      // Calculate coverage
      const foundCount = results.found.length + results.isClitic.length;
      const coverage = ((foundCount / results.total) * 100).toFixed(1);
      const tokenCoverage = ((results.found.reduce((sum, w) => sum + w.freq, 0) + 
                              results.isClitic.reduce((sum, w) => sum + w.freq, 0)) / 
                             results.totalTokens * 100).toFixed(1);
      
      // Return raw data for programmatic use
      return {
        coverage: parseFloat(coverage),
        tokenCoverage: parseFloat(tokenCoverage),
        uniqueWords: results.total,
        totalTokens: results.totalTokens,
        found: results.found.length,
        missing: results.notInDictionary,
        clitics: results.isClitic
      };
    };
  </script>

</body>
</html>
