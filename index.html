<!DOCTYPE html>
<html lang="ru" translate="no">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google" content="notranslate">
  <title>Ilya — v5.11.30 two-layer cluster architecture</title>
  
  <!-- Favicon: simple И in terracotta circle -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23a85a3a'/><text x='50' y='68' font-size='50' fill='white' text-anchor='middle' font-family='serif'>И</text></svg>">
  
  <!-- Noto Serif for all text -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500&family=Noto+Serif:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
  
  <!-- Pako library for gzip decompression -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  
  <style>
    /* ========================================
       CALM AUTHORITY PALETTE v5.2
       Kimi Design System — Muted Sage Edition
       ======================================== */
    :root {
      /* Core Palette */
      --ilya-paper: #ffffff;
      --ilya-parchment: #fafafa;
      --ilya-binding: #f5f5f0;
      --ilya-binding-dark: #ebebe5;
      
      /* Legacy aliases (for backward compatibility) */
      --paper: #faf6f0;
      --surface: #ffffff;
      
      /* Typography Colors */
      --ilya-text-primary: #2c3e50;
      --ilya-text-secondary: #5a6c7d;
      --ilya-text-muted: #7f8c8d;
      --ilya-text-caption: #95a5a6;
      
      /* Legacy ink aliases */
      --ink-primary: #1a1612;
      --ink-secondary: #4a4540;
      
      /* Ilya Stationery Palette (v5.9.6) */
      --stationery-cream: #F8F5F0;        /* Warm aged manuscript */
      --stationery-ink: #1A1612;          /* Rich black, not pure */
      --stationery-accent: #8B9A7D;       /* Sage green - primary accent */
      --stationery-sage: #8B9A7D;         /* Alias for clarity */
      --stationery-watermark: rgba(139, 154, 125, 0.06); /* Faint sage */
      
      /* Borders & Focus */
      --ilya-border-light: #e8e8e8;
      --ilya-border: #e0e0e0;
      --ilya-border-focus: #7a9e7e;
      
      /* Functional Colors — Muted Sage Accent */
      --ilya-accent: #7a9e7e;
      --ilya-accent-light: rgba(122, 158, 126, 0.1);
      --ilya-accent-hover: #6b8e6f;
      
      /* Legacy accent aliases (terracotta for existing components) */
      --accent: #a85a3a;
      --accent-muted: rgba(168, 90, 58, 0.75);
      
      /* Status Colors */
      --ilya-warning: #d4a373;
      
      /* Fonts */
      --font-mono: 'Courier New', 'Consolas', monospace;
      --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-ipa: 'Doulos SIL', 'Charis SIL', 'Gentium', 'Noto Serif', 'Times New Roman', serif;
      
      /* Paper dimensions (v5.8.2) */
      /* Letter: 8.5in × 11in at 96dpi = 816px × 1056px */
      /* A4: 210mm × 297mm at 96dpi ≈ 794px × 1123px */
      --paper-width: 816px;
      --paper-height: 1056px;
      --paper-aspect: 8.5 / 11;
      
      /* Shadows */
      --ilya-shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      
      /* Legacy shadow aliases */
      --shadow-ambient: 0 1px 2px rgba(26, 22, 18, 0.08);
      --shadow-card: 0 2px 8px rgba(26, 22, 18, 0.1);
      --shadow-paper: 0 2px 12px rgba(26, 22, 18, 0.08);
      --shadow-popup: 0 8px 24px rgba(26, 22, 18, 0.15);
      
      /* Document Container */
      --ilya-doc-radius: 16px;
      --ilya-doc-border: 2px solid var(--ilya-border);
      --ilya-doc-shadow: 0 4px 20px rgba(0,0,0,0.05);
      
      /* Spacing Scale (8px base) */
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      
      /* Typography Scale */
      --text-xs: 12px;
      --text-sm: 14px;
      --text-base: 16px;
      
      /* Animation Timing */
      --duration-fast: 150ms;
      --duration-base: 300ms;
      --ease-out: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      
      /* Legacy */
      --radius: 6px;
      --ease: cubic-bezier(0.34, 0, 0.2, 1);
      --drawer-handle-height: 36px;
    }

    /* ========================================
       RESET & BASE
       ======================================== */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans', system-ui, sans-serif;
      background-color: #e8e4de;
      color: var(--ink-primary);
      line-height: 1.6;
      min-height: 100vh;
      overflow: hidden;
    }

    /* ========================================
       UNIFIED FOCUS SYSTEM
       All interactive elements use 2px sage outline
       ======================================== */
    :focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    :focus:not(:focus-visible) {
      outline: none;
    }
    
    :focus-visible {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    /* Form elements use border + box-shadow instead of outline */
    input:focus,
    textarea:focus,
    select:focus,
    [contenteditable]:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    input:focus:not(:focus-visible),
    textarea:focus:not(:focus-visible),
    select:focus:not(:focus-visible),
    [contenteditable]:focus:not(:focus-visible) {
      box-shadow: none;
      border-color: var(--ilya-border);
    }

    /* ========================================
       DISPLAY CONTAINER: Main app layout
       ======================================== */
    .display-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* ========================================
       PAPER APERTURE: Viewing area with inset depth
       ======================================== */
    .paper-aperture {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
      /* Kimi: explicit height prevents infinite growth */
      min-height: 0; /* Flex child needs this to scroll */
    }

    /* ========================================
       PAPER: Document simulation (v5.9.1)
       Supports Letter (8.5×11) and A4 (210×297mm)
       Height-constrained with aspect-ratio calculating width
       ======================================== */
    .paper {
      /* Height is the constraining dimension; aspect-ratio calculates width */
      height: min(var(--paper-height), 80vh);
      aspect-ratio: var(--paper-aspect);
      max-width: calc(100% - 3rem);
      background: var(--surface);
      box-shadow: var(--shadow-paper);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
      margin: 1.5rem auto;
      transition: aspect-ratio 300ms ease-out, 
                  height 300ms ease-out;
      
      /* Ghosted scrollbar (Calm Authority) */
      scrollbar-width: thin;
      scrollbar-color: rgba(74, 69, 64, 0.2) transparent;
    }
    
    /* WebKit ghosted scrollbar */
    .paper::-webkit-scrollbar {
      width: 6px;
    }
    
    .paper::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .paper::-webkit-scrollbar-thumb {
      background: rgba(74, 69, 64, 0.2);
      border-radius: 3px;
    }
    
    .paper::-webkit-scrollbar-thumb:hover {
      background: rgba(74, 69, 64, 0.35);
    }
    
    /* A4 paper size */
    .paper[data-size="a4"] {
      --paper-width: 794px;
      --paper-height: 1123px;
      --paper-aspect: 210 / 297;
    }
    
    /* Post-animation content fade (for reflow) */
    .paper.reflowing .doc-body {
      opacity: 0.8;
      transition: opacity 100ms ease-out;
    }

    @media print {
      .paper {
        width: 8.5in;
        height: 11in;
        margin: 0;
        box-shadow: none;
        overflow: visible;
      }
      
      .paper[data-size="a4"] {
        width: 210mm;
        height: 297mm;
      }
    }

    /* Loading state */
    .paper.rendering {
      opacity: 0.7;
      transition: opacity 100ms ease;
    }

    /* ========================================
       PAGE TEMPLATES (v5.9.4)
       Multi-page stationery design
       ======================================== */
    
    /* Container for multiple pages */
    .paper-stack {
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 24px;
    }
    
    /* Individual page */
    .paper-page {
      width: min(var(--paper-width), 100% - 3rem);
      min-height: var(--paper-height);
      aspect-ratio: var(--paper-aspect);
      background: var(--stationery-cream);
      box-shadow: 0 2px 4px rgba(26, 22, 18, 0.08);
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      position: relative;
      overflow: hidden;  /* Prevent content bleed between pages (v5.11.9) */
      
      /* GPU acceleration for shadow performance */
      transform: translateY(0);
      will-change: transform;
    }
    
    /* A4 variant */
    .paper-page[data-size="a4"] {
      --paper-width: 794px;
      --paper-height: 1123px;
      --paper-aspect: 210 / 297;
    }
    
    /* ----------------------------------------
       PAGE 1: TITLE TEMPLATE
       ---------------------------------------- */
    .paper-page[data-template="title"] {
      /* Structure defined by children */
    }
    
    /* Bracket logo [ Ilya ] */
    .page-logo {
      position: absolute;
      top: 48px;
      left: 72px;
      font-size: 18px;
      color: var(--stationery-sage);
      display: flex;
      align-items: baseline;
      gap: 2px;
    }
    
    .page-logo .bracket {
      font-family: var(--font-mono);
      font-weight: 600;
    }
    
    .page-logo .logo-name {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-style: italic;
      font-weight: normal;
      letter-spacing: 0.5px;
    }
    
    /* Title header block */
    .page-header-title {
      padding: 72px 72px 16px;
      text-align: left;
    }
    
    .page-title {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-size: 28px;
      font-weight: normal;
      color: var(--stationery-ink);
      margin: 0 0 16px 0;
      letter-spacing: 0.5px;
    }
    
    .page-metadata {
      font-family: var(--font-sans);
      font-size: 11px;
      font-weight: 500;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    
    .page-metadata .divider {
      color: var(--stationery-sage);
      font-weight: 300;
    }
    
    .page-metadata-rule {
      width: 200px;
      height: 1px;
      background: var(--stationery-sage);
      margin-top: 16px;
      border: none;
    }
    
    /* ----------------------------------------
       PAGES 2+: SUBSEQUENT TEMPLATE
       ---------------------------------------- */
    .paper-page[data-template="subsequent"] {
      /* Structure defined by children */
    }
    
    /* Faint bracket watermark */
    .paper-page[data-template="subsequent"]::before {
      content: "[ ]";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--font-mono);
      font-size: 48px;
      font-weight: 300;
      color: var(--stationery-watermark);
      letter-spacing: 8px;
      pointer-events: none;
    }
    
    /* Running header */
    .page-header-running {
      padding: 36px 72px 8px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      border-bottom: 1px solid var(--stationery-sage);
      margin: 0 72px;
      padding-left: 0;
      padding-right: 0;
    }
    
    .running-title {
      font-family: var(--font-sans);
      font-size: 10px;
      font-weight: 600;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    /* ----------------------------------------
       PAGE CONTENT AREA
       ---------------------------------------- */
    .page-content {
      flex: 1;
      padding: 16px 72px;
      padding-bottom: 120px; /* Clearance for absolute footer (reduced from 150px in v5.11.17) */
      display: flex;
      flex-direction: column;
    }
    
    .page-content.empty {
      justify-content: center;
      align-items: center;
    }
    
    .page-ghost-text {
      color: var(--ink-secondary);
      opacity: 0.25;
      font-style: italic;
      font-family: var(--font-sans);
      font-size: 14px;
      text-align: center;
    }
    
    /* ----------------------------------------
       PAGE FOOTER (v5.9.6)
       2/3 attribution left, 1/3 pagination right
       Positioned absolutely at bottom of page
       ---------------------------------------- */
    .page-footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px 72px 32px;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 24px;
      align-items: end;
      background: var(--stationery-cream);
    }
    
    .footer-attribution {
      font-family: var(--font-sans);
      font-size: 8px;
      line-height: 1.5;
      color: var(--ink-secondary);
      max-width: 100%;
    }
    
    .footer-attribution p {
      margin: 0 0 4px 0;
    }
    
    .footer-attribution p:last-child {
      margin-bottom: 0;
    }
    
    .footer-pagination {
      font-family: var(--font-sans);
      font-size: 10px;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: right;
      white-space: nowrap;
    }
    
    /* ----------------------------------------
       PRINT STYLES FOR PAGES
       ---------------------------------------- */
    @media print {
      .paper-stack {
        gap: 0;
        padding: 0;
      }
      
      /* Note: Main print styles for .paper-page are in the comprehensive 
         @media print block below (around line 2650+) */
      
      .paper-page::before {
        /* Keep bracket logo but not watermark */
      }
      
      .paper-page[data-template="subsequent"]::before {
        display: none; /* Hide watermark in print */
      }
    }
    
    /* ----------------------------------------
       MOBILE: HORIZONTAL SWIPE
       ---------------------------------------- */
    @media (max-width: 768px) {
      .paper-stack {
        flex-direction: row;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        gap: 0;
        padding: 16px;
      }
      
      .paper-page {
        flex: 0 0 calc(100vw - 32px);
        scroll-snap-align: center;
        margin: 0 8px;
      }
    }

    /* Content area fills available space */
    .paper .doc-body {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .paper .verse-container {
      flex: 1;
    }

    /* ========================================
       DOCUMENT HEADER (Legacy - single page)
       ======================================== */
    .doc-header {
      padding: 72px 72px 24px;
      text-align: center;
      position: relative;
    }

    .doc-header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 72px;
      right: 72px;
      height: 1px;
      background: rgba(26, 22, 18, 0.1);
    }

    .doc-composer-line {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-top: 1rem;
    }

    .doc-composer {
      font-family: 'Noto Serif', serif;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--ink-secondary);
    }

    .doc-composer .dates {
      font-weight: 400;
      color: var(--ink-secondary);
      opacity: 0.8;
    }

    .doc-poet {
      font-family: 'Noto Serif', serif;
      font-size: 0.9rem;
      color: var(--ink-secondary);
    }

    .doc-poet .dates {
      color: var(--ink-secondary);
      opacity: 0.8;
    }

    .doc-title {
      font-family: 'Noto Serif', serif;
      font-size: 1.5rem;
      font-style: italic;
      font-weight: 400;
      color: var(--ink-primary);
      margin: 0 0 0.25rem 0;
    }

    .doc-opus {
      font-family: 'Noto Serif', serif;
      font-size: 0.9rem;
      color: var(--ink-secondary);
    }

    /* Placeholder text: greyed, italic, replaced by real content */
    .placeholder-text {
      font-style: italic;
      opacity: 0.35;
    }

    /* Hide placeholder when real content exists */
    .doc-composer:not(:empty) .placeholder-text,
    .doc-poet:not(:empty) .placeholder-text,
    .doc-title:not(:empty) .placeholder-text,
    .doc-opus:not(:empty) .placeholder-text {
      /* JS will remove placeholder spans when content is added */
    }

    /* ========================================
       DOCUMENT BODY
       ======================================== */
    .doc-body {
      flex: 1;
      padding: 24px 72px;
    }
    
    .verse-container {
      max-width: 100%;
    }

    /* ========================================
       DOCUMENT FOOTER
       ======================================== */
    .doc-footer {
      padding: 24px 72px 48px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-family: 'Noto Serif', serif;
      font-size: 0.8rem;
      color: var(--ink-secondary);
      position: relative;
    }

    .doc-footer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 72px;
      right: 72px;
      height: 1px;
      background: rgba(26, 22, 18, 0.1);
    }

    .doc-footer .attribution {
      font-style: italic;
    }

    /* ========================================
       VERSE LINE
       ======================================== */
    .verse-line {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 0.625rem; /* Column gap reduced from 1.5rem for density (v5.11.18) */
      align-items: flex-start;
      padding: 0.45rem 0;
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
      width: 100%;
    }

    .verse-line:last-child {
      border-bottom: none;
    }

    /* ========================================
       WORD STACK
       ======================================== */
    .word-stack {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.1rem;
      padding: 0.35rem 0.5rem 0.35rem 0;
      cursor: pointer;
      border-radius: var(--radius);
      transition: background 150ms var(--ease);
      flex-shrink: 0;
    }
    
    .word-stack:hover {
      background: rgba(168, 90, 58, 0.06);
    }

    .word-stack:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    /* Vowelless clitics: reduced gap (4px) to visually connect with host (v5.11.19) */
    .word-stack.vowelless-clitic.proclitic {
      margin-right: -0.375rem; /* Reduces 10px gap to 4px before host */
    }
    .word-stack.vowelless-clitic.enclitic {
      margin-left: -0.375rem; /* Reduces 10px gap to 4px after host */
    }

    .word-stack[aria-selected="true"] {
      background: var(--ilya-accent-light);
    }

    .word-stack .ipa {
      font-family: 'Charis SIL', 'Doulos SIL', 'Noto Serif', 'DejaVu Sans', serif;
      font-size: 1rem;
      color: var(--ink-secondary);
      letter-spacing: 0.01em;
    }

    .word-stack .cyrillic {
      font-family: 'Noto Serif', serif;
      font-size: 1rem;
      font-weight: 600;
      color: var(--ink-primary);
    }

    .word-stack .punct {
      color: var(--ink-secondary);
      opacity: 0.7;
    }

    .word-stack .gloss {
      font-family: 'Noto Serif', serif;
      font-size: 0.8rem;
      font-style: italic;
      color: var(--accent-muted);
      min-height: 1.1em;
      min-width: 1em;
    }

    .word-stack.proclitic .cyrillic,
    .word-stack.enclitic .cyrillic {
      font-weight: 500;
    }
    
    /* Clitics show directional arrows — normal spacing (v5.11.10) */
    
    /* Unverified stress: no visual indicator on paper — popup message is sufficient */

    /* ========================================
       INPUT DRAWER: Bottom-anchored, collapsible
       ======================================== */
    .input-drawer {
      flex-shrink: 0;
      background: var(--surface);
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
    }

    /* ========================================
       DRAWER HANDLE: Full-width clickable bar
       ======================================== */
    .drawer-handle {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      height: var(--drawer-handle-height);
      background: #f0f0f0;
      cursor: pointer;
      user-select: none;
      transition: background 150ms var(--ease);
    }

    .drawer-handle:hover {
      background: #e8e8e8;
    }

    .drawer-handle:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: -2px;
    }

    /* Preview text (left side, visible when collapsed) */
    .handle-preview {
      position: absolute;
      left: var(--space-lg);
      font-family: 'Noto Serif', serif;
      font-size: 0.85rem;
      color: var(--ink-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 40%;
      opacity: 0;
      transition: opacity 200ms var(--ease);
    }

    .input-drawer.collapsed .handle-preview {
      opacity: 1;
    }

    /* Center toggle (chevron + label) */
    .handle-toggle {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .handle-toggle .chevron {
      width: 14px;
      height: 14px;
      stroke: var(--ink-secondary);
      stroke-width: 2;
      fill: none;
      opacity: 0.6;
      transition: transform 200ms var(--ease);
    }

    .handle-toggle .handle-label {
      font-size: 0.7rem;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--ink-secondary);
      opacity: 0.6;
    }

    /* Show appropriate label based on state */
    .handle-label-more,
    .handle-label-less {
      display: none;
    }

    .input-drawer.expanded .handle-label-less {
      display: inline;
    }

    .input-drawer.expanded .handle-label-more {
      display: none;
    }

    .input-drawer.collapsed .handle-label-more {
      display: inline;
    }

    .input-drawer.collapsed .handle-label-less {
      display: none;
    }

    /* Chevron flips when collapsed */
    .input-drawer.collapsed .handle-toggle .chevron {
      transform: rotate(180deg);
    }

    /* ========================================
       DRAWER: Expanded Content
       ======================================== */
    .drawer-content {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      transition: opacity 200ms var(--ease);
    }

    /* Hide content when collapsed */
    .input-drawer.collapsed .drawer-content {
      display: none;
    }

    /* ========================================
       DRAWER: Textarea
       ======================================== */
    .drawer-textarea {
      width: 100%;
      max-height: 240px;
      min-height: 100px;
      padding: 0.75rem;
      font-family: monospace;
      font-size: 0.95rem;
      line-height: 1.6;
      color: var(--ink-secondary);
      background: #f5f5f5;
      border: 1px solid rgba(26, 22, 18, 0.12);
      border-radius: var(--radius);
      resize: vertical;
      transition: border-color 150ms var(--ease);
    }

    .drawer-textarea:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }

    .drawer-textarea::placeholder {
      color: var(--ink-secondary);
      opacity: 0.5;
    }

    /* ========================================
       DRAWER: Footer (status + buttons)
       ======================================== */
    .drawer-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: var(--space-md);
    }

    .footer-status {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      font-size: 0.75rem;
      color: var(--ink-secondary);
    }

    .char-counter {
      opacity: 0;
      transition: opacity 200ms var(--ease);
    }

    .char-counter.visible {
      opacity: 1;
    }

    .char-counter.warning {
      color: #b45309;
    }

    .char-counter.error {
      color: #dc2626;
    }

    .auto-saved {
      opacity: 0;
      transition: opacity 200ms var(--ease);
    }

    .auto-saved.visible {
      opacity: 0.7;
    }

    /* OCR Status */
    .ocr-status {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      color: var(--ink-secondary);
    }

    .ocr-status.error {
      color: #c75d5d;
    }

    .ocr-status.success {
      color: var(--ilya-accent);
    }

    .ocr-status .spinner {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Scan button icon alignment */
    #ocrScanBtn {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    #ocrScanBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .footer-actions {
      display: flex;
      gap: var(--space-sm);
    }

    /* Button styles */
    .btn {
      padding: 0.5rem 1.25rem;
      border-radius: var(--radius);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }

    .btn-primary {
      background: var(--ilya-accent);
      color: white;
      border: none;
    }

    .btn-primary:hover {
      background: var(--ilya-accent-hover);
    }
    
    .btn-primary:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .btn-secondary {
      background: transparent;
      color: var(--ilya-text-secondary);
      border: 1px solid var(--ilya-border);
    }

    .btn-secondary:hover {
      border-color: var(--ilya-text-secondary);
      color: var(--ilya-text-primary);
    }
    
    .btn-secondary:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    /* ========================================
       GHOST TEXT: Empty state instruction
       ======================================== */
    .ghost-text {
      margin: 0;
      padding: 0;
      font-family: 'Noto Serif', serif;
      font-style: italic;
      font-size: 1rem;
      line-height: 1.6;
      color: var(--ink-secondary);
      opacity: 0.5;
      max-width: 45em;
    }

    .ghost-text p {
      margin: 0 0 0.5rem 0;
    }

    .ghost-text.hidden {
      display: none;
    }

    /* ========================================
       POPUP OVERLAY
       ======================================== */
    .popup-overlay {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: none;
    }

    .popup-overlay.active {
      display: block;
    }

    .popup-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(26, 22, 18, 0.1);
    }

    /* ========================================
       POPUP CARD
       ======================================== */
    .popup-card {
      position: absolute;
      width: 320px;
      max-height: 70vh;
      overflow-y: auto;
      background: var(--surface);
      border-radius: var(--radius);
      box-shadow: var(--shadow-popup);
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 250ms var(--ease), transform 250ms var(--ease);
      z-index: 101;
    }

    .popup-overlay.active .popup-card {
      opacity: 1;
      transform: translateY(0);
    }

    .popup-arrow {
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid var(--surface);
      filter: drop-shadow(0 2px 2px rgba(26, 22, 18, 0.08));
    }

    .popup-card.arrow-top .popup-arrow {
      top: -8px;
      bottom: auto;
      border-top: none;
      border-bottom: 10px solid var(--surface);
      filter: drop-shadow(0 -2px 2px rgba(26, 22, 18, 0.08));
    }

    /* Mobile popup */
    @media (max-width: 600px) {
      .popup-card {
        position: fixed;
        left: 0 !important;
        right: 0;
        bottom: 0 !important;
        top: auto !important;
        width: 100%;
        max-height: 70vh;
        border-radius: 16px 16px 0 0;
        transform: translateY(100%);
        overflow-y: auto;
      }

      .popup-overlay.active .popup-card {
        transform: translateY(0);
      }

      .popup-arrow {
        display: none;
      }

      .popup-body::before {
        content: '';
        display: block;
        width: 36px;
        height: 4px;
        background: rgba(26, 22, 18, 0.2);
        border-radius: 2px;
        margin: 0.75rem auto 0.5rem;
      }
    }

    /* ========================================
       POPUP BODY
       ======================================== */
    .popup-body {
      padding: 1.25rem;
    }

    .clitic-badge {
      background: var(--ilya-accent-light);
      color: var(--ilya-accent);
      font-size: 0.75rem;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      margin-bottom: 1rem;
      text-align: center;
    }

    .why-clitic-banner {
        background: var(--ilya-accent-light);
        color: var(--ilya-accent);
        font-size: 0.75rem;
        padding: 0.6rem 0.85rem;
        border-radius: 4px;
        margin-bottom: 0.75rem;
        text-align: left;
        line-height: 1.45;
    }
    
    .why-clitic-banner em {
        display: block;
        margin-top: 0.4rem;
        font-style: italic;
    }
    
    .why-clitic-banner .tie-bar-ref {
        color: var(--ilya-accent-dark, #4a5c4d);
        font-weight: 600;
        font-style: normal;
    }

    .syllable-section {
      margin-bottom: 1rem;
    }

    .syllable-label {
      font-size: 0.7rem;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .syllable-sandwich {
      background: var(--paper);
      border-radius: var(--radius);
      padding: 0.6rem;
    }

    .syllable-display {
      display: flex;
      justify-content: center;
      gap: 0.3rem;
      flex-wrap: wrap;
    }

    .syllable-btn {
      font-family: 'Noto Serif', serif;
      font-size: 1.15rem;
      padding: 0.5rem 0.75rem;
      background: var(--surface);
      border: 1px solid rgba(26, 22, 18, 0.15);
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }

    .syllable-btn:hover {
      border-color: var(--ilya-accent);
      background: var(--ilya-accent-light);
    }
    
    .syllable-btn:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .syllable-btn.stressed {
      background: var(--ilya-accent);
      color: white;
      border-color: var(--ilya-accent);
      font-weight: 500;
    }

    .syllable-btn.stressed:hover {
      background: var(--ilya-accent-hover);
    }
    
    .syllable-btn.disabled,
    .syllable-btn:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      background: var(--ilya-parchment);
      border-color: rgba(26, 22, 18, 0.1);
    }
    
    .syllable-btn.disabled:hover,
    .syllable-btn:disabled:hover {
      border-color: rgba(26, 22, 18, 0.1);
      background: var(--ilya-parchment);
    }
    
    .syllable-btn.disabled:focus,
    .syllable-btn:disabled:focus {
      outline: none;
    }
    
    /* Syllable drag states (v5.10.15) */
    .syllable-btn.dragging {
      opacity: 0.5;
      transform: scale(0.98);
    }
    
    .syllable-btn.drag-target {
      border-color: var(--ilya-accent);
      box-shadow: 0 0 0 3px rgba(122, 158, 126, 0.3);
    }
    
    .syllable-btn.drag-invalid {
      animation: shake 0.3s ease-out;
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    
    /* Ghost consonant during drag */
    .consonant-ghost {
      position: fixed;
      pointer-events: none;
      font-family: var(--font-ipa);
      font-size: 1.15rem;
      padding: 0.3rem 0.5rem;
      background: var(--surface);
      border: 1px solid var(--ilya-accent);
      border-radius: 4px;
      opacity: 0.85;
      z-index: 10000;
      transition: opacity 0.15s, transform 0.15s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .consonant-ghost.valid {
      background: var(--ilya-accent-light);
      border-color: var(--ilya-accent);
    }
    
    .consonant-ghost.invalid {
      background: #fee;
      border-color: #c44;
      opacity: 0.6;
    }

    /* Syllable display header (v5.10.19) - interactive IPA at top of popup */
    .syllable-display-header {
      text-align: center;
      margin-bottom: 0.5rem;
    }
    
    .syllable-display-header .syllable-display {
      justify-content: center;
    }
    
    .syllable-display-header .syllable-btn {
      font-family: var(--font-ipa);
      font-size: 1.2rem;
      padding: 0.4rem 0.6rem;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: var(--ilya-text-secondary);
    }
    
    .syllable-display-header .syllable-btn:hover {
      background: var(--ilya-accent-light);
      border-color: var(--ilya-accent);
      color: var(--ink-primary);
    }
    
    .syllable-display-header .syllable-btn.stressed {
      background: var(--ilya-accent);
      color: white;
      border-color: var(--ilya-accent);
      font-weight: 500;
    }
    
    .syllable-display-header .syllable-btn.stressed:hover {
      background: var(--ilya-accent-hover);
    }
    
    /* Customized state indicator (boundaries adjusted) */
    .syllable-display-header.customized .syllable-btn {
      color: var(--ilya-accent);
    }
    
    .syllable-display-header.customized .syllable-btn.stressed {
      color: white;
    }

    .popup-cyrillic {
      font-family: 'Noto Serif', serif;
      font-size: 1.35rem;
      font-weight: 500;
      color: var(--ink-primary);
      text-align: center;
      margin-bottom: 0.75rem;
    }

    .gloss-section {
      text-align: center;
      margin-bottom: 1rem;
    }

    .gloss-inline {
      font-family: 'Noto Serif', serif;
      font-size: 1rem;
      font-style: italic;
      color: var(--ilya-accent);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      display: inline-block;
      min-width: 140px;
      background: var(--ilya-accent-light);
      border: 1px dashed rgba(122, 158, 126, 0.3);
      transition: all 150ms var(--ease);
    }

    .gloss-inline:hover {
      background: rgba(122, 158, 126, 0.15);
      border-color: var(--ilya-accent);
    }

    .gloss-inline:focus {
      outline: none;
      background: rgba(122, 158, 126, 0.15);
      border-style: solid;
      border-color: var(--ilya-accent);
      box-shadow: 0 0 0 2px var(--ilya-accent-light);
    }

    /* When gloss has content, make it look settled but keep sage */
    .gloss-inline:not(:empty) {
      background: transparent;
      border-color: transparent;
      color: var(--ilya-accent);
    }

    .gloss-inline:not(:empty):hover {
      background: var(--ilya-accent-light);
      border-color: transparent;
    }

    .gloss-inline:empty::before {
      content: attr(data-placeholder);
      color: var(--ilya-accent);
      opacity: 0.7;
      font-style: italic;
    }

    /* ========================================
       REFINE ANALYSIS PANEL (v5.5)
       Content First, Control Second redesign
       ======================================== */
    
    /* ========================================
       POPUP FOOTER CONTROLS (v5.11 - Flat Structure)
       Replaces accordion with contextual rows
       ======================================== */
    
    .popup-footer-controls {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .footer-control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--ilya-binding);
      border-radius: 8px;
      font-size: 0.85rem;
    }
    
    .footer-label {
      color: var(--ilya-text-secondary);
      font-weight: 500;
    }
    
    .footer-label .next-word {
      color: var(--ilya-text-primary);
      font-style: italic;
    }
    
    /* Variant row (ё toggle) */
    .variant-row {
      background: linear-gradient(135deg, var(--ilya-binding) 0%, rgba(122, 158, 126, 0.08) 100%);
    }
    
    .variant-control {
      display: flex;
      gap: 4px;
    }
    
    .variant-control .segment {
      min-width: 36px;
      padding: 6px 12px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .variant-control .segment[data-variant="yo"].active {
      background: var(--ilya-accent);
      color: white;
    }
    
    .variant-control .segment[data-variant="ye"].active {
      background: var(--ilya-text-muted);
      color: white;
    }
    
    /* Assimilation row */
    .assimilation-row {
      background: var(--ilya-binding);
    }
    
    .assimilation-row.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    
    .assimilation-control {
      display: flex;
      gap: 4px;
    }
    
    .assimilation-control .segment {
      padding: 6px 10px;
      font-size: 0.8rem;
    }
    
    /* Toast notification for ё warning */
    .yo-toast {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 10px 16px;
      background: var(--ilya-text-primary);
      color: white;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transform: translateY(100%);
      transition: transform 250ms var(--ease);
      border-radius: 0 0 16px 16px;
      z-index: 10;
    }
    
    .yo-toast.visible {
      transform: translateY(0);
    }
    
    .yo-toast .undo-btn {
      background: transparent;
      border: 1px solid white;
      color: white;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 150ms;
    }
    
    .yo-toast .undo-btn:hover {
      background: rgba(255,255,255,0.15);
    }

    /* Legacy accordion styles - keeping for gradual removal */
    .refine-analysis-toggle {
      display: none; /* Hidden in v5.11 */
    }

    .refine-panel {
      display: none; /* Hidden in v5.11 */
    }

    /* ========================================
       PHONEME RIBBON (v5.5 - Vertical Layout)
       Educational "Why This Transcription?" feature
       ======================================== */
    
    .phoneme-ribbon {
      margin-top: 0.75rem;
      padding: 0 8px;
    }
    
    /* ========================================
       VERTICAL RIBBON (v5.5)
       Replaces horizontal ribbon-grid
       ======================================== */
    
    .ribbon-vertical {
      --ribbon-inline-padding: 12px;
      --syllable-gap: 16px;
      --stressed-tint-opacity: 0.08;
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 8px 0;
      /* Allow overlays to extend beyond container */
      overflow: visible;
    }
    
    /* Phoneme row - minimum 44px for tap targets */
    .phoneme-row {
      position: relative;
      display: flex;
      align-items: center;
      min-height: 44px;
      padding: 0 var(--ribbon-inline-padding);
      cursor: pointer;
      border-radius: 4px;
      transition: background 150ms var(--ease);
    }
    
    .phoneme-row:hover {
      background: rgba(122, 158, 126, 0.06);
    }
    
    .phoneme-row:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 1px;
    }
    
    /* Metrical spacing between syllables */
    .phoneme-row[data-syllable-start="true"] {
      margin-top: var(--syllable-gap);
    }
    
    .phoneme-row[data-syllable-start="true"]:first-child,
    .stressed-syllable-region:first-child {
      margin-top: 0;
    }
    
    /* Stressed syllable region - subtle tint with soft radius */
    .stressed-syllable-region {
      background: rgba(122, 158, 126, var(--stressed-tint-opacity));
      border-radius: 6px;
      padding: 6px 0;
      margin: var(--syllable-gap) calc(var(--ribbon-inline-padding) * -0.5) 0;
    }
    
    .stressed-syllable-region:first-child {
      margin-top: 0;
    }
    
    .stressed-syllable-region .phoneme-row {
      padding: 0 calc(var(--ribbon-inline-padding) + 6px);
    }
    
    .stressed-syllable-region .phoneme-row[data-syllable-start="true"] {
      margin-top: 0;
    }
    
    /* Featured ribbon entry (tie bar for clitics) */
    .phoneme-row.featured-entry {
      background: rgba(107, 124, 110, 0.08);
      border-left: 3px solid var(--ilya-accent);
      margin-left: -0.75rem;
      padding-left: calc(0.75rem - 3px);
      margin-bottom: 0.75rem;
    }
    
    .phoneme-row.featured-entry .phoneme-blurb-overlay {
      background: rgba(107, 124, 110, 0.06);
    }
    
    .phoneme-row.featured-entry .blurb-text {
      line-height: 1.5;
    }
    
    /* Phoneme row content wrapper for grid animation */
    .phoneme-row-content {
      display: grid;
      grid-template-rows: auto 0fr;
      width: 100%;
      transition: grid-template-rows 200ms var(--ease);
    }
    
    .phoneme-row.expanded .phoneme-row-content {
      grid-template-rows: auto 1fr;
    }
    
    /* Typography hierarchy */
    .phoneme-mapping {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-height: 32px;
    }
    
    /* Ensure clicks pass through to parent row */
    .phoneme-cyr,
    .phoneme-arrow,
    .phoneme-ipa {
      pointer-events: none;
    }
    
    .phoneme-cyr {
      font-family: 'Noto Serif', serif;
      color: var(--ilya-text-muted);
      width: 20px;
      font-size: 0.95rem;
    }
    
    .phoneme-arrow {
      color: var(--ilya-text-caption);
      font-size: 0.75rem;
      opacity: 0.5;
    }
    
    .phoneme-ipa {
      font-family: var(--font-ipa);
      color: var(--ilya-text-primary);
      font-size: 0.95rem;
    }
    
    /* Silent letter styling (deletion clusters) */
    .phoneme-row.silent-letter .phoneme-cyr {
      color: var(--ilya-text-caption);
    }
    
    .phoneme-row.silent-letter .phoneme-ipa {
      color: var(--ilya-text-caption);
      font-style: italic;
      font-family: var(--font-sans);
      font-size: 0.8rem;
    }
    
    /* Cluster box - full perimeter groups merged letters (v5.11.29) */
    /* ==========================================================================
       CLUSTER TWO-LAYER ARCHITECTURE (v5.11.30)
       Base layer: rows with hidden chevron/IPA
       Overlay layer: tight perimeter + connector + blurb bubble
       ========================================================================== */
    
    /* Cluster group wrapper - structural only, no visual border */
    .cluster-group {
      position: relative;
    }
    
    /* Cluster member rows - chevron/IPA hidden */
    .cluster-group .phoneme-row {
      min-height: 44px; /* Preserve row height for positioning */
    }
    
    .cluster-group .phoneme-row .phoneme-arrow,
    .cluster-group .phoneme-row .phoneme-ipa {
      visibility: hidden;
    }
    
    /* Cluster perimeter - positioned over orthography column only */
    .cluster-perimeter {
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 36px; /* Tight around orthography */
      border: 2px solid var(--ilya-accent);
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 150ms ease;
    }
    
    .cluster-group.active .cluster-perimeter {
      opacity: 1;
      border-width: 3px;
    }
    
    /* Always show subtle perimeter at rest */
    .cluster-group .cluster-perimeter {
      opacity: 1;
      border-color: var(--ilya-accent);
    }
    
    /* Cluster overlay container - holds connector + bubble */
    .cluster-overlay-container {
      position: absolute;
      left: 48px; /* Right of perimeter (4px + 36px + 8px gap) */
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 150ms ease;
    }
    
    .cluster-group.active .cluster-overlay-container {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* Connector beam */
    .cluster-connector {
      width: 20px;
      height: 2px;
      background: var(--ilya-accent);
      flex-shrink: 0;
    }
    
    /* Blurb bubble */
    .cluster-bubble {
      background: white;
      border: 2px solid var(--ilya-accent);
      border-radius: 4px;
      padding: 12px 16px;
      min-width: 200px;
      max-width: 280px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .cluster-bubble .cluster-merged-ipa {
      font-family: var(--font-ipa);
      font-size: 1.2rem;
      color: var(--ilya-text-primary);
      text-align: center;
      padding-bottom: 8px;
      margin-bottom: 8px;
      border-bottom: 1px solid rgba(122, 158, 126, 0.2);
    }
    
    .cluster-bubble .cluster-blurb-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: var(--ilya-text-secondary);
    }
    
    .cluster-bubble .cluster-blurb-citation {
      font-size: 0.75rem;
      color: var(--ilya-text-caption);
      margin-top: 8px;
      font-style: italic;
    }
    
    /* Mobile: stack vertically */
    @media (max-width: 768px) {
      .cluster-overlay-container {
        left: 50%;
        top: 100%;
        transform: translateX(-50%);
        flex-direction: column;
        margin-top: 8px;
      }
      
      .cluster-connector {
        width: 2px;
        height: 12px;
      }
      
      .cluster-bubble {
        max-width: calc(100vw - 48px);
      }
    }
    
    /* ==========================================================================
       END CLUSTER TWO-LAYER ARCHITECTURE
       ========================================================================== */

    /* Blurb content (accordion) */
    .phoneme-blurb {
      overflow: hidden;
      min-height: 0;
    }
    
    .phoneme-blurb-inner {
      padding: 8px 0 4px 28px;
      border-top: 1px solid rgba(122, 158, 126, 0.15);
      margin-top: 6px;
    }
    
    .blurb-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: var(--ilya-text-secondary);
      margin-bottom: 4px;
    }
    
    .blurb-citation {
      font-size: 0.75rem;
      font-style: italic;
      color: var(--ilya-text-caption);
    }
    
    /* Mobile: ribbon scroll temporarily disabled for overlay support
    @media (max-width: 768px) {
      .ribbon-vertical {
        max-height: 50vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
    }
    */
    
    /* ========================================
       FLOATING BLURB OVERLAY (v5.5)
       "Inline Overlay" pattern per Kimi's design
       Scholarly annotation without layout shift
       ======================================== */
    
    /* Backdrop: white fade behind active blurb */
    .ribbon-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.7);
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms var(--ease);
      z-index: 5;
      border-radius: 6px;
    }
    
    .ribbon-backdrop.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* Fade other rows when a blurb is active - keep them readable */
    .ribbon-vertical.has-active-blurb .phoneme-row:not(.expanded) {
      opacity: 0.6;
      transition: opacity 200ms var(--ease);
    }
    
    /* Expanded row stays prominent */
    .ribbon-vertical.has-active-blurb .phoneme-row.expanded {
      z-index: 6;
      opacity: 1;
      filter: none;
    }
    
    /* Expanded row gets subtle highlight */
    .phoneme-row.expanded {
      background: rgba(122, 158, 126, 0.1);
      border-radius: 4px;
    }
    
    /* The floating blurb overlay */
    .phoneme-blurb-overlay {
      position: absolute;
      top: calc(100% + 4px);
      left: -6px;
      right: -6px;
      background: #FAFAF8;
      border: 2px solid var(--ilya-accent);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06),
                  0 2px 8px rgba(122, 158, 126, 0.1);
      padding: 16px;
      z-index: 10;
      min-height: 60px;
      max-height: 200px;
      overflow-y: auto;
      
      /* Hidden by default */
      opacity: 0;
      pointer-events: none;
      transform: scale(0.98) translateY(4px);
      transition: opacity 200ms var(--ease),
                  transform 200ms var(--ease);
    }
    
    /* When row is expanded, show overlay */
    .phoneme-row.expanded .phoneme-blurb-overlay {
      opacity: 1;
      pointer-events: auto;
      transform: scale(1) translateY(0);
    }
    
    /* Expand upward variant (for rows in bottom half) */
    .phoneme-blurb-overlay.expand-upward {
      top: auto;
      bottom: 100%;
    }
    
    /* Blurb content styling within overlay */
    .phoneme-blurb-overlay .blurb-text {
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--ilya-text-primary);
      margin-bottom: 8px;
    }
    
    .phoneme-blurb-overlay .blurb-citation {
      font-size: 0.8rem;
      font-style: italic;
      color: var(--ilya-accent);
    }
    
    /* ========================================
       COMPACT MODULES (v5.4.2)
       Shared pattern for Stress Source & Phrase Boundary
       ======================================== */
    
    .stress-source-module,
    .phrase-boundary-module {
      margin-bottom: 0.5rem;
      padding: 0 8px;
      box-sizing: border-box;
    }
    
    .module-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.3rem;
    }
    
    .module-label {
      font-size: 0.7rem;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    
    .staged-indicator {
      font-size: 0.75rem;
      color: #9CA3AF;
      opacity: 0;
      transition: opacity 150ms var(--ease);
    }
    
    .staged-indicator.visible {
      opacity: 1;
    }
    
    /* Segmented Control */
    .segmented-control {
      display: flex;
      background: #F3F4F6;
      border-radius: 6px;
      padding: 2px;
      gap: 2px;
    }
    
    .segment {
      flex: 1;
      padding: 0.35rem 0.4rem;
      font-size: 0.7rem;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
      box-sizing: border-box;
    }
    
    .segment:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    /* Active/committed segment */
    .segment.active {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
    }
    
    /* Staged segment (pending, not yet committed) */
    .segment.staged {
      background: white;
      color: var(--ink-secondary);
      outline: 1px dashed #9CA3AF;
      outline-offset: -2px;
    }
    
    /* Committed segment (saved) */
    .segment.committed {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      outline: 1px solid var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* ========================================
       SHARED COMMIT FOOTER (v5.4.2)
       Fixed height, always present
       ======================================== */
    
    .shared-commit-footer {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 0.75rem;
      height: 36px;
      padding: 0 8px;
      margin-top: 0.5rem;
      opacity: 0.4;
      transition: opacity 150ms var(--ease);
    }
    
    .shared-commit-footer.has-changes {
      opacity: 1;
    }
    
    .shared-commit-footer .apply-btn,
    .shared-commit-footer .revert-btn {
      font-size: 0.75rem;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }
    
    .shared-commit-footer .apply-btn {
      background: var(--ilya-accent);
      color: white;
      border: none;
    }
    
    .shared-commit-footer .apply-btn:hover {
      background: var(--ilya-accent-dark, #5a8a5e);
    }
    
    .shared-commit-footer .revert-btn {
      background: transparent;
      color: var(--ink-secondary);
      border: 1px solid rgba(26, 22, 18, 0.15);
    }
    
    .shared-commit-footer .revert-btn:hover {
      border-color: var(--ink-secondary);
    }
    
    /* Hairline separator between modules - HIDDEN IN v5.11 */
    .phrase-boundary-module {
      display: none !important; /* Hidden in v5.11 (moved to assimilation row) */
      padding-top: 0.5rem;
      border-top: 1px solid #E5E7EB;
    }
    
    /* ё toggle module - HIDDEN IN v5.11 (moved to variant row) */
    .yo-toggle-module {
      display: none !important; /* Hidden in v5.11 */
      margin-bottom: 0.5rem;
      padding: 0.5rem 8px 0;
      border-top: 1px solid #E5E7EB;
      box-sizing: border-box;
    }
    
    .yo-toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    
    .yo-current-form {
      font-family: 'Noto Serif', Georgia, serif;
      font-size: 1rem;
      color: var(--ink-primary);
    }
    
    .yo-toggle-btn {
      padding: 0.35rem 0.6rem;
      font-size: 0.75rem;
      background: transparent;
      border: 1px solid var(--ilya-border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
    }
    
    .yo-toggle-btn:hover {
      border-color: var(--ilya-accent);
      color: var(--ilya-accent);
    }
    
    .yo-toggle-btn:active {
      transform: scale(0.97);
      transition: transform 50ms ease-out;
    }
    
    .yo-toggle-btn:focus {
      outline: 2px solid var(--ilya-accent-light);
      outline-offset: 1px;
    }
    
    .yo-warning {
      margin-top: 0.35rem;
      font-size: 0.7rem;
      color: var(--ilya-warning);
      font-style: italic;
    }
    
    /* Popup content crossfade for ё toggle (v5.8.1) */
    .popup-body {
      transition: opacity 120ms ease-out;
    }
    
    .popup-body.fading {
      opacity: 0.3;
      transition: opacity 80ms ease-out;
    }

    /* Old restore-link kept for compatibility */
    .restore-link {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem;
      background: none;
      border: none;
      font-family: 'Noto Sans', sans-serif;
      font-size: 0.7rem;
      color: var(--ilya-accent);
      cursor: pointer;
      transition: opacity 150ms var(--ease);
    }

    .restore-link:hover {
      opacity: 0.7;
    }
    
    .restore-link:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .restore-link svg {
      width: 12px;
      height: 12px;
    }

    .restore-link-wrapper {
      display: flex;
      justify-content: flex-end;
      width: 100%;
    }

    .citation {
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .citation-rule {
      color: var(--ink-primary);
    }

    .citation-ref {
      color: var(--ink-secondary);
      font-style: italic;
    }

    /* ========================================
       DASHBOARD: Split Layout (Desktop ≥768px)
       ======================================== */
    
    /* Mobile tabs navigation */
    .drawer-tabs {
      display: none;
      border-bottom: 1px solid var(--ilya-border);
      background: var(--ilya-binding);
    }
    
    .drawer-tab {
      flex: 1;
      padding: var(--space-md);
      font-size: var(--text-sm);
      font-weight: 500;
      color: var(--ilya-text-secondary);
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      transition: all var(--duration-fast) var(--ease-out);
    }
    
    .drawer-tab.active {
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border-bottom-color: var(--ilya-accent);
    }
    
    .drawer-tab:hover:not(.active) {
      background: rgba(122, 158, 126, 0.05);
    }
    
    .drawer-tab:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* Drawer zones container */
    .drawer-zones {
      display: flex;
      flex-direction: row;
      flex: 1;
      min-height: 0;
    }
    
    /* Input zone (text area side) */
    .input-zone {
      flex: 2;
      display: flex;
      flex-direction: column;
      padding: var(--space-lg);
      background: var(--ilya-paper);
      border-right: 1px solid var(--ilya-border-light);
      overflow-y: auto;
    }
    
    /* Dashboard zone (metadata side) */
    .dashboard-zone {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: var(--space-lg);
      background: var(--ilya-binding);
      overflow-y: auto;
      gap: var(--space-md);
    }
    
    /* Mobile: stacked with tabs */
    @media (max-width: 767px) {
      .drawer-tabs {
        display: flex;
      }
      
      .drawer-zones {
        flex-direction: column;
      }
      
      .input-zone {
        border-right: none;
        flex: 1;
      }
      
      .dashboard-zone {
        flex: 1;
      }
      
      .input-zone.hidden,
      .dashboard-zone.hidden {
        display: none;
      }
    }
    
    /* ========================================
       DASHBOARD: Form Components
       ======================================== */
    .form-group {
      margin-bottom: var(--space-md);
    }
    
    .form-label {
      display: block;
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--ilya-text-secondary);
      margin-bottom: var(--space-sm);
    }
    
    .form-input {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      transition: all var(--duration-fast) var(--ease-out);
    }
    
    .form-input:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .form-input::placeholder {
      color: var(--ilya-text-muted);
    }
    
    .form-hint {
      font-size: 10px;
      color: var(--ilya-text-muted);
      margin-top: 4px;
      font-style: italic;
    }
    
    /* ========================================
       DASHBOARD: Searchable Select
       ======================================== */
    .searchable-select {
      position: relative;
      width: 100%;
    }
    
    .select-trigger {
      width: 100%;
      padding: var(--space-md);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all var(--duration-fast) var(--ease-out);
      text-align: left;
    }
    
    .select-trigger:hover {
      border-color: var(--ilya-border-focus);
    }
    
    .select-trigger.active {
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .select-trigger .chevron-down {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .select-trigger.active .chevron-down {
      transform: rotate(180deg);
    }
    
    .select-trigger .placeholder {
      color: var(--ilya-text-muted);
    }
    
    .select-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      box-shadow: var(--ilya-shadow-md);
      z-index: 100;
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
      transition: all var(--duration-base) var(--ease-out);
    }
    
    .select-dropdown.open {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }
    
    .select-search {
      width: 100%;
      padding: var(--space-md);
      border: none;
      border-bottom: 1px solid var(--ilya-border-light);
      font-size: var(--text-sm);
      font-family: var(--font-sans);
    }
    
    .select-search:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .select-option {
      padding: var(--space-md);
      cursor: pointer;
      border-bottom: 1px solid var(--ilya-border-light);
      transition: background var(--duration-fast) var(--ease-out);
    }
    
    .select-option:last-child {
      border-bottom: none;
    }
    
    .select-option:hover,
    .select-option.highlighted {
      background: var(--ilya-accent-light);
    }
    
    .select-option .primary {
      display: block;
      font-weight: 500;
      color: var(--ilya-text-primary);
    }
    
    .select-option .secondary {
      display: block;
      font-size: var(--text-xs);
      color: var(--ilya-text-caption);
      margin-top: 2px;
    }
    
    .select-option.custom {
      font-style: italic;
      color: var(--ilya-text-secondary);
      border-top: 2px solid var(--ilya-border);
    }
    
    .custom-warning {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      font-size: var(--text-xs);
      color: var(--ilya-warning);
      margin-top: var(--space-sm);
      padding: var(--space-sm);
      background: rgba(212, 163, 115, 0.1);
      border-radius: 4px;
    }
    
    /* ========================================
       DASHBOARD: Profile Section
       ======================================== */
    .profile-section {
      margin-top: auto;
      border-top: 1px solid var(--ilya-border);
      padding-top: var(--space-lg);
    }
    
    .profile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: var(--space-sm) 0;
    }
    
    .profile-header:hover {
      opacity: 0.8;
    }
    
    .profile-title {
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--ilya-text-secondary);
    }
    
    .profile-active {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
    }
    
    .profile-chevron {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .profile-section.expanded .profile-chevron {
      transform: rotate(180deg);
    }
    
    .profile-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-base) var(--ease-out),
                  opacity var(--duration-base) var(--ease-out);
      opacity: 0;
    }
    
    .profile-section.expanded .profile-content {
      max-height: 300px;
      opacity: 1;
    }
    
    .profile-select {
      width: 100%;
      padding: var(--space-md);
      margin: var(--space-md) 0;
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      cursor: pointer;
    }
    
    .profile-select:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .profile-description {
      display: flex;
      gap: var(--space-sm);
      font-size: var(--text-sm);
      font-family: var(--font-ipa);
      color: var(--ilya-text-secondary);
      line-height: 1.5;
      padding: var(--space-md);
      background: var(--ilya-paper);
      border-radius: 6px;
    }
    
    .info-icon-circle {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      font-style: italic;
      font-family: var(--font-sans);
      color: var(--ilya-accent);
      border: 1.5px solid var(--ilya-accent);
      border-radius: 50%;
      opacity: 0.7;
    }
    
    .profile-future {
      display: none; /* Hidden until multiple profiles implemented */
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
      margin-top: var(--space-md);
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    /* ========================================
       DOCUMENT SECTION (v5.8.2)
       Paper size selection in dashboard
       ======================================== */
    .document-section {
      margin-top: var(--space-lg);
      border-top: 1px solid var(--ilya-border);
      padding-top: var(--space-lg);
    }
    
    .document-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: var(--space-sm) 0;
    }
    
    .document-header:hover {
      opacity: 0.8;
    }
    
    .document-title {
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--ilya-text-secondary);
    }
    
    .document-active {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
    }
    
    .document-pages {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
      margin-left: 8px;
    }
    
    .document-pages::before {
      content: "•";
      margin-right: 8px;
    }
    
    .document-chevron {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .document-section.expanded .document-chevron {
      transform: rotate(180deg);
    }
    
    .document-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-base) var(--ease-out),
                  opacity var(--duration-base) var(--ease-out);
      opacity: 0;
    }
    
    .document-section.expanded .document-content {
      max-height: 150px;
      opacity: 1;
    }
    
    /* Paper size segmented control */
    .paper-size-control {
      display: flex;
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      padding: 3px;
      gap: 3px;
      margin: var(--space-md) 0;
    }
    
    .paper-size-btn {
      flex: 1;
      padding: 0.5rem 0.75rem;
      font-size: var(--text-sm);
      font-weight: 500;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
      min-height: 44px;
    }
    
    .paper-size-btn:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    .paper-size-btn.active {
      background: var(--ink-primary);
      color: white;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    }
    
    .paper-size-label {
      display: block;
      font-weight: 500;
    }
    
    .paper-size-dims {
      display: block;
      font-size: var(--text-xs);
      opacity: 0.7;
      margin-top: 2px;
    }
    
    /* Export section (v5.9.8) */
    .export-section {
      margin-top: var(--space-lg);
      padding-top: var(--space-lg);
      border-top: 1px solid var(--ilya-border-light);
    }
    
    .export-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 16px;
      background: var(--stationery-sage);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: var(--text-sm);
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms var(--ease);
      min-height: 44px;
    }
    
    .export-btn:hover {
      background: #7a8a6d;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(139, 154, 125, 0.3);
    }
    
    .export-btn:active {
      transform: translateY(0);
    }
    
    .export-btn:disabled {
      background: var(--ilya-border);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .export-icon {
      width: 18px;
      height: 18px;
    }
    
    /* IPA text styling */
    .ipa-text {
      font-family: var(--font-ipa);
      font-size: 1.05em;
    }

    /* ========================================
       PRINT STYLES
       ======================================== */
    @media print {
      /* Hide all UI elements */
      .input-drawer,
      .popup-overlay,
      .dashboard-zone,
      .drawer-handle,
      .tab-bar,
      .input-zone,
      .drawer-tabs {
        display: none !important;
      }

      /* Reset body and aperture */
      body {
        background: white !important;
        padding: 0;
        margin: 0;
      }
      
      .display-container {
        display: block;
        padding: 0;
        margin: 0;
      }
      
      .paper-aperture {
        padding: 0;
        overflow: visible;
        box-shadow: none;
        display: block;
        background: white;
        width: 100%;
      }

      /* Paper stack: no gaps, visible overflow */
      .paper-stack {
        gap: 0;
        padding: 0;
        display: block;
      }

      /* Individual pages - WYSIWYG fix (v5.11.6)
         Force each paper-page to be one physical page */
      .paper-page {
        page-break-after: always;
        page-break-inside: avoid;
        break-after: page;
        break-inside: avoid;
        box-shadow: none !important;
        margin: 0;
        padding: 0.5in 0.75in;
        width: 8.5in;
        min-height: 11in;
        height: 11in;  /* Force full page height */
        overflow: visible;  /* But don't clip if slightly over */
        background: white;
        box-sizing: border-box;
        position: relative;
      }
      
      /* Last page shouldn't force a trailing blank */
      .paper-page:last-child {
        page-break-after: auto;
        break-after: auto;
      }
      
      /* A4: 210mm × 297mm */
      .paper-page[data-size="a4"] {
        width: 210mm;
        min-height: 297mm;
        height: 297mm;
        padding: 12.7mm 15mm;
      }
      
      /* Hide watermark in print */
      .paper-page[data-template="subsequent"]::before {
        display: none;
      }

      /* Word stacks: no hover effects */
      .word-stack {
        cursor: default;
        background: transparent !important;
      }

      .word-stack:hover {
        background: none !important;
        box-shadow: none !important;
      }

      /* Verse lines: avoid breaking mid-line */
      .verse-line {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      
      /* Footer: align with page content area (v5.11.6) */
      .page-footer {
        position: absolute;
        bottom: 0;
        left: 0.75in;
        right: 0.75in;
        padding: 12px 0 24px 0;  /* Keep vertical padding only */
      }

      /* Page setup - minimal margins, content has its own padding */
      @page {
        margin: 0;
        size: letter;
      }
      
      @page :first {
        margin: 0;
      }
    }

    /* ========================================
       RESPONSIVE
       ======================================== */
    @media (max-width: 880px) {
      .paper {
        min-height: auto;
      }

      .doc-header {
        padding: 48px 36px 20px;
      }

      .doc-body {
        padding: 20px 36px;
      }

      .doc-footer {
        padding: 20px 36px 36px;
      }
    }

    @media (max-width: 480px) {
      .doc-header {
        padding: 36px 24px 16px;
      }

      .doc-body {
        padding: 16px 24px;
      }

      .doc-footer {
        padding: 16px 24px 24px;
      }

      .doc-title {
        font-size: 1.25rem;
      }

      .word-stack .cyrillic {
        font-size: 1.1rem;
      }

      .word-stack .ipa {
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body class="notranslate">

  <div class="display-container">
    
    <!-- Paper Aperture: Viewing area with inset depth -->
    <main class="paper-aperture" id="paperAperture">
      
      <!-- Paper Stack: Multi-page container (v5.9.4) -->
      <div class="paper-stack" id="paperStack">
        
        <!-- Pages render here dynamically -->
        
      </div>

    </main>

    <!-- Input Drawer: Bottom-anchored, collapsible -->
    <aside class="input-drawer expanded" id="inputDrawer">
      
      <!-- Handle Bar (always visible, entire bar clickable) -->
      <div class="drawer-handle" 
           id="drawerHandle"
           role="button" 
           tabindex="0" 
           aria-expanded="true"
           aria-controls="drawerContent"
           title="Toggle input drawer">
        
        <!-- Left: Preview (visible when collapsed) -->
        <span class="handle-preview" id="handlePreview"></span>
        
        <!-- Center: Chevron + Label (changes based on state) -->
        <span class="handle-toggle">
          <svg class="chevron" viewBox="0 0 24 24" aria-hidden="true">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
          <span class="handle-label">
            <span class="handle-label-more">show dashboard</span>
            <span class="handle-label-less">hide dashboard</span>
          </span>
        </span>
        
      </div>
      
      <!-- Mobile Tabs (visible <768px) -->
      <div class="drawer-tabs" id="drawerTabs">
        <button class="drawer-tab active" data-tab="text">Text</button>
        <button class="drawer-tab" data-tab="details">Details</button>
      </div>
      
      <!-- Drawer Content (hidden when collapsed) -->
      <div class="drawer-content" id="drawerContent">
        
        <div class="drawer-zones">
          
          <!-- Input Zone (2/3 on desktop, tab on mobile) -->
          <div class="input-zone" id="inputZone">
            <!-- Textarea -->
            <textarea 
              class="drawer-textarea" 
              id="textInput" 
              placeholder="Paste or type Russian Cyrillic text here..."
              aria-label="Russian text input"
            ></textarea>
            
            <!-- Footer row: status left, buttons right -->
            <div class="drawer-footer">
              <div class="footer-status" aria-live="polite">
                <span class="char-counter" id="charCounter"></span>
                <span class="auto-saved" id="autoSaved">Saved</span>
                <span class="ocr-status" id="ocrStatus" style="display: none;">
                  <svg class="spinner" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" stroke-opacity="0.25"/>
                    <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
                  </svg>
                  <span class="ocr-status-text"></span>
                </span>
              </div>
              <div class="footer-actions">
                <!-- Hidden file input for OCR -->
                <input type="file" 
                       id="ocrFileInput" 
                       accept="image/*" 
                       capture="environment"
                       aria-hidden="true"
                       style="display: none;">
                <button class="btn btn-secondary" id="clearBtn">Clear</button>
                <button class="btn btn-secondary" id="ocrScanBtn" 
                        aria-label="Import Russian text from image"
                        disabled
                        title="Loading Russian language pack...">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                  </svg>
                  Scan
                </button>
                <button class="btn btn-primary" id="transcribeBtn">Transcribe</button>
              </div>
            </div>
          </div>
          
          <!-- Dashboard Zone (1/3 on desktop, tab on mobile) -->
          <div class="dashboard-zone hidden" id="dashboardZone">
            
            <!-- Title -->
            <div class="form-group">
              <input type="text" class="form-input" id="metaTitle" placeholder="Title">
            </div>
            
            <!-- Opus -->
            <div class="form-group">
              <input type="text" class="form-input" id="metaOpus" placeholder="Opus / Catalogue">
            </div>
            
            <!-- Composer (searchable select) -->
            <div class="form-group">
              <div class="searchable-select" id="composerSelect">
                <button type="button" class="select-trigger" id="composerTrigger">
                  <span class="placeholder">Composer</span>
                  <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
                <div class="select-dropdown" id="composerDropdown">
                  <input type="text" class="select-search" placeholder="Type to filter..." id="composerSearch">
                  <div class="select-options" id="composerOptions"></div>
                </div>
              </div>
            </div>
            
            <!-- Poet (searchable select) -->
            <div class="form-group">
              <div class="searchable-select" id="poetSelect">
                <button type="button" class="select-trigger" id="poetTrigger">
                  <span class="placeholder">Poet / Librettist</span>
                  <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
                <div class="select-dropdown" id="poetDropdown">
                  <input type="text" class="select-search" placeholder="Type to filter..." id="poetSearch">
                  <div class="select-options" id="poetOptions"></div>
                </div>
              </div>
            </div>
            
            <!-- Transcriber Name (for attribution) -->
            <div class="form-group">
              <input type="text" class="form-input" id="metaTranscriber" placeholder="Your name (for attribution)">
              <div class="form-hint">Appears in document footer</div>
            </div>
            
            <!-- Transcription Profile -->
            <div class="profile-section" id="profileSection">
              <div class="profile-header" id="profileHeader">
                <div>
                  <span class="profile-title">Transcription Profile</span>
                  <span class="profile-active" id="profileActive">Old Muscovite</span>
                </div>
                <svg class="profile-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </div>
              <div class="profile-content">
                <select class="profile-select" id="profileSelect">
                  <option value="old-muscovite" selected>Old Muscovite</option>
                  <option value="peterburgian">Peterburgian</option>
                  <option value="choral">Choral</option>
                </select>
                <div class="profile-description" id="profileDescription">
                  <span class="info-icon-circle">i</span>
                  <span>Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]</span>
                </div>
                <div class="profile-future">View all profiles →</div>
              </div>
            </div>
            
            <!-- Document Settings (v5.8.2) -->
            <div class="document-section" id="documentSection">
              <div class="document-header" id="documentHeader">
                <div>
                  <span class="document-title">Page</span>
                  <span class="document-active" id="documentActive">Letter (8.5×11)</span>
                  <span class="document-pages" id="pageNumber">1 page</span>
                </div>
                <svg class="document-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </div>
              <div class="document-content">
                <div class="paper-size-control" id="paperSizeControl">
                  <button type="button" class="paper-size-btn active" data-size="letter" id="paperSizeLetter">
                    <span class="paper-size-label">Letter</span>
                    <span class="paper-size-dims">8.5 × 11 in</span>
                  </button>
                  <button type="button" class="paper-size-btn" data-size="a4" id="paperSizeA4">
                    <span class="paper-size-label">A4</span>
                    <span class="paper-size-dims">210 × 297 mm</span>
                  </button>
                </div>
              </div>
            </div>
            
            <!-- Export (v5.9.8) -->
            <div class="export-section">
              <button type="button" class="export-btn" id="exportPdfBtn">
                <svg class="export-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                  <polyline points="14 2 14 8 20 8"></polyline>
                  <line x1="12" y1="18" x2="12" y2="12"></line>
                  <line x1="9" y1="15" x2="12" y2="12"></line>
                  <line x1="15" y1="15" x2="12" y2="12"></line>
                </svg>
                <span>Export PDF</span>
              </button>
              <div class="form-hint">Opens print dialog. Select "Save as PDF".</div>
            </div>
            
          </div>
          
        </div>
        
      </div>
      
    </aside>

  </div>

  <!-- Popup Overlay -->
  <div class="popup-overlay" id="popupOverlay">
    <div class="popup-backdrop" id="popupBackdrop"></div>
    <div class="popup-card" id="popupCard">
      <div class="popup-arrow"></div>
      
      <div class="popup-body">
        <!-- Clitic badge (conditionally shown) -->
        <div class="clitic-badge" id="cliticBadge" style="display: none;">
          <span id="cliticType">Proclitic</span> — attaches phonologically
        </div>
        
        <!-- TIER 1: THE ANSWER (always visible) -->
        <!-- Syllable buttons: interactive IPA display + stress control + consonant drag -->
        <div class="syllable-label" id="syllableLabel"></div>
        <div class="syllable-display-header" id="syllableDisplayHeader">
          <div class="syllable-display" id="syllableDisplay"></div>
        </div>
        <div class="popup-cyrillic" id="popupCyrillic">—</div>
        
        <div class="gloss-section">
          <span 
            class="gloss-inline" 
            id="glossInline"
            contenteditable="true"
            role="textbox"
            aria-label="Translation"
            data-placeholder="add translation"
          ></span>
        </div>
        
        <!-- Phoneme Ribbon (elevated, vertical layout) -->
        <div class="phoneme-ribbon" id="phonemeRibbon">
          <div class="ribbon-vertical" id="ribbonVertical">
            <!-- Populated by JavaScript -->
          </div>
        </div>
        
        <!-- FOOTER CONTROLS (v5.11 - Flat Structure) -->
        <div class="popup-footer-controls">
          
          <!-- Clitic banner (if applicable) - moved out of accordion -->
          <div class="why-clitic-banner" id="whyCliticBanner" style="display: none;"></div>
          
          <!-- Variant row (ё toggle) - only shown if word has е/ё -->
          <div class="footer-control-row variant-row" id="variantRow" style="display: none;">
            <span class="footer-label">Variant:</span>
            <div class="segmented-control variant-control" id="variantButtons">
              <button class="segment" id="variantYo" data-variant="yo">ё</button>
              <button class="segment" id="variantYe" data-variant="ye">е</button>
            </div>
          </div>
          
          <!-- Assimilation row - only shown if not last word in line -->
          <div class="footer-control-row assimilation-row" id="assimilationRow" style="display: none;">
            <span class="footer-label">Link to "<span class="next-word" id="nextWordLabel">—</span>":</span>
            <div class="segmented-control assimilation-control" id="assimilationButtons">
              <button class="segment" id="assimilationLinked" data-boundary="soft">Linked</button>
              <button class="segment" id="assimilationSeparated" data-boundary="hard">Separated</button>
            </div>
          </div>
          
        </div>
        
        <!-- Toast for ё warning -->
        <div class="yo-toast" id="yoToast">
          <span>ё → е changes pronunciation</span>
          <button class="undo-btn" id="yoUndoBtn">Undo</button>
        </div>
        
        <!-- OLD ACCORDION (hidden in v5.11, kept for reference) -->
        <button class="refine-analysis-toggle" id="refineAnalysisToggle" style="display: none;">
          Refine Analysis <span class="disclosure-chevron">▼</span>
        </button>
        
        <div class="refine-panel" id="refinePanel" style="display: none;">
          <div class="refine-panel-inner">
            <!-- Stress source module (will move to provenance badges in v5.12) -->
            <div class="stress-source-module" id="stressSourceModule">
              <div class="module-header">
                <span class="module-label">Stress source</span>
                <span class="staged-indicator" id="stressStagedIndicator">✎</span>
              </div>
              <div class="segmented-control" id="stressSourceButtons">
                <button class="segment" id="stressSourceDictionary" data-source="dictionary" title="Ilya defaults to first-syllable stress for words not in our dictionary. This stress has not been independently verified.">Dictionary</button>
                <button class="segment" id="stressSourceComposer" data-source="composer">Composer</button>
                <button class="segment" id="stressSourceUser" data-source="user">My choice</button>
              </div>
            </div>
            
            <!-- ё toggle module (MOVED to Variant row in v5.11) -->
            <div class="yo-toggle-module" id="yoToggleModule" style="display: none;">
              <div class="module-header">
                <span class="module-label">Spelling</span>
              </div>
              <div class="yo-toggle-row">
                <span class="yo-current-form" id="yoCurrentForm">—</span>
                <button class="yo-toggle-btn" id="yoToggleBtn" title="Toggle ё/е spelling">
                  <span id="yoToggleLabel">—</span>
                </button>
              </div>
              <div class="yo-warning" id="yoWarning" style="display: none;">
                Removing ё may change stress position
              </div>
            </div>
            
            <!-- Phrase boundary module (MOVED to Assimilation row in v5.11) -->
            <div class="phrase-boundary-module" id="phraseBoundaryModule" style="display: none;">
              <div class="module-header">
                <span class="module-label">Phrase boundary</span>
                <span class="staged-indicator" id="boundaryStagedIndicator">✎</span>
              </div>
              <div class="segmented-control" id="boundaryButtons">
                <button class="segment" id="boundaryLinked" data-boundary="soft">Linked</button>
                <button class="segment" id="boundarySeparated" data-boundary="hard">Break after</button>
              </div>
            </div>
            
            <!-- Commit footer -->
            <div class="shared-commit-footer" id="sharedCommitFooter">
              <button class="revert-btn" id="sharedRevertBtn">Revert</button>
              <button class="apply-btn" id="sharedApplyBtn">Apply Changes</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
/* ==================================================
   STRESS DICTIONARY (loaded from external JSON)
   Kaikki.org Wiktionary extract — 416K+ words
   ================================================== */
let STRESS_DICTIONARY = {};
let DICTIONARY_LOADED = false;

// Load dictionary from external gzipped file
async function loadDictionary() {
    try {
        // First try the gzipped version
        let response = await fetch('data/ilya_dictionary.json.gz');
        
        if (response.ok) {
            // Decompress gzipped data using pako
            const compressed = await response.arrayBuffer();
            const decompressed = pako.inflate(new Uint8Array(compressed), { to: 'string' });
            STRESS_DICTIONARY = JSON.parse(decompressed);
            DICTIONARY_LOADED = true;
            console.log(`Dictionary loaded: ${Object.keys(STRESS_DICTIONARY).length.toLocaleString()} words`);
            return;
        }
        
        // Fallback to uncompressed JSON
        response = await fetch('data/ilya_dictionary.json');
        if (response.ok) {
            STRESS_DICTIONARY = await response.json();
            DICTIONARY_LOADED = true;
            console.log(`Dictionary loaded (uncompressed): ${Object.keys(STRESS_DICTIONARY).length.toLocaleString()} words`);
            return;
        }
        
        // Final fallback to old OpenRussian dictionary
        response = await fetch('data/openrussian-dict.json');
        if (response.ok) {
            STRESS_DICTIONARY = await response.json();
            DICTIONARY_LOADED = true;
            console.log(`Legacy dictionary loaded: ${Object.keys(STRESS_DICTIONARY).length.toLocaleString()} words`);
            return;
        }
        
        console.warn('No dictionary file found, stress lookup disabled');
    } catch (error) {
        console.warn('Could not load dictionary:', error);
    }
}

// Start loading dictionary immediately
loadDictionary();

/* ==================================================
   SINGER'S MONOSYLLABLE SUPPLEMENT
   Common words missing from OpenRussian dictionary
   ================================================== */
const SINGER_SUPPLEMENT = {
    // Pronouns
    'я': { stress: 0, gloss: 'I', source: 'supplement' },
    'ты': { stress: 0, gloss: 'you (informal)', source: 'supplement' },
    'он': { stress: 0, gloss: 'he', source: 'supplement' },
    'мы': { stress: 0, gloss: 'we', source: 'supplement' },
    'вы': { stress: 0, gloss: 'you (formal/plural)', source: 'supplement' },
    'мне': { stress: 0, gloss: 'to me', source: 'supplement' },
    'мной': { stress: 0, gloss: 'with me', source: 'supplement' },
    'нам': { stress: 0, gloss: 'to us', source: 'supplement' },
    'вам': { stress: 0, gloss: 'to you', source: 'supplement' },
    'вас': { stress: 0, gloss: 'you (acc.)', source: 'supplement' },
    'нас': { stress: 0, gloss: 'us', source: 'supplement' },
    'кто': { stress: 0, gloss: 'who', source: 'supplement' },
    'что': { stress: 0, gloss: 'what', source: 'supplement' },
    'чём': { stress: 0, gloss: 'what (prep.)', source: 'supplement' },
    'всё': { stress: 0, gloss: 'everything', source: 'supplement' },
    'все': { stress: 0, gloss: 'everyone', source: 'supplement' },
    'сам': { stress: 0, gloss: 'oneself', source: 'supplement' },
    'мой': { stress: 0, gloss: 'my', source: 'supplement' },
    'моя': { stress: 1, gloss: 'my (fem.)', source: 'supplement' },
    'моё': { stress: 1, gloss: 'my (neut.)', source: 'supplement' },
    'моей': { stress: 1, gloss: 'my (gen./dat./prep. fem.)', source: 'supplement' },
    'твой': { stress: 0, gloss: 'your', source: 'supplement' },
    'твоя': { stress: 1, gloss: 'your (fem.)', source: 'supplement' },
    'твоё': { stress: 1, gloss: 'your (neut.)', source: 'supplement' },
    'твоей': { stress: 1, gloss: 'your (gen./dat./prep. fem.)', source: 'supplement' },
    'её': { stress: 1, gloss: 'her/hers', source: 'supplement' },
    'свой': { stress: 0, gloss: 'one\'s own', source: 'supplement' },
    'наш': { stress: 0, gloss: 'our', source: 'supplement' },
    'ваш': { stress: 0, gloss: 'your (formal)', source: 'supplement' },
    'весь': { stress: 0, gloss: 'all/whole', source: 'supplement' },
    'тот': { stress: 0, gloss: 'that', source: 'supplement' },
    'там': { stress: 0, gloss: 'there', source: 'supplement' },
    'тут': { stress: 0, gloss: 'here', source: 'supplement' },
    'где': { stress: 0, gloss: 'where', source: 'supplement' },
    
    // Particles & Negation
    'не': { stress: 0, gloss: 'not', source: 'supplement' },
    'ни': { stress: 0, gloss: 'nor/not a', source: 'supplement' },
    'да': { stress: 0, gloss: 'yes/and', source: 'supplement' },
    'нет': { stress: 0, gloss: 'no', source: 'supplement' },
    'вот': { stress: 0, gloss: 'here is', source: 'supplement' },
    'уж': { stress: 0, gloss: 'already', source: 'supplement' },
    'ещё': { stress: 0, gloss: 'still/yet', source: 'supplement' },
    'уже': { stress: 0, gloss: 'already', source: 'supplement' },
    'так': { stress: 0, gloss: 'so/thus', source: 'supplement' },
    'как': { stress: 0, gloss: 'how/as', source: 'supplement' },
    'чем': { stress: 0, gloss: 'than', source: 'supplement' },
    
    // Prepositions (stressed when standalone)
    'о': { stress: 0, gloss: 'about', source: 'supplement' },
    'об': { stress: 0, gloss: 'about', source: 'supplement' },
    'в': { stress: 0, gloss: 'in/into', source: 'supplement' },
    'во': { stress: 0, gloss: 'in/into', source: 'supplement' },
    'к': { stress: 0, gloss: 'to/toward', source: 'supplement' },
    'ко': { stress: 0, gloss: 'to/toward', source: 'supplement' },
    'с': { stress: 0, gloss: 'with/from', source: 'supplement' },
    'со': { stress: 0, gloss: 'with/from', source: 'supplement' },
    'у': { stress: 0, gloss: 'at/by', source: 'supplement' },
    'на': { stress: 0, gloss: 'on/onto', source: 'supplement' },
    'за': { stress: 0, gloss: 'behind/for', source: 'supplement' },
    'по': { stress: 0, gloss: 'along/by', source: 'supplement' },
    'до': { stress: 0, gloss: 'until/to', source: 'supplement' },
    'из': { stress: 0, gloss: 'from/out of', source: 'supplement' },
    'от': { stress: 0, gloss: 'from', source: 'supplement' },
    'при': { stress: 0, gloss: 'at/by/in presence of', source: 'supplement' },
    'для': { stress: 0, gloss: 'for', source: 'supplement' },
    'без': { stress: 0, gloss: 'without', source: 'supplement' },
    'под': { stress: 0, gloss: 'under', source: 'supplement' },
    'над': { stress: 0, gloss: 'above', source: 'supplement' },
    'про': { stress: 0, gloss: 'about', source: 'supplement' },
    
    // Common verb forms (imperatives, short forms)
    'пой': { stress: 0, gloss: 'sing!', source: 'supplement' },
    'дай': { stress: 0, gloss: 'give!', source: 'supplement' },
    'стой': { stress: 0, gloss: 'stop!/stand!', source: 'supplement' },
    'спи': { stress: 0, gloss: 'sleep!', source: 'supplement' },
    'жди': { stress: 0, gloss: 'wait!', source: 'supplement' },
    'иди': { stress: 0, gloss: 'go!', source: 'supplement' },
    'будь': { stress: 0, gloss: 'be!', source: 'supplement' },
    'знай': { stress: 0, gloss: 'know!', source: 'supplement' },
    'верь': { stress: 0, gloss: 'believe!', source: 'supplement' },
    'жить': { stress: 0, gloss: 'to live', source: 'supplement' },
    'быть': { stress: 0, gloss: 'to be', source: 'supplement' },
    'петь': { stress: 0, gloss: 'to sing', source: 'supplement' },
    'спать': { stress: 0, gloss: 'to sleep', source: 'supplement' },
    'ждать': { stress: 0, gloss: 'to wait', source: 'supplement' },
    'знать': { stress: 0, gloss: 'to know', source: 'supplement' },
    'дать': { stress: 0, gloss: 'to give', source: 'supplement' },
    'стать': { stress: 0, gloss: 'to become', source: 'supplement' },
    'был': { stress: 0, gloss: 'was (m.)', source: 'supplement' },
    'была': { stress: 1, gloss: 'was (f.)', source: 'supplement' },
    'было': { stress: 0, gloss: 'was (n.)', source: 'supplement' },
    'были': { stress: 0, gloss: 'were', source: 'supplement' },
    'сказал': { stress: 1, gloss: 'said/told', source: 'supplement' },
    'думать': { stress: 0, gloss: 'to think', source: 'supplement' },
    'думаю': { stress: 0, gloss: 'I think', source: 'supplement' },
    'думаешь': { stress: 0, gloss: 'you think', source: 'supplement' },
    'есть': { stress: 0, gloss: 'is/to eat', source: 'supplement' },
    
    // Gloss overrides (dictionary glosses too verbose)
    'русский': { stress: 0, pos: 'adj.', gloss: 'Russian', source: 'supplement' },
    
    // Nouns (common in vocal repertoire)
    'ночь': { stress: 0, gloss: 'night', source: 'supplement' },
    'день': { stress: 0, gloss: 'day', source: 'supplement' },
    'путь': { stress: 0, gloss: 'path/way', source: 'supplement' },
    'свет': { stress: 0, gloss: 'light', source: 'supplement' },
    'мир': { stress: 0, gloss: 'world/peace', source: 'supplement' },
    'сон': { stress: 0, gloss: 'dream/sleep', source: 'supplement' },
    'дом': { stress: 0, gloss: 'home/house', source: 'supplement' },
    'сад': { stress: 0, gloss: 'garden', source: 'supplement' },
    'лес': { stress: 0, gloss: 'forest', source: 'supplement' },
    'бог': { stress: 0, gloss: 'god', source: 'supplement' },
    'царь': { stress: 0, gloss: 'tsar', source: 'supplement' },
    'князь': { stress: 0, gloss: 'prince', source: 'supplement' },
    'дух': { stress: 0, gloss: 'spirit', source: 'supplement' },
    'друг': { stress: 0, gloss: 'friend', source: 'supplement' },
    'враг': { stress: 0, gloss: 'enemy', source: 'supplement' },
    'брат': { stress: 0, gloss: 'brother', source: 'supplement' },
    'сын': { stress: 0, gloss: 'son', source: 'supplement' },
    'муж': { stress: 0, gloss: 'husband', source: 'supplement' },
    'жизнь': { stress: 0, gloss: 'life', source: 'supplement' },
    'любовь': { stress: 1, gloss: 'love', source: 'supplement' },
    'любви': { stress: 1, gloss: 'of love', source: 'supplement' },
    'правда': { stress: 0, gloss: 'truth', source: 'supplement' },
    'правду': { stress: 0, gloss: 'truth (acc.)', source: 'supplement' },
    'смерть': { stress: 0, gloss: 'death', source: 'supplement' },
    'боль': { stress: 0, gloss: 'pain', source: 'supplement' },
    'грусть': { stress: 0, gloss: 'sadness', source: 'supplement' },
    'страсть': { stress: 0, gloss: 'passion', source: 'supplement' },
    'честь': { stress: 0, gloss: 'honor', source: 'supplement' },
    'власть': { stress: 0, gloss: 'power', source: 'supplement' },
    'часть': { stress: 0, gloss: 'part', source: 'supplement' },
    'речь': { stress: 0, gloss: 'speech', source: 'supplement' },
    'мысль': { stress: 0, gloss: 'thought', source: 'supplement' },
    'мама': { stress: 0, gloss: 'mama', source: 'supplement' },
    'маме': { stress: 0, gloss: 'to mama', source: 'supplement' },
    'кровь': { stress: 0, gloss: 'blood', source: 'supplement' },
    'грудь': { stress: 0, gloss: 'chest/breast', source: 'supplement' },
    'взор': { stress: 0, gloss: 'gaze', source: 'supplement' },
    'взгляд': { stress: 0, gloss: 'glance', source: 'supplement' },
    'слух': { stress: 0, gloss: 'hearing/rumor', source: 'supplement' },
    'шум': { stress: 0, gloss: 'noise', source: 'supplement' },
    'гром': { stress: 0, gloss: 'thunder', source: 'supplement' },
    'дождь': { stress: 0, gloss: 'rain', source: 'supplement' },
    'снег': { stress: 0, gloss: 'snow', source: 'supplement' },
    'лёд': { stress: 0, gloss: 'ice', source: 'supplement' },
    'огонь': { stress: 0, gloss: 'fire', source: 'supplement' },
    'вода': { stress: 0, gloss: 'water', source: 'supplement' },
    'земля': { stress: 0, gloss: 'earth', source: 'supplement' },
    'край': { stress: 0, gloss: 'edge/land', source: 'supplement' },
    'рай': { stress: 0, gloss: 'paradise', source: 'supplement' },
    'ад': { stress: 0, gloss: 'hell', source: 'supplement' },
    
    // Adjectives (short forms common in poetry)
    'рад': { stress: 0, gloss: 'glad', source: 'supplement' },
    'сыт': { stress: 0, gloss: 'full/sated', source: 'supplement' },
    'злой': { stress: 0, gloss: 'evil/angry', source: 'supplement' },
    'свят': { stress: 0, gloss: 'holy', source: 'supplement' },
    'прав': { stress: 0, gloss: 'right/correct', source: 'supplement' },
    'жив': { stress: 0, gloss: 'alive', source: 'supplement' },
    'мёртв': { stress: 0, gloss: 'dead', source: 'supplement' },
    'нов': { stress: 0, gloss: 'new', source: 'supplement' },
    'стар': { stress: 0, gloss: 'old', source: 'supplement' },
    'юн': { stress: 0, gloss: 'young', source: 'supplement' },
    'мил': { stress: 0, gloss: 'dear/sweet', source: 'supplement' },
    'люб': { stress: 0, gloss: 'beloved', source: 'supplement' },
    
    // Conjunctions & Adverbs
    'но': { stress: 0, gloss: 'but', source: 'supplement' },
    'а': { stress: 0, gloss: 'and/but', source: 'supplement' },
    'и': { stress: 0, gloss: 'and', source: 'supplement' },
    'то': { stress: 0, gloss: 'then/that', source: 'supplement' },
    'же': { stress: 0, gloss: '(emphasis)', source: 'supplement' },
    'ли': { stress: 0, gloss: '(question)', source: 'supplement' },
    'бы': { stress: 0, gloss: 'would', source: 'supplement' },
    'вновь': { stress: 0, gloss: 'again', source: 'supplement' },
    'вдруг': { stress: 0, gloss: 'suddenly', source: 'supplement' },
    'прочь': { stress: 0, gloss: 'away', source: 'supplement' },
    'вниз': { stress: 0, gloss: 'down', source: 'supplement' },
    'вверх': { stress: 0, gloss: 'up', source: 'supplement' },
    'лишь': { stress: 0, gloss: 'only', source: 'supplement' },
    'чуть': { stress: 0, gloss: 'barely', source: 'supplement' },
    'сквозь': { stress: 0, gloss: 'through', source: 'supplement' }
};

/* ==================================================
   GLOSS FORMATTING HELPERS
   Handles verbose grammatical descriptions from kaikki.org
   ================================================== */

/**
 * Extract lemma from grammatical gloss text
 * e.g., "short feminine singular past indicative perfective of уга́снуть (ugásnutʹ)" → "угаснуть"
 */
function extractLemmaFromGloss(gloss) {
    if (!gloss) return null;
    
    // Pattern: "... of CYRILLIC_WORD (transliteration)" or just "... of CYRILLIC_WORD"
    const match = gloss.match(/of\s+([а-яёА-ЯЁ́]+)(?:\s*\(|$|\s|,)/i);
    if (match) {
        // Remove any combining accents from the extracted lemma
        return match[1].normalize('NFD').replace(/[\u0300-\u036f]/g, '').normalize('NFC').toLowerCase();
    }
    return null;
}

/**
 * Look up semantic gloss for a lemma
 */
function getLemmaGloss(lemma) {
    if (!lemma) return null;
    
    const lemmaEntry = STRESS_DICTIONARY[lemma];
    if (!lemmaEntry) return null;
    
    const entryGloss = Array.isArray(lemmaEntry) 
        ? (lemmaEntry[0].gloss || lemmaEntry[0].g || '')
        : (lemmaEntry.gloss || lemmaEntry.g || '');
    
    // Don't return if it's also a grammatical description
    if (entryGloss && !/^(short |inflection |nominative |genitive |dative |accusative |instrumental |prepositional )/i.test(entryGloss)) {
        return entryGloss;
    }
    return null;
}

/**
 * Curated short glosses for common words (Issue P)
 * These override verbose dictionary glosses to maintain column alignment.
 * Key = lemma (base form), so inflected forms inherit the gloss.
 */
const CURATED_GLOSSES = new Map([
    // Personal pronouns
    ['я', 'I'],
    ['ты', 'you'],
    ['он', 'he'],
    ['она', 'she'],
    ['оно', 'it'],
    ['мы', 'we'],
    ['вы', 'you (pl.)'],
    ['они', 'they'],
    // Pronoun oblique forms (when lemma lookup fails)
    ['меня', 'me'],
    ['мне', 'to me'],
    ['мной', 'by me'],
    ['мною', 'by me'],
    ['тебя', 'you'],
    ['тебе', 'you'],
    ['тобой', 'by you'],
    ['тобою', 'by you'],
    ['его', 'him/his'],
    ['него', 'him'],
    ['ему', 'to him'],
    ['нему', 'to him'],
    ['им', 'by him'],
    ['ним', 'him'],
    ['её', 'her'],
    ['неё', 'her'],
    ['ей', 'to her'],
    ['ней', 'her'],
    ['ею', 'by her'],
    ['нею', 'by her'],
    ['нас', 'us'],
    ['нам', 'to us'],
    ['нами', 'by us'],
    ['вас', 'you (pl.)'],
    ['вам', 'to you'],
    ['вами', 'by you'],
    ['их', 'them/their'],
    ['них', 'them'],
    ['ими', 'by them'],
    ['ними', 'them'],
    // Possessives (all genders/cases)
    ['мой', 'my'],
    ['моя', 'my'],
    ['моё', 'my'],
    ['мои', 'my'],
    ['моего', 'my'],
    ['моей', 'my'],
    ['моему', 'my'],
    ['моим', 'my'],
    ['моими', 'my'],
    ['моих', 'my'],
    ['мою', 'my'],
    ['твой', 'your'],
    ['твоя', 'your'],
    ['твоё', 'your'],
    ['твои', 'your'],
    ['твоего', 'your'],
    ['твоей', 'your'],
    ['твоему', 'your'],
    ['твоим', 'your'],
    ['твоими', 'your'],
    ['твоих', 'your'],
    ['твою', 'your'],
    ['свой', 'one\'s own'],
    ['наш', 'our'],
    ['ваш', 'your (pl.)'],
    // Demonstratives
    ['этот', 'this'],
    ['эта', 'this'],
    ['это', 'this/it is'],
    ['эти', 'these'],
    ['тот', 'that'],
    ['та', 'that'],
    ['то', 'that'],
    ['те', 'those'],
    // Interrogatives
    ['что', 'what/that'],
    ['чего', 'what'],
    ['чему', 'to what'],
    ['чем', 'what (instr.)'],
    ['кто', 'who'],
    ['кого', 'whom'],
    ['кому', 'to whom'],
    ['кем', 'by whom'],
    ['чей', 'whose'],
    ['чья', 'whose'],
    ['чьё', 'whose'],
    ['чьи', 'whose'],
    // Common adverbs
    ['где', 'where'],
    ['как', 'how'],
    ['когда', 'when'],
    ['здесь', 'here'],
    ['там', 'there'],
    ['сюда', 'hither'],
    ['туда', 'thither'],
    ['тут', 'here'],
    ['уже', 'already'],
    ['уж', 'already'],
    ['ещё', 'still, yet'],
    ['еще', 'still, yet'],
    // Quantifiers
    ['весь', 'all'],
    ['вся', 'all'],
    ['всё', 'everything'],
    ['все', 'everyone'],
    ['всех', 'all'],
    ['всем', 'all'],
    ['сам', 'oneself'],
    ['сама', 'herself'],
    ['само', 'itself'],
    ['сами', 'themselves'],
    ['один', 'one, alone'],
    ['одна', 'one, alone'],
    ['одно', 'one, alone'],
    // Common verbs
    ['быть', 'to be'],
    ['есть', 'is/to eat'],
    ['нет', 'no/there is no'],
    ['сойти', 'to descend'],
    ['сойдём', 'we will descend'],
    ['сойду', 'I will descend'],
    // Preposition-like
    ['между', 'between'],
    ['меж', 'between'],
    ['ради', 'for the sake of'],
    // Numbers  
    ['два', 'two'],
    ['три', 'three'],
    // Common short words in vocal lit
    ['день', 'day'],
    ['ночь', 'night'],
    ['путь', 'path, way'],
    ['жизнь', 'life'],
    ['смерть', 'death'],
    ['любовь', 'love'],
    ['душа', 'soul'],
    ['сердце', 'heart'],
    ['час', 'hour'],
    ['год', 'year'],
    ['век', 'century, age'],
    
    // Additional common vocab (v5.11.18)
    ['странствие', 'wandering'],
    ['странствии', 'wandering'],
    ['странствия', 'wandering'],
    ['мгновение', 'moment'],
    ['мгновенье', 'moment'],
    ['воспоминание', 'memory'],
    ['воспоминанье', 'memory'],
    ['судьбина', 'fate, destiny'],
    ['провожать', 'to see off'],
    ['провождать', 'to see off'],
    ['угадать', 'to guess'],
    ['годовщина', 'anniversary'],
    ['годовщину', 'anniversary'],
    ['бой', 'battle, fight'],
    ['бою', 'battle'],
    ['волна', 'wave'],
    ['волнах', 'waves'],
    
    // v5.11.21: Additional Станцы vocab
    ['уединённый', 'solitary'],
    ['уединенный', 'solitary'],
    ['патриарх', 'patriarch'],
    ['забвенный', 'forgotten'],
    ['младенец', 'infant'],
    ['младенца', 'infant'],
    ['уступаю', 'I yield'],
    ['уступать', 'to yield'],
    ['тлеть', 'to decay'],
    ['цвести', 'to bloom'],
    ['годину', 'hour, time'],
    ['грядущей', 'coming, future'],
    ['грядущий', 'coming, future'],
    ['соседняя', 'neighboring'],
    ['долина', 'valley'],
    ['охладелый', 'cold, dead'],
    ['прах', 'dust, ashes'],
    ['бесчувственному', 'insensible'],
    ['бесчувственный', 'insensible'],
    ['истлевать', 'to decay'],
    ['предел', 'limit, end'],
    ['пределу', 'limit, end'],
    ['почивать', 'to rest, sleep'],
    ['гробовой', 'grave, deathly'],
    ['гробового', 'grave'],
    ['младая', 'young'],
    ['равнодушная', 'indifferent'],
    ['равнодушный', 'indifferent'],
    ['природа', 'nature'],
    ['краса', 'beauty'],
    ['красою', 'beauty'],
    ['вечною', 'eternal'],
    ['сиять', 'to shine'],
]);

/**
 * Format gloss for word-stack display (minimal, translation only)
 */
function formatGlossForDisplay(gloss, pos, lemma, word) {
    // Check curated glosses first (word form, then lemma)
    if (word && CURATED_GLOSSES.has(word.toLowerCase())) {
        return CURATED_GLOSSES.get(word.toLowerCase());
    }
    if (lemma && CURATED_GLOSSES.has(lemma.toLowerCase())) {
        return CURATED_GLOSSES.get(lemma.toLowerCase());
    }
    
    // Blank for missing glosses: leave space for pencil users (v5.11.20)
    if (!gloss) return '';
    
    // First, try to extract a clean translation from verbose patterns
    const cleanedGloss = extractCleanGloss(gloss);
    
    // Detect verbose grammatical patterns from kaikki.org
    const isGrammatical = /^(short |inflection of|nominative |genitive |dative |accusative |instrumental |prepositional |comparative |superlative )/i.test(cleanedGloss) 
                       || /\b(singular|plural)\s+(of|past|present|future)\b/i.test(cleanedGloss);
    
    if (isGrammatical) {
        // Try lemma field first, then extract from gloss text
        const effectiveLemma = lemma || extractLemmaFromGloss(gloss);
        
        if (effectiveLemma) {
            // Look up lemma's semantic gloss
            const semanticGloss = getLemmaGloss(effectiveLemma);
            if (semanticGloss) {
                return truncateGloss(extractCleanGloss(semanticGloss), 5);
            }
            // Fallback: leave blank for pencil users (no arrow - v5.11.22)
            return '';
        }
        // No lemma found: leave blank
        return '';
    }
    
    // Clean, semantic gloss — truncate to 5 words max for PDF display
    return truncateGloss(cleanedGloss, 5);
}

/**
 * Extract clean translation from verbose dictionary glosses
 * Handles patterns like "Usually translated as 'this'" → "this"
 */
function extractCleanGloss(gloss) {
    if (!gloss) return '';
    
    // Pattern: "translated as X" or "Translated as X" — extract X
    let match = gloss.match(/translated as ["']?([^"'.,;\/]+)/i);
    if (match) return match[1].replace(/["']/g, '').trim();
    
    // Pattern: "diminutive of X: Y" or "augmentative of X: Y" → extract Y
    match = gloss.match(/^(?:diminutive|augmentative|pejorative|endearing form) of [^:]+:\s*(.+)$/i);
    if (match) return match[1].trim();
    
    // Pattern: simple gloss followed by verbose parenthetical explanation
    // e.g., "I (first-person singular subject pronoun)" → "I"
    // e.g., "house, building (a residential building)" → "house, building"
    // But keep useful clarifications like "birch (tree or wood)"
    match = gloss.match(/^([^(]+)\s*\((?:a |the |first|second|third|singular|plural|subject|object|nominative|genitive|dative|accusative|masculine|feminine|neuter)[^)]*\)$/i);
    if (match) return match[1].trim();
    
    // Pattern: starts with linguistic jargon followed by simple gloss in parens
    // e.g., "proximal demonstrative (this)" but NOT "birch (tree or wood)"
    if (/^(mostly |generic |proximal |distal |demonstrative )/i.test(gloss)) {
        match = gloss.match(/\(([a-z][^)]{0,20})\)\s*$/i);
        if (match && !/\d/.test(match[1])) return match[1].trim();
    }
    
    // No extraction pattern matched — return original
    return gloss;
}

/**
 * Truncate gloss to N words max AND M characters max, adding ellipsis if needed
 * v5.11.8: Reduced maxChars to 18 for tighter word stack layout
 */
function truncateGloss(gloss, maxWords, maxChars = 18) {
    if (!gloss) return '';
    
    // First, strip ALL parenthetical content for word stack display
    let cleaned = gloss.replace(/\s*\([^)]*\)/g, ''); // Remove all parentheticals
    cleaned = cleaned.replace(/\s*\([^)]*$/, ''); // Remove unclosed parentheticals
    cleaned = cleaned.trim();
    
    // Word limit (no ellipsis)
    const words = cleaned.split(/\s+/);
    if (words.length > maxWords) {
        cleaned = words.slice(0, maxWords).join(' ');
    }
    
    // Character limit - truncate at word boundary, no ellipsis
    if (cleaned.length > maxChars) {
        const truncatedWords = [];
        let charCount = 0;
        for (const word of cleaned.split(/\s+/)) {
            if (charCount + word.length + (truncatedWords.length > 0 ? 1 : 0) <= maxChars) {
                truncatedWords.push(word);
                charCount += word.length + (truncatedWords.length > 1 ? 1 : 0);
            } else {
                break;
            }
        }
        cleaned = truncatedWords.join(' ') || cleaned.slice(0, maxChars);
    }
    
    // Remove dangling particles after comma/semicolon (v5.11.19)
    // "to wander, to" → "to wander" (the trailing "to" is semantically incomplete)
    cleaned = cleaned.replace(/[,;]\s+(to|a|the|of|in|on|for|and|or)$/i, '');
    
    // Remove trailing punctuation for cleaner appearance
    cleaned = cleaned.replace(/[,;:]+$/, '');
    
    return cleaned;
}

/**
 * Format gloss for popup display (POS + gloss + grammar hints)
 */
function formatGlossForPopup(gloss, pos, lemma) {
    if (!gloss) return pos ? `${pos}` : '';
    
    // Detect verbose grammatical patterns
    const isGrammatical = /^(short |inflection of|nominative |genitive |dative |accusative |instrumental |prepositional |comparative |superlative )/i.test(gloss) 
                       || /\b(singular|plural)\s+(of|past|present|future)\b/i.test(gloss);
    
    if (isGrammatical) {
        // Extract grammar hints
        let grammarHint = '';
        if (/past/i.test(gloss)) grammarHint += 'past ';
        if (/present/i.test(gloss)) grammarHint += 'pres. ';
        if (/future/i.test(gloss)) grammarHint += 'fut. ';
        if (/feminine/i.test(gloss)) grammarHint += 'f.';
        else if (/masculine/i.test(gloss)) grammarHint += 'm.';
        else if (/neuter/i.test(gloss)) grammarHint += 'n.';
        if (/plural/i.test(gloss)) grammarHint += 'pl.';
        grammarHint = grammarHint.trim();
        
        // Try lemma field first, then extract from gloss text
        const effectiveLemma = lemma || extractLemmaFromGloss(gloss);
        
        // Get semantic gloss
        let semanticGloss = '';
        if (effectiveLemma) {
            const rawGloss = getLemmaGloss(effectiveLemma);
            semanticGloss = rawGloss ? extractCleanGloss(rawGloss) : `→ ${effectiveLemma}`;
        }
        
        const displayGloss = semanticGloss || '';
        const grammarPart = grammarHint ? `(${grammarHint})` : '';
        
        // Avoid duplicating POS if gloss already starts with it
        if (pos && displayGloss.toLowerCase().startsWith(pos.toLowerCase())) {
          return `${displayGloss} ${grammarPart}`.trim();
        }
        
        return pos 
            ? `${pos} ${displayGloss} ${grammarPart}`.trim()
            : `${displayGloss} ${grammarPart}`.trim();
    }
    
    // Clean semantic gloss — extract clean translation, add POS
    const cleanedGloss = extractCleanGloss(gloss);
    
    // Avoid duplicating POS if gloss already starts with it (v5.10.23)
    if (pos && cleanedGloss.toLowerCase().startsWith(pos.toLowerCase())) {
      return cleanedGloss;
    }
    
    return pos ? `${pos} ${cleanedGloss}` : cleanedGloss;
}

/**
 * Add combining acute accent (U+0301) to the stressed vowel in Cyrillic text.
 * Exception: ё/Ё already indicates stress via dieresis, so no acute added.
 * 
 * @param {string} word - The Cyrillic word
 * @param {Array} syllables - Array of syllable objects with isStressed property
 * @returns {string} - Word with acute on stressed vowel (or unchanged if ё is stressed)
 */
function addStressMarkToCyrillic(word, syllables) {
    if (!syllables || syllables.length === 0) return word;
    
    // Find the stressed syllable
    const stressedSyl = syllables.find(s => s.isStressed);
    if (!stressedSyl) return word;
    
    // Find position of stressed syllable's Cyrillic in the word
    const vowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                           'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
    
    // Count vowels to find stressed syllable position
    let vowelCount = 0;
    let stressedSylIndex = 0;
    for (let i = 0; i < syllables.length; i++) {
        if (syllables[i].isStressed) {
            stressedSylIndex = i;
            break;
        }
    }
    
    // Now find the (stressedSylIndex + 1)th vowel in the word
    let currentVowelNum = 0;
    const chars = Array.from(word);
    let result = '';
    
    for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        result += char;
        
        if (vowels.has(char)) {
            if (currentVowelNum === stressedSylIndex) {
                // This is the stressed vowel — add acute unless it's ё/Ё
                if (char !== 'ё' && char !== 'Ё') {
                    result += '\u0301'; // Combining acute accent
                }
            }
            currentVowelNum++;
        }
    }
    
    return result;
}

/**
 * Add combining acute accent to the vowel in a syllable string (for popup display).
 * Exception: ё/Ё already indicates stress via dieresis, so no acute added.
 * 
 * @param {string} syllable - A single Cyrillic syllable
 * @returns {string} - Syllable with acute on its vowel (or unchanged if ё)
 */
function addAcuteToSyllable(syllable) {
    const vowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                           'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
    
    const chars = Array.from(syllable);
    let result = '';
    let acuteAdded = false;
    
    for (const char of chars) {
        result += char;
        if (!acuteAdded && vowels.has(char) && char !== 'ё' && char !== 'Ё') {
            result += '\u0301'; // Combining acute accent
            acuteAdded = true;
        }
    }
    
    return result;
}

    /* ========================================
       TRANSCRIPTION PROFILES
       ======================================== */
    const TRANSCRIPTION_PROFILES = {
      'old-muscovite': {
        name: 'Old Muscovite',
        default: true,
        params: {
          reduction: 'ikanye',
          shcha: 'shshokanye',    // [ʃʲː]
          adjectival: 'stage',     // [ɨj]
          intensity: 'full'
        },
        description: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]'
      },
      'peterburgian': {
        name: 'Peterburgian',
        params: {
          reduction: 'ekanye',
          shcha: 'shchokanye',    // [ʃtʃ]
          adjectival: 'modern',    // [ij]
          intensity: 'full'
        },
        description: 'Ekanye vowel reduction, [ʃtʃ] for щ, modern adjectivals [ij]'
      },
      'choral': {
        name: 'Choral',
        params: {
          reduction: 'ikanye',
          shcha: 'shshokanye',    // [ʃʲː]
          adjectival: 'stage',     // [ɨj]
          intensity: 'reduced'
        },
        description: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj], reduced intensity for vowel matching'
      }
    };
    
    /* ========================================
       TAB CONTROLLER (Mobile)
       ======================================== */
    const TabController = {
      tabs: null,
      inputZone: null,
      dashboardZone: null,
      activeTab: 'text',
      
      init() {
        this.tabs = document.querySelectorAll('.drawer-tab');
        this.inputZone = document.getElementById('inputZone');
        this.dashboardZone = document.getElementById('dashboardZone');
        
        if (!this.tabs.length) return;
        
        this.tabs.forEach(tab => {
          tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
        
        // Check viewport and show appropriate zone
        this.handleResize();
        window.addEventListener('resize', () => this.handleResize());
      },
      
      switchTab(tabName) {
        this.activeTab = tabName;
        
        // Update tab buttons
        this.tabs.forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        
        // Update zones visibility (mobile only)
        if (window.innerWidth < 768) {
          this.inputZone.classList.toggle('hidden', tabName !== 'text');
          this.dashboardZone.classList.toggle('hidden', tabName !== 'details');
        }
      },
      
      handleResize() {
        // Desktop: show both zones
        if (window.innerWidth >= 768) {
          this.inputZone.classList.remove('hidden');
          this.dashboardZone.classList.remove('hidden');
        } else {
          // Mobile: show only active tab
          this.switchTab(this.activeTab);
        }
      }
    };
    
    /* ========================================
       SEARCHABLE SELECT CONTROLLER
       ======================================== */
    const SearchableSelect = {
      instances: {},
      
      create(config) {
        const { id, trigger, dropdown, search, options, data, onSelect } = config;
        
        const instance = {
          isOpen: false,
          selectedValue: null,
          selectedDisplay: null,
          filteredData: [...data],
          highlightIndex: -1,
          
          open() {
            this.isOpen = true;
            trigger.classList.add('active');
            dropdown.classList.add('open');
            search.value = '';
            this.filteredData = [...data]; // Reset filtered data
            this.highlightIndex = -1;
            search.focus();
            this.render(this.filteredData);
          },
          
          close() {
            this.isOpen = false;
            trigger.classList.remove('active');
            dropdown.classList.remove('open');
            this.highlightIndex = -1;
          },
          
          toggle() {
            if (this.isOpen) this.close();
            else this.open();
          },
          
          select(item) {
            this.selectedValue = item;
            this.selectedDisplay = `${item.latin} (${item.dates})`;
            
            // Update trigger display
            trigger.innerHTML = `
              <span>${this.selectedDisplay}</span>
              <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            `;
            
            this.close();
            if (onSelect) onSelect(item);
          },
          
          filter(query) {
            const q = query.toLowerCase();
            this.filteredData = data.filter(item => 
              item.latin.toLowerCase().includes(q) ||
              item.cyrillic.toLowerCase().includes(q)
            );
            this.highlightIndex = -1;
            this.render(this.filteredData);
          },
          
          render(items) {
            let html = items.map((item, idx) => `
              <div class="select-option ${idx === this.highlightIndex ? 'highlighted' : ''}" data-index="${idx}">
                <span class="primary">${item.latin}</span>
                <span class="secondary">${item.cyrillic} • ${item.dates}</span>
              </div>
            `).join('');
            
            // Add "Not in list" option
            html += `<div class="select-option custom" data-custom="true">+ Not in list (enter custom)</div>`;
            
            options.innerHTML = html;
            
            // Bind click handlers
            options.querySelectorAll('.select-option').forEach(opt => {
              opt.addEventListener('click', () => {
                if (opt.dataset.custom) {
                  // Custom entry - for now just close
                  this.close();
                  // Future: show custom input
                } else {
                  const idx = parseInt(opt.dataset.index);
                  this.select(this.filteredData[idx]);
                }
              });
            });
          }
        };
        
        // Event listeners
        trigger.addEventListener('click', () => instance.toggle());
        search.addEventListener('input', (e) => instance.filter(e.target.value));
        
        // Make trigger focusable and respond to typing
        trigger.setAttribute('tabindex', '0');
        trigger.addEventListener('keydown', (e) => {
          // If typing a printable character, open and start filtering
          if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            if (!instance.isOpen) {
              instance.open();
            }
            search.value = e.key;
            instance.filter(e.key);
          } else if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            instance.toggle();
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (!instance.isOpen) instance.open();
          } else if (e.key === 'Escape') {
            instance.close();
          }
        });
        
        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!trigger.contains(e.target) && !dropdown.contains(e.target)) {
            instance.close();
          }
        });
        
        // Keyboard navigation
        search.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            instance.highlightIndex = Math.min(instance.highlightIndex + 1, instance.filteredData.length - 1);
            instance.render(instance.filteredData);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            instance.highlightIndex = Math.max(instance.highlightIndex - 1, 0);
            instance.render(instance.filteredData);
          } else if (e.key === 'Enter' && instance.highlightIndex >= 0) {
            e.preventDefault();
            instance.select(instance.filteredData[instance.highlightIndex]);
          } else if (e.key === 'Escape') {
            instance.close();
          }
        });
        
        this.instances[id] = instance;
        return instance;
      }
    };
    
    /* ========================================
       PROFILE CONTROLLER
       ======================================== */
    const ProfileController = {
      section: null,
      header: null,
      select: null,
      description: null,
      activeLabel: null,
      currentProfile: 'old-muscovite',
      
      init() {
        this.section = document.getElementById('profileSection');
        this.header = document.getElementById('profileHeader');
        this.select = document.getElementById('profileSelect');
        this.description = document.getElementById('profileDescription');
        this.activeLabel = document.getElementById('profileActive');
        
        if (!this.section) return;
        
        // Toggle expand/collapse
        this.header.addEventListener('click', () => {
          this.section.classList.toggle('expanded');
        });
        
        // Profile selection
        this.select.addEventListener('change', (e) => {
          this.setProfile(e.target.value);
        });
      },
      
      setProfile(profileKey) {
        const profile = TRANSCRIPTION_PROFILES[profileKey];
        if (!profile) return;
        
        this.currentProfile = profileKey;
        this.activeLabel.textContent = profile.name;
        this.description.innerHTML = `
          <span class="info-icon-circle">i</span>
          <span>${profile.description}</span>
        `;
        
        // TODO: Trigger re-transcription if content exists
        console.log('Profile changed to:', profile.name, profile.params);
      },
      
      getParams() {
        return TRANSCRIPTION_PROFILES[this.currentProfile]?.params || TRANSCRIPTION_PROFILES['old-muscovite'].params;
      }
    };
    
    /* ========================================
       DOCUMENT CONTROLLER (v5.9.0)
       Paper size selection + pagination
       ======================================== */
    const DocumentController = {
      section: null,
      header: null,
      activeLabel: null,
      paperSizeBtns: null,
      pageNumberEl: null,
      paper: null,
      currentSize: 'letter',
      
      // Paper dimensions in pixels (96dpi)
      PAPER_HEIGHTS: {
        letter: 1056,  // 11in × 96dpi
        a4: 1123       // 297mm × 96dpi / 25.4
      },
      
      init() {
        this.section = document.getElementById('documentSection');
        this.header = document.getElementById('documentHeader');
        this.activeLabel = document.getElementById('documentActive');
        this.paperSizeBtns = document.querySelectorAll('.paper-size-btn');
        this.pageNumberEl = document.getElementById('pageNumber');
        this.paper = document.querySelector('.paper');
        
        if (!this.section) return;
        
        // Toggle expand/collapse
        this.header.addEventListener('click', () => {
          this.section.classList.toggle('expanded');
        });
        
        // Paper size selection
        this.paperSizeBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            this.setSize(btn.dataset.size);
          });
        });
        
        // Recalculate on window resize
        window.addEventListener('resize', () => {
          this.updatePageCount();
        });
      },
      
      setSize(size) {
        if (size === this.currentSize) return;
        
        this.currentSize = size;
        
        // Update button states
        this.paperSizeBtns.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.size === size);
        });
        
        // Update label with dimensions
        this.activeLabel.textContent = size === 'letter' ? 'Letter (8.5×11)' : 'A4 (210×297)';
        
        // Add reflowing class for content fade
        this.paper?.classList.add('reflowing');
        
        // Update paper data attribute (triggers CSS transition)
        if (size === 'a4') {
          this.paper?.setAttribute('data-size', 'a4');
        } else {
          this.paper?.removeAttribute('data-size');
        }
        
        // Remove reflowing class and update page count after transition
        setTimeout(() => {
          this.paper?.classList.remove('reflowing');
          this.updatePageCount();
        }, 400); // 300ms transition + 100ms buffer
      },
      
      getSize() {
        return this.currentSize;
      },
      
      // Calculate page count based on content vs paper height
      calculatePageCount() {
        if (!this.paper) return 1;
        
        const contentHeight = this.paper.scrollHeight;
        const visibleHeight = this.paper.clientHeight;
        
        // If no overflow, it's 1 page
        if (contentHeight <= visibleHeight) return 1;
        
        // Calculate based on full paper height (not viewport-constrained)
        const fullPaperHeight = this.PAPER_HEIGHTS[this.currentSize];
        const pageCount = Math.ceil(contentHeight / fullPaperHeight);
        
        return Math.max(1, pageCount);
      },
      
      // Update the page count label using Paginator
      updatePageCount() {
        if (!this.pageNumberEl) {
          console.warn('[DocumentController] pageNumberEl not found');
          return;
        }
        
        // Count pages based on DocumentState lines
        let totalPages = 1;
        
        if (DocumentState?.lines?.length > 0) {
          const lineCount = DocumentState.lines.length;
          const pages = Paginator.distributeToPages(
            Array(lineCount).fill({}),  // Mock lines for counting
            null,                        // No heights for simple count
            this.currentSize
          );
          totalPages = pages.length;
        }
        
        // Format: "X pages" for dashboard indicator
        if (totalPages === 1) {
          this.pageNumberEl.textContent = '1 page';
        } else {
          this.pageNumberEl.textContent = `${totalPages} pages`;
        }
      }
    };
    
    /* ========================================
       PAGINATOR (v5.9.4)
       Multi-page distribution engine
       ======================================== */
    const Paginator = {
      // Measured values (populated after first render)
      lineHeight: null,
      safeLineHeight: null,
      
      // Line height cache for pre-flight measurement (v5.11.17)
      lineHeightCache: null,
      lineHeightCacheHash: null,
      
      // Paper dimensions in pixels (96dpi)
      PAPER_HEIGHTS: {
        letter: 1056,  // 11in × 96dpi
        a4: 1123       // 297mm × 96dpi / 25.4
      },
      
      // Layout constants (in pixels)
      MARGINS: {
        top: 48,       // Reduced from 72 - header provides visual padding
        bottom: 24,    // Reduced from 72 - footer provides visual padding
        left: 72,
        right: 72
      },
      
      // Header heights
      TITLE_HEADER_HEIGHT: 150,    // Page 1: full title block
      RUNNING_HEADER_HEIGHT: 48,   // Pages 2+: "COMPOSER — TITLE"
      FOOTER_HEIGHT: 120,           // Footer with attribution + pagination (measured)
      
      /**
       * Measure actual line height from rendered content
       * Should be called after renderToPaper() completes
       */
      measureLineHeight() {
        const lines = document.querySelectorAll('.verse-line');
        
        if (lines.length === 0) {
          console.log('[Paginator] No lines to measure');
          return null;
        }
        
        // Find maximum height among all lines
        const heights = Array.from(lines).map(el => {
          const rect = el.getBoundingClientRect();
          return rect.height;
        });
        
        const maxHeight = Math.max(...heights);
        const minHeight = Math.min(...heights);
        const avgHeight = heights.reduce((a, b) => a + b, 0) / heights.length;
        
        // Store with 5% safety margin (reduced from 10%)
        this.lineHeight = maxHeight;
        this.safeLineHeight = Math.ceil(maxHeight * 1.05);
        
        console.log('[Paginator] Line height measured:', {
          min: minHeight.toFixed(1),
          max: maxHeight.toFixed(1),
          avg: avgHeight.toFixed(1),
          safe: this.safeLineHeight,
          sampleSize: lines.length
        });
        
        return this.safeLineHeight;
      },
      
      /**
       * Pre-flight measurement: measure all line heights BEFORE pagination (v5.11.17)
       * Uses off-screen container with actual CSS to get true visual heights
       * @param {Array} allLines - Transcribed line data
       * @param {Function} createLineElement - Function to create .verse-line element
       * @returns {Array} Heights in pixels for each line
       */
      measureAllLineHeights(allLines, createLineElement) {
        // Check cache first
        const contentHash = this.hashLineContent(allLines);
        if (this.lineHeightCache && this.lineHeightCacheHash === contentHash) {
          console.log('[Paginator] Using cached line heights');
          return this.lineHeightCache;
        }
        
        // Get content width from existing page, or use fallback
        const contentWidth = this.getContentWidth();
        
        // Create hidden container that inherits page-content CSS
        // Must match real container exactly: box-sizing, overflow, width
        const hiddenContainer = document.createElement('div');
        hiddenContainer.className = 'page-content';
        hiddenContainer.style.cssText = `
          position: absolute;
          visibility: hidden;
          pointer-events: none;
          width: ${contentWidth}px;
          box-sizing: border-box;
          overflow: hidden;
          top: -9999px;
          left: -9999px;
        `;
        document.body.appendChild(hiddenContainer);
        
        // Diagnostic logging (v5.11.18)
        const realPage = document.querySelector('.paper-page .page-content');
        if (realPage) {
          const realWidth = realPage.getBoundingClientRect().width;
          const hiddenWidth = hiddenContainer.getBoundingClientRect().width;
          console.log(`[Paginator] Width check - Hidden: ${hiddenWidth.toFixed(1)}px, Real: ${realWidth.toFixed(1)}px, Diff: ${(hiddenWidth - realWidth).toFixed(1)}px`);
        }
        
        // Measure each line
        const heights = allLines.map(line => {
          const el = createLineElement(line);
          hiddenContainer.appendChild(el);
          const height = el.getBoundingClientRect().height;
          hiddenContainer.removeChild(el);
          return height;
        });
        
        // Clean up
        hiddenContainer.remove();
        
        // Cache results
        this.lineHeightCache = heights;
        this.lineHeightCacheHash = contentHash;
        
        // Calculate standard row height using 10th percentile for robustness (v5.11.18)
        // Math.min() is fragile if some lines are unusually short
        const nonZeroHeights = heights.filter(h => h > 0);
        if (nonZeroHeights.length > 0) {
          const sorted = [...nonZeroHeights].sort((a, b) => a - b);
          const idx = Math.floor(sorted.length * 0.1); // 10th percentile
          this.standardRowHeight = sorted[idx] || sorted[0];
        } else {
          this.standardRowHeight = 105; // Fallback
        }
        
        console.log('[Paginator] Pre-flight measurement:', {
          lines: heights.length,
          standardRowHeight: this.standardRowHeight.toFixed(1),
          minHeight: Math.min(...heights).toFixed(1),
          maxHeight: Math.max(...heights).toFixed(1),
          wrappingLines: heights.filter(h => h > this.standardRowHeight * 1.5).length
        });
        
        return heights;
      },
      
      /**
       * Get content width from rendered page or calculate from constants
       */
      getContentWidth() {
        const referencePage = document.querySelector('.paper-page');
        if (referencePage) {
          const referenceContent = referencePage.querySelector('.page-content');
          if (referenceContent) {
            const computedStyle = window.getComputedStyle(referenceContent);
            return referenceContent.clientWidth 
              - parseFloat(computedStyle.paddingLeft || 0) 
              - parseFloat(computedStyle.paddingRight || 0);
          }
        }
        // Fallback: letter width (8.5in) minus margins (72px each side)
        return 816 - 144; // 672px
      },
      
      /**
       * Hash line content for cache invalidation
       * Uses cleanWord and stress index from transcribed word data
       */
      hashLineContent(allLines) {
        return allLines.map(line => 
          line.map(tw => 
            (tw.cleanWord || '') + ':' + (tw.wordData?.stress ?? '')
          ).join('|')
        ).join('||');
      },
      
      /**
       * Invalidate line height cache (call when content changes)
       */
      invalidateCache() {
        this.lineHeightCache = null;
        this.lineHeightCacheHash = null;
        console.log('[Paginator] Cache invalidated');
      },
      
      /**
       * Calculate how many lines fit on each page type
       * Fixed counts based on testing: 5 for title page, 7 for subsequent
       * (v5.11.7 - reduced from 6/8 to prevent clipping)
       */
      calculateLinesPerPage(paperSize = 'letter') {
        // Fixed line counts based on visual testing
        // Page 1 has less room due to title block
        // Subsequent pages have more room with just running header
        // (v5.11.19 - restored to 6/8, horizontal gap reduction prevents wrapping)
        const linesPage1 = 6;
        const linesSubsequent = 8;
        
        console.log('[Paginator] Lines per page:', {
          paperSize,
          linesPage1,
          linesSubsequent
        });
        
        return {
          page1: linesPage1,
          subsequent: linesSubsequent
        };
      },
      
      /**
       * Format running header: "COMPOSER — TITLE"
       * Smart truncation per Kimi's spec
       */
      formatRunningHeader(surname, title) {
        if (!surname && !title) return '';
        
        // Truncate title if needed (30 chars max)
        let shortTitle = title || '';
        if (shortTitle.length > 30) {
          shortTitle = shortTitle.slice(0, 27) + '...';
        }
        
        // Format as "SURNAME — TITLE"
        if (surname && shortTitle) {
          return `${surname.toUpperCase()} — ${shortTitle.toUpperCase()}`;
        }
        return (surname || shortTitle).toUpperCase();
      },
      
      /**
       * Distribute lines across pages (v5.11.19)
       * @param {Array} allLines - All transcribed lines
       * @param {Object} targets - { page1: N, subsequent: M } line counts
       * @param {string} paperSize - 'letter' or 'a4'
       * @returns {Array} Array of page objects
       */
      distributeToPages(allLines, targets = null, paperSize = 'letter') {
        // Use provided targets or defaults
        const { page1, subsequent } = targets || { page1: 6, subsequent: 8 };
        
        const pages = [];
        let cursor = 0;
        
        // Page 1: title template, fewer lines
        if (allLines.length > 0) {
          pages.push({
            pageNumber: 1,
            template: 'title',
            lines: allLines.slice(0, page1)
          });
          cursor = page1;
        }
        
        // Subsequent pages: running header, more lines
        while (cursor < allLines.length) {
          pages.push({
            pageNumber: pages.length + 1,
            template: 'subsequent',
            lines: allLines.slice(cursor, cursor + subsequent)
          });
          cursor += subsequent;
        }
        
        // Ensure at least one page
        if (pages.length === 0) {
          pages.push({
            pageNumber: 1,
            template: 'title',
            lines: []
          });
        }
        
        console.log('[Paginator] Distribution:', {
          targets: { page1, subsequent },
          totalLines: allLines.length,
          pageCount: pages.length,
          linesPerPage: pages.map(p => p.lines.length)
        });
        
        return pages;
      },
      
      /**
       * Get total page count for display
       */
      getPageCount(allLines, paperSize = 'letter') {
        const pages = this.distributeToPages(allLines, null, paperSize);
        return pages.length;
      },
      
      /**
       * Update measurements (call after render or resize)
       */
      update() {
        this.measureLineHeight();
        const paperSize = DocumentController.getSize();
        this.calculateLinesPerPage(paperSize);
      }
    };
    
    /* ========================================
       DASHBOARD CONTROLLER
       ======================================== */
    const DashboardController = {
      titleInput: null,
      opusInput: null,
      transcriberInput: null,
      composerSelect: null,
      poetSelect: null,
      exportBtn: null,
      
      init() {
        this.titleInput = document.getElementById('metaTitle');
        this.opusInput = document.getElementById('metaOpus');
        this.transcriberInput = document.getElementById('metaTranscriber');
        this.exportBtn = document.getElementById('exportPdfBtn');
        
        // Initialize searchable selects
        this.composerSelect = SearchableSelect.create({
          id: 'composer',
          trigger: document.getElementById('composerTrigger'),
          dropdown: document.getElementById('composerDropdown'),
          search: document.getElementById('composerSearch'),
          options: document.getElementById('composerOptions'),
          data: COMPOSERS,
          onSelect: (item) => this.updatePaperMetadata()
        });
        
        this.poetSelect = SearchableSelect.create({
          id: 'poet',
          trigger: document.getElementById('poetTrigger'),
          dropdown: document.getElementById('poetDropdown'),
          search: document.getElementById('poetSearch'),
          options: document.getElementById('poetOptions'),
          data: POETS,
          onSelect: (item) => this.updatePaperMetadata()
        });
        
        // Listen for text input changes
        this.titleInput?.addEventListener('input', () => this.updatePaperMetadata());
        this.opusInput?.addEventListener('input', () => this.updatePaperMetadata());
        this.transcriberInput?.addEventListener('input', () => this.updateTranscriber());
        
        // Export PDF button
        this.exportBtn?.addEventListener('click', () => this.exportPDF());
        
        // Update export button state
        this.updateExportButton();
      },
      
      updateExportButton() {
        if (!this.exportBtn) return;
        const hasContent = DocumentState.lines.length > 0;
        this.exportBtn.disabled = !hasContent;
        this.exportBtn.title = hasContent ? 'Export transcription as PDF' : 'Transcribe text first';
      },
      
      exportPDF() {
        if (DocumentState.lines.length === 0) {
          alert('Please transcribe some text first.');
          return;
        }
        
        // Set document title for PDF filename suggestion
        const title = this.titleInput?.value || 'Ilya Transcription';
        const originalTitle = document.title;
        document.title = title;
        
        // Trigger print dialog
        window.print();
        
        // Restore document title after print dialog closes
        setTimeout(() => {
          document.title = originalTitle;
        }, 1000);
      },
      
      updateTranscriber() {
        const name = this.transcriberInput?.value.trim();
        DocumentState.userName = name || 'anonymous';
        // Re-render to update footers
        if (DocumentState.lines.length > 0) {
          DrawerController.renderToPaper();
        }
      },
      
      updatePaperMetadata() {
        // In multi-page mode, metadata is embedded in page templates
        // Re-render to update headers with new metadata
        if (DocumentState.lines.length > 0) {
          DrawerController.renderToPaper();
        }
      },
      
      getMetadata() {
        return {
          title: this.titleInput?.value || '',
          opus: this.opusInput?.value || '',
          composer: this.composerSelect?.selectedValue || null,
          poet: this.poetSelect?.selectedValue || null,
          transcriber: this.transcriberInput?.value || 'anonymous'
        };
      }
    };

    /* ========================================
       DRAWER CONTROLLER
       ======================================== */
    const DrawerController = {
      drawer: null,
      handle: null,
      content: null,
      preview: null,
      textInput: null,
      clearBtn: null,
      transcribeBtn: null,
      // OCR elements
      ocrScanBtn: null,
      ocrFileInput: null,
      ocrStatus: null,
      ocrStatusText: null,
      
      init() {
        this.drawer = document.getElementById('inputDrawer');
        this.handle = document.getElementById('drawerHandle');
        this.content = document.getElementById('drawerContent');
        this.preview = document.getElementById('handlePreview');
        this.textInput = document.getElementById('textInput');
        this.clearBtn = document.getElementById('clearBtn');
        this.transcribeBtn = document.getElementById('transcribeBtn');
        
        // OCR elements
        this.ocrScanBtn = document.getElementById('ocrScanBtn');
        this.ocrFileInput = document.getElementById('ocrFileInput');
        this.ocrStatus = document.getElementById('ocrStatus');
        this.ocrStatusText = this.ocrStatus?.querySelector('.ocr-status-text');
        
        // Initialize OCR (lazy-loads Tesseract in background)
        this.initOCR();
        
        // Click handler for entire handle bar
        this.handle.addEventListener('click', () => this.toggle());
        
        // Keyboard support (Enter/Space to toggle, Escape to collapse)
        this.handle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.toggle();
          }
        });
        
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.isExpanded()) {
            this.collapse();
          }
        });
        
        // Update preview when text changes
        this.textInput.addEventListener('input', () => this.updatePreview());
        
        // Clear button
        this.clearBtn.addEventListener('click', () => this.clear());
        
        // Transcribe button (placeholder for now)
        this.transcribeBtn.addEventListener('click', () => this.transcribe());
        
        // Start expanded so input is visible by default
        this.expand();
      },
      
      isExpanded() {
        return this.drawer.classList.contains('expanded');
      },
      
      toggle() {
        if (this.isExpanded()) {
          this.collapse();
        } else {
          this.expand();
        }
      },
      
      expand() {
        this.drawer.classList.remove('collapsed');
        this.drawer.classList.add('expanded');
        this.handle.setAttribute('aria-expanded', 'true');
        // Focus textarea when expanding
        setTimeout(() => this.textInput.focus(), 100);
      },
      
      collapse() {
        this.drawer.classList.remove('expanded');
        this.drawer.classList.add('collapsed');
        this.handle.setAttribute('aria-expanded', 'false');
        this.updatePreview();
        // Return focus to handle
        this.handle.focus();
      },
      
      updatePreview() {
        const text = this.textInput.value.trim();
        if (!text) {
          this.preview.textContent = '';
          return;
        }
        
        const lines = text.split('\n').filter(line => line.trim());
        const lineCount = lines.length;
        const firstLine = lines[0] || '[empty first line]';
        
        // Truncate at 30 chars
        const truncated = firstLine.length > 30 
          ? firstLine.substring(0, 30) + '...' 
          : firstLine;
        
        this.preview.textContent = `${truncated} • ${lineCount} line${lineCount !== 1 ? 's' : ''}`;
      },
      
      clear() {
        // If there's transcribed content, confirm before clearing
        if (DocumentState.lines.length > 0) {
          if (!confirm('Clear transcription? This cannot be undone.')) {
            return;
          }
        }
        
        // Clear input field
        this.textInput.value = '';
        this.updatePreview();
        
        // Clear document state
        DocumentState.lines = [];
        
        // Re-render to show empty page with ghost text
        this.renderToPaper();
        
        this.textInput.focus();
      },
      
      transcribe() {
        const text = this.textInput.value.trim();
        if (!text) {
          this.textInput.focus();
          return;
        }
        
        // Parse lines into words
        const lines = text.split('\n').filter(line => line.trim());
        
        // Invalidate pre-measurement cache when new content arrives (v5.11.17)
        Paginator.invalidateCache();
        
        // Convert to DocumentState format with dictionary lookup
        DocumentState.lines = lines.map(line => {
          const words = line.trim().split(/\s+/)
            // Filter out punctuation-only tokens (v5.11.8)
            .filter(word => {
              const cleaned = word.replace(/[.,!?;:"""''–—\-]/g, '');
              return cleaned.length > 0;
            });
          return words.map(word => {
            const lookup = GraysonEngine.lookupStress(word);
            
            // Determine the display form (may be ё-restored)
            let displayWord = word;
            let wasYoRestored = false;
            let dictionaryForm = null;
            
            if (lookup?.source === 'yo-restored' && lookup.canonicalForm) {
              // Restore ё while preserving original case pattern
              displayWord = GraysonEngine.applyCasePattern(word, lookup.canonicalForm);
              dictionaryForm = displayWord;  // Store what Ilya found
              wasYoRestored = true;
            }
            
            // ё always carries stress — check the display form (which may now have ё)
            const yoSyllable = GraysonEngine.findYoSyllable(displayWord);
            let stress, stressSource, yoSource;
            
            if (yoSyllable !== -1) {
              // ё found: stress is locked to that syllable
              stress = yoSyllable;
              stressSource = wasYoRestored ? 'yo-restored' : 'yo-rule';
              yoSource = wasYoRestored ? 'yo-restored' : null;  // null = native ё, no intervention
            } else if (lookup) {
              stress = lookup.stress;
              stressSource = lookup.source;
              yoSource = null;
            } else {
              // Unknown word: default to first syllable, marked for user verification
              stress = 0;
              stressSource = 'default';
              yoSource = null;
            }
            
            return {
              cyrillic: displayWord,
              stress: stress,
              gloss: lookup ? lookup.gloss : '',
              pos: lookup ? lookup.pos : '',
              lemma: lookup ? lookup.lemma : '',
              isHomograph: lookup ? lookup.isHomograph : false,
              originalStress: stress,
              stressSource: stressSource,
              hasYo: yoSyllable !== -1,
              originalInput: wasYoRestored ? word : null,  // What user typed (if different)
              dictionaryForm: dictionaryForm,              // What Ilya found (if restored)
              yoSource: yoSource,                          // yo-restored | user-yo-edit | null
              rightBoundary: null,
              boundarySource: null
            };
          });
        }).filter(line => line.length > 0);  // Remove empty lines (v5.11.8)
        
        // Auto-detect boundary types for each line
        DocumentState.lines.forEach(line => {
          GraysonEngine.autoDetectBoundaries(line);
        });
        
        // Render to paper
        this.renderToPaper();
        
        // Collapse drawer after transcription
        this.collapse();
      },
      
      renderToPaper(fallbackMode = false) {
        const paperStack = document.getElementById('paperStack');
        const paperSize = DocumentController.getSize();
        
        if (!paperStack) return;
        
        // Clear existing pages
        paperStack.innerHTML = '';
        
        // If no content, show empty title page with ghost text
        if (!DocumentState.lines || DocumentState.lines.length === 0) {
          const emptyPage = this.createPageElement(1, 'title', [], 1, paperSize);
          paperStack.appendChild(emptyPage);
          DocumentController.updatePageCount();
          DashboardController.updateExportButton();
          return;
        }
        
        // PHASE 1-2.5: Transcribe all lines
        const transcribedLines = this.transcribeAllLines();
        
        // Distribute lines to pages
        // Normal mode: 6/8, Fallback mode: 5/7 (guaranteed safe)
        const targets = fallbackMode 
          ? { page1: 5, subsequent: 7 }
          : { page1: 6, subsequent: 8 };
        
        const pages = Paginator.distributeToPages(transcribedLines, targets, paperSize);
        const totalPages = pages.length;
        
        console.log('[renderToPaper] Creating', totalPages, 'pages', fallbackMode ? '(fallback mode)' : '');
        
        // Render each page
        pages.forEach((pageData, pageIdx) => {
          const pageElement = this.createPageElement(
            pageData.pageNumber,
            pageData.template,
            pageData.lines,
            totalPages,
            paperSize
          );
          paperStack.appendChild(pageElement);
        });
        
        // POST-RENDER OVERFLOW CHECK (v5.11.19)
        // If overflow detected and not already in fallback mode, re-render with reduced counts
        if (!fallbackMode) {
          const hasOverflow = this.detectOverflow();
          if (hasOverflow) {
            console.warn('[renderToPaper] Overflow detected, re-rendering in fallback mode (5/7)');
            this.renderToPaper(true); // Recursive call with fallback
            return;
          }
        }
        
        // Update page count display and export button state
        DocumentController.updatePageCount();
        DashboardController.updateExportButton();
      },
      
      /**
       * Detect if any page has content overflow (v5.11.19)
       * Returns true if any last verse-line extends into footer zone
       */
      detectOverflow() {
        const pages = document.querySelectorAll('.paper-page');
        let hasOverflow = false;
        
        pages.forEach((page, idx) => {
          const pageContent = page.querySelector('.page-content');
          const footer = page.querySelector('.page-footer');
          
          if (!pageContent || !footer) return;
          
          const lastVerseLine = pageContent.querySelector('.verse-line:last-child');
          if (!lastVerseLine) return;
          
          const lineRect = lastVerseLine.getBoundingClientRect();
          const footerRect = footer.getBoundingClientRect();
          const lineBottom = lineRect.bottom;
          const footerTop = footerRect.top;
          
          // 20px safety margin
          if (lineBottom > footerTop - 20) {
            console.warn(`[Overflow] Page ${idx + 1}: line bottom ${lineBottom.toFixed(0)}px, footer top ${footerTop.toFixed(0)}px`);
            hasOverflow = true;
          }
        });
        
        return hasOverflow;
      },
      
      /**
       * Create a single page element with header, content, and footer
       */
      createPageElement(pageNumber, template, lines, totalPages, paperSize) {
        const page = document.createElement('article');
        page.className = 'paper-page';
        page.setAttribute('data-template', template);
        page.setAttribute('data-page', pageNumber);
        if (paperSize === 'a4') {
          page.setAttribute('data-size', 'a4');
        }
        
        // Get metadata from dashboard
        const title = DashboardController.titleInput?.value || 'Song Title';
        const opus = DashboardController.opusInput?.value || '';
        // Format name from "Lastname, Firstname" to "Firstname Lastname"
        const formatNameForDisplay = (item) => {
          if (!item) return '';
          const name = item.latin || '';
          const dates = item.dates || '';
          // Split "Lastname, Firstname" and reverse
          const parts = name.split(',').map(p => p.trim());
          const displayName = parts.length > 1 ? `${parts[1]} ${parts[0]}` : name;
          return dates ? `${displayName} (${dates})` : displayName;
        };
        
        const composerDisplay = formatNameForDisplay(DashboardController.composerSelect?.selectedValue);
        const poetDisplay = formatNameForDisplay(DashboardController.poetSelect?.selectedValue);
        // For running header, keep surname only
        const composerSurname = DashboardController.composerSelect?.selectedValue?.latin?.split(',')[0]?.trim() || '';
        
        let headerHTML = '';
        
        if (template === 'title') {
          // Page 1: Full title block with logo
          headerHTML = `
            <div class="page-logo">
              <span class="bracket">[</span>
              <span class="logo-name">Ilya</span>
              <span class="bracket">]</span>
            </div>
            <header class="page-header-title">
              <h1 class="page-title">${title}</h1>
              <div class="page-metadata">
                ${composerDisplay ? `<span>${composerDisplay}</span>` : ''}
                ${composerDisplay && opus ? '<span class="divider">│</span>' : ''}
                ${opus ? `<span>${opus}</span>` : ''}
              </div>
              ${poetDisplay ? `<div class="page-metadata"><span>Text by ${poetDisplay}</span></div>` : ''}
              <hr class="page-metadata-rule">
            </header>
          `;
        } else {
          // Pages 2+: Running header
          const runningHeader = Paginator.formatRunningHeader(composerSurname, title);
          headerHTML = `
            <header class="page-header-running">
              <span class="running-title">${runningHeader}</span>
            </header>
          `;
        }
        
        // Content area
        let contentHTML = '';
        if (lines.length === 0 && template === 'title') {
          // Empty state
          contentHTML = `
            <main class="page-content empty">
              <span class="page-ghost-text">Paste or type your Cyrillic Russian text below, then press Transcribe.</span>
            </main>
          `;
        } else {
          // Render verse lines
          const linesHTML = lines.map(line => this.renderVerseLine(line)).join('');
          contentHTML = `
            <main class="page-content">
              <div class="verse-container">${linesHTML}</div>
            </main>
          `;
        }
        
        // Footer with attribution (2/3) and pagination (1/3)
        const userName = DocumentState.userName || 'anonymous';
        const canadaFlag = `<svg xmlns="http://www.w3.org/2000/svg" width="1.5em" height="0.75em" viewBox="0 0 9600 4800" style="vertical-align: middle; margin-left: 0.25em;"><path fill="#f00" d="m0 0h2400l99 99h4602l99-99h2400v4800h-2400l-99-99h-4602l-99 99H0z"/><path fill="#fff" d="m2400 0h4800v4800h-4800zm2490 4430-45-863a95 95 0 0 1 111-98l859 151-116-320a65 65 0 0 1 20-73l941-762-212-99a65 65 0 0 1-34-79l186-572-542 115a65 65 0 0 1-73-38l-105-247-423 454a65 65 0 0 1-111-57l204-1052-327 189a65 65 0 0 1-91-27l-332-652-332 652a65 65 0 0 1-91 27l-327-189 204 1052a65 65 0 0 1-111 57l-423-454-105 247a65 65 0 0 1-73 38l-542-115 186 572a65 65 0 0 1-34 79l-212 99 941 762a65 65 0 0 1 20 73l-116 320 859-151a95 95 0 0 1 111 98l-45 863z"/></svg>`;
        const footerHTML = `
          <footer class="page-footer">
            <div class="footer-attribution">
              <p>This transcription was created by ${userName} using <em>Ilya</em> v1.0, whose rules engine is based on Dr. Craig Grayson's <em>Russian Lyric Diction</em> (University of Washington, 2012). Stress data from English Wiktionary via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).</p>
              <p>Dann Mitton built <em>Ilya</em> to be open source: use and distribute it freely, improve it if you can, share what you make. Don't be evil. <em>Ilya</em> is a scholarly tool: neither it nor its transcriptions may be repackaged or sold. Made with love in Canada.${canadaFlag}</p>
            </div>
            <div class="footer-pagination">
              Page ${pageNumber} of ${totalPages}
            </div>
          </footer>
        `;
        
        page.innerHTML = headerHTML + contentHTML + footerHTML;
        
        return page;
      },
      
      /**
       * Render a single verse line (array of transcribed words) to HTML
       */
      renderVerseLine(transcribedWords) {
        if (!transcribedWords || !transcribedWords.length) return '';
        
        const wordStacksHTML = transcribedWords.map((tw, wordIdx) => {
          const classes = ['word-stack'];
          if (tw.isProclitic) classes.push('proclitic');
          if (tw.isEnclitic) classes.push('enclitic');
          if (tw.isVowellessClitic) classes.push('vowelless-clitic');
          if (tw.wordData?.stressSource === 'default') classes.push('stress-unverified');
          
          // Build data attributes
          const dataAttrs = `
            data-word-id="${tw.lineIdx}-${tw.wordIdx}"
            data-line-index="${tw.lineIdx}"
            data-word-index="${tw.wordIdx}"
            data-cyrillic="${tw.cleanWord}"
            data-ipa="${tw.ipaSurface}"
            data-ipa-underlying="${tw.ipaUnderlying}"
            data-gloss="${tw.wordData?.gloss || ''}"
            data-pos="${tw.wordData?.pos || ''}"
            data-lemma="${tw.wordData?.lemma || ''}"
            data-punctuation="${tw.punct}"
            data-syllables='${JSON.stringify(tw.syllables)}'
            data-is-proclitic="${tw.isProclitic}"
            data-is-enclitic="${tw.isEnclitic}"
            data-is-o_-interjection="${tw.isO_Interjection || false}"
            data-is-first-word="${tw.isFirstWord || false}"
            data-line-ends-with-question="${tw.lineEndsWithQuestion || false}"
            data-proclitic-position="${tw.procliticPosition || ''}"
            data-has-yo="${tw.hasYo}"
            data-stress-source="${tw.wordData?.stressSource || ''}"
            data-right-boundary="${tw.rightBoundary || ''}"
            data-boundary-source="${tw.boundarySource || ''}"
            data-transcription-log='${JSON.stringify(tw.transcriptionLog || [])}'
            data-original-input="${tw.wordData?.originalInput || ''}"
            data-dictionary-form="${tw.wordData?.dictionaryForm || ''}"
            data-yo-source="${tw.wordData?.yoSource || ''}"
          `;
          
          return `
            <div class="${classes.join(' ')}" tabindex="0" ${dataAttrs}>
              <span class="ipa">${tw.ipaDisplay}</span>
              <span class="cyrillic">${addStressMarkToCyrillic(tw.cleanWord, tw.syllables)}<span class="punct">${tw.punct}</span></span>
              <span class="gloss">${tw.isProclitic || tw.isEnclitic 
                ? (GraysonEngine.cliticData.get(tw.cleanWord.toLowerCase())?.gloss || '')
                : formatGlossForDisplay(tw.wordData?.gloss, tw.wordData?.pos, tw.wordData?.lemma, tw.cleanWord)}</span>
            </div>
          `;
        }).join('');
        
        return `<div class="verse-line" role="row">${wordStacksHTML}</div>`;
      },
      
      /**
       * Transcribe all lines (Phase 1-2.5)
       * Returns array of arrays of transcribed word objects
       */
      transcribeAllLines() {
        return DocumentState.lines.map((line, lineIdx) => {
          // PHASE 1: Transcribe all words, store ipaUnderlying
          const transcribedWords = line.map((wordData, wordIdx) => {
            // Capture trailing punctuation explicitly (v5.11.11 - fixes ghost text bug K)
            const trailingPunctMatch = wordData.cyrillic.match(/[.,!?;:"""'']+$/);
            const punct = trailingPunctMatch ? trailingPunctMatch[0] : '';
            const cleanWord = wordData.cyrillic
              .replace(/[.,!?;:"""'']+$/, '')  // Remove trailing punct
              .replace(/[-–—]/g, '');           // Remove hyphens/dashes (keep word intact)
            
            // Detect if line ends with question mark
            const lineText = line.map(w => w.cyrillic).join(' ');
            const lineEndsWithQuestion = /\?$/.test(lineText.trim());
            const isFirstWord = wordIdx === 0;
            
            // Special case: "о" as interjection vs preposition
            const isO_Word = cleanWord.toLowerCase() === 'о';
            const hasFollowingPunct = /[,!]/.test(punct);
            const isO_Interjection = isO_Word && (
              hasFollowingPunct ||
              (isFirstWord && !lineEndsWithQuestion)
            );
            
            const isProclitic = !isO_Interjection && GraysonEngine.proclitics.has(cleanWord.toLowerCase());
            const isEnclitic = GraysonEngine.enclitics.has(cleanWord.toLowerCase());
            const hasYo = GraysonEngine.hasYo(cleanWord);
            
            // For proclitics, determine reduction based on host word's stress position
            let procliticPosition = null;
            if (isProclitic && wordIdx < line.length - 1) {
              const nextWord = line[wordIdx + 1];
              const nextStress = nextWord.stress;
              procliticPosition = (nextStress === 0) ? 'pretonic' : 'remote';
            }
            
            const cliticStress = (isProclitic || isEnclitic) ? -1 : wordData.stress;
            const result = GraysonEngine.transcribe(cleanWord, cliticStress, isProclitic || isEnclitic, procliticPosition);
            
            return {
              wordData,
              wordIdx,
              lineIdx,
              cleanWord,
              punct,
              isProclitic,
              isEnclitic,
              isO_Interjection,
              isFirstWord,
              lineEndsWithQuestion,
              procliticPosition,
              hasYo,
              syllables: result.syllables,
              ipaUnderlying: result.ipaUnderlying,
              transcriptionLog: result.transcriptionLog,
              ipaSurface: null,
              skipFinalDevoicing: false,
              rightBoundary: wordData.rightBoundary,
              boundarySource: wordData.boundarySource
            };
          });
          
          // PHASE 2: Apply cross-word assimilation
          GraysonEngine.applyCrossWordAssimilation(transcribedWords);
          
          // PHASE 2.5: Sync syllable IPA with surface form after final devoicing
          transcribedWords.forEach(tw => {
            if (tw.ipaSurface !== tw.ipaUnderlying && tw.syllables.length > 0) {
              const lastSyl = tw.syllables[tw.syllables.length - 1];
              const underlyingConcat = tw.syllables.map(s => s.ipa).join('');
              // Remove stress marks AND spaces from surface for comparison
              const surfaceClean = tw.ipaSurface.replace(/[ˈ\s]+/g, '');
              
              const prefixLen = underlyingConcat.length - lastSyl.ipa.length;
              
              if (surfaceClean.length >= prefixLen) {
                const newLastSylIpa = surfaceClean.slice(prefixLen);
                lastSyl.ipa = newLastSylIpa;
                
                if (tw.transcriptionLog && tw.transcriptionLog.length > 0) {
                  for (let i = tw.transcriptionLog.length - 1; i >= 0; i--) {
                    const entry = tw.transcriptionLog[i];
                    if (entry.features && entry.features.type === 'consonant') {
                      const devoicingMap = GraysonEngine.voicedToVoiceless;
                      if (devoicingMap[entry.ipa]) {
                        entry.ipa = devoicingMap[entry.ipa];
                        entry.features.finalDevoicing = true;
                      }
                      break;
                    }
                  }
                }
              }
            }
            
            // Create IPA content (syllables with stress marks, spaces between)
            // v5.11.11: Show stress marks on monosyllables too (Issue L)
            let ipaCore;
            
            // If cross-word assimilation modified ipaSurface, use that directly
            // (e.g., sibilant merger: шумом after с → ˈʃːumʌm)
            if (tw.ipaSurface !== tw.ipaUnderlying) {
              ipaCore = tw.ipaSurface;
            } else {
              // Normal case: build from syllables
              ipaCore = tw.syllables.map(s => {
                return s.isStressed ? 'ˈ' + s.ipa : s.ipa;
              }).join(' ');
            }
            
            // Store the actual IPA for fusion (v5.11.10)
            tw.ipaContent = ipaCore;
            tw.ipaDisplay = ipaCore; // Will be overwritten for clitics
          });
          
          // PHASE 2.6: Clitic IPA fusion (v5.11.20)
          // Vowelless clitics fuse directly (no space, no arrow) - they're not syllables
          // Vowelled clitics keep space (they ARE syllables) and show directional arrows
          // Use canonicalIpa from cliticData ONLY for vowelless clitics (syllabification fails)
          // For vowelled clitics, use the dynamically calculated IPA (position-aware reduction)
          const cyrillicVowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                                          'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
          const hasVowel = (word) => {
            return Array.from(word).some(char => cyrillicVowels.has(char));
          };
          
          transcribedWords.forEach((tw, idx) => {
            if (tw.isProclitic || tw.isEnclitic) {
              const isVowelless = !hasVowel(tw.cleanWord);
              if (isVowelless) {
                // Vowelless clitic: check if cross-word assimilation modified ipaSurface
                // If ipaSurface differs from ipaUnderlying, use the modified version
                // (e.g., sibilant merger: с + шумом → ipaSurface is empty, /s/ merged into host)
                if (tw.ipaSurface !== tw.ipaUnderlying) {
                  tw.ipaContent = tw.ipaSurface; // Use modified (possibly empty) IPA
                } else {
                  // No cross-word modification: use canonical IPA
                  const cliticInfo = GraysonEngine.cliticData.get(tw.cleanWord.toLowerCase());
                  tw.ipaContent = cliticInfo?.canonicalIpa || tw.ipaContent || '';
                }
              }
              // Vowelled clitics: keep dynamically calculated ipaContent (position-aware)
            }
            
            if (tw.isProclitic) {
              const nextWord = transcribedWords[idx + 1];
              const isVowelless = !hasVowel(tw.cleanWord);
              
              if (isVowelless) {
                // Vowelless proclitic: show arrow, fuse IPA to host
                tw.ipaDisplay = '→'; // Arrow shows attachment direction
                tw.isVowellessClitic = true;
                if (nextWord && !nextWord.isProclitic) {
                  // Fuse directly (no space)
                  // If host starts with stress mark, move it before the proclitic consonant
                  // Wrong: vˈstranst (stress mark after onset consonant)
                  // Right: ˈvstranst (stress mark before entire syllable onset)
                  if (nextWord.ipaDisplay.startsWith('ˈ')) {
                    nextWord.ipaDisplay = 'ˈ' + tw.ipaContent + nextWord.ipaDisplay.slice(1);
                  } else {
                    nextWord.ipaDisplay = tw.ipaContent + nextWord.ipaDisplay;
                  }
                }
              } else {
                // Vowelled proclitic: show arrow, keep as separate syllable
                tw.ipaDisplay = '→';
                tw.isVowellessClitic = false;
                if (nextWord && !nextWord.isProclitic) {
                  // Prepend with space (clitic is a syllable)
                  nextWord.ipaDisplay = tw.ipaContent + ' ' + nextWord.ipaDisplay;
                }
              }
            } else if (tw.isEnclitic) {
              const prevWord = transcribedWords[idx - 1];
              const isVowelless = !hasVowel(tw.cleanWord);
              
              if (isVowelless) {
                // Vowelless enclitic: show arrow, fuse IPA to host
                tw.ipaDisplay = '←'; // Arrow shows attachment direction
                tw.isVowellessClitic = true;
                if (prevWord && !prevWord.isEnclitic) {
                  // Fuse directly (no space)
                  prevWord.ipaDisplay = prevWord.ipaDisplay + tw.ipaContent;
                }
              } else {
                // Vowelled enclitic: show arrow, keep as separate syllable
                tw.ipaDisplay = '←';
                tw.isVowellessClitic = false;
                if (prevWord && !prevWord.isEnclitic) {
                  // Append with space (clitic is a syllable)
                  prevWord.ipaDisplay = prevWord.ipaDisplay + ' ' + tw.ipaContent;
                }
              }
            }
          });
          
          return transcribedWords;
        });
      },
      
      // ========================================
      // OCR Methods
      // ========================================
      
      /**
       * Initialize OCR module (lazy-loads Tesseract in background)
       */
      async initOCR() {
        if (!OCRModule.isSupported()) {
          console.log('OCR not supported in this browser');
          this.ocrScanBtn.style.display = 'none';
          return;
        }
        
        // Set up error callback
        OCRModule.onError((msg) => {
          console.warn('OCR error:', msg);
          this.showOCRStatus('error', msg);
        });
        
        // Scan button triggers hidden file input
        this.ocrScanBtn.addEventListener('click', () => {
          if (!this.ocrScanBtn.disabled) {
            this.ocrFileInput.click();
          }
        });
        
        // File selected → process
        this.ocrFileInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          await this.processOCRFile(file);
          // Reset input for re-use
          this.ocrFileInput.value = '';
        });
        
        // Start lazy-loading Tesseract
        try {
          const loaded = await OCRModule.init();
          if (loaded) {
            this.ocrScanBtn.disabled = false;
            this.ocrScanBtn.title = 'Import Russian text from image';
          }
        } catch (err) {
          console.error('OCR init failed:', err);
          this.ocrScanBtn.title = 'OCR unavailable';
        }
      },
      
      /**
       * Process uploaded image file through OCR
       */
      async processOCRFile(file) {
        // Hide normal status, show OCR status
        document.getElementById('charCounter')?.classList.remove('visible');
        document.getElementById('autoSaved')?.classList.remove('visible');
        
        // Status message mapping (Kimi's "narrated steps")
        const statusMessages = {
          'loading tesseract': 'Loading recognition engine...',
          'loading language': 'Loading Russian dictionary...',
          'loading eng+rus traineddata': 'Loading Russian dictionary...',
          'loaded eng+rus traineddata': 'Dictionary loaded.',
          'processing': 'Analyzing image...',
          'recognizing text': 'Reading Cyrillic text...',
          'recognizing': 'Reading Cyrillic text...',
          'cleaning': 'Cleaning up results...'
        };
        
        try {
          const text = await OCRModule.processImage(file, (status, progress) => {
            const message = statusMessages[status] || status;
            this.showOCRStatus('processing', message);
          });
          
          if (text) {
            // Append to existing text with newline separator if not empty
            const existingText = this.textInput.value.trim();
            if (existingText) {
              this.textInput.value = existingText + '\n\n' + text;
            } else {
              this.textInput.value = text;
            }
            
            this.updatePreview();
            this.showOCRStatus('success', 'Import complete');
            
            // Clear success message after 3 seconds
            setTimeout(() => this.hideOCRStatus(), 3000);
          }
        } catch (err) {
          console.error('OCR processing failed:', err);
          this.showOCRStatus('error', err.message || 'Failed to read image');
          
          // Clear error after 5 seconds
          setTimeout(() => this.hideOCRStatus(), 5000);
        }
      },
      
      /**
       * Show OCR status message
       */
      showOCRStatus(type, message) {
        if (!this.ocrStatus) return;
        
        this.ocrStatus.style.display = 'flex';
        this.ocrStatus.className = 'ocr-status ' + type;
        
        if (this.ocrStatusText) {
          this.ocrStatusText.textContent = message;
        }
        
        // Show/hide spinner based on type
        const spinner = this.ocrStatus.querySelector('.spinner');
        if (spinner) {
          spinner.style.display = type === 'processing' ? 'block' : 'none';
        }
      },
      
      /**
       * Hide OCR status and restore normal footer status
       */
      hideOCRStatus() {
        if (this.ocrStatus) {
          this.ocrStatus.style.display = 'none';
        }
        // Let updatePreview restore char counter if needed
        this.updatePreview();
      }
    };

    /* ========================================
       LOOKUP TABLES: Composers and Poets
       ======================================== */
    const COMPOSERS = [
      { latin: 'Rachmaninoff, Sergei', cyrillic: 'Рахманинов, Сергей', dates: '1873–1943' },
      { latin: 'Tchaikovsky, Pyotr', cyrillic: 'Чайковский, Пётр', dates: '1840–1893' },
      { latin: 'Mussorgsky, Modest', cyrillic: 'Мусоргский, Модест', dates: '1839–1881' },
      { latin: 'Rimsky-Korsakov, Nikolai', cyrillic: 'Римский-Корсаков, Николай', dates: '1844–1908' },
      { latin: 'Glinka, Mikhail', cyrillic: 'Глинка, Михаил', dates: '1804–1857' },
      { latin: 'Borodin, Alexander', cyrillic: 'Бородин, Александр', dates: '1833–1887' },
      { latin: 'Cui, César', cyrillic: 'Кюи, Цезарь', dates: '1835–1918' },
      { latin: 'Dargomyzhsky, Alexander', cyrillic: 'Даргомыжский, Александр', dates: '1813–1869' },
      { latin: 'Arensky, Anton', cyrillic: 'Аренский, Антон', dates: '1861–1906' },
      { latin: 'Medtner, Nikolai', cyrillic: 'Метнер, Николай', dates: '1880–1951' },
      { latin: 'Taneyev, Sergei', cyrillic: 'Танеев, Сергей', dates: '1856–1915' },
      { latin: 'Gretchaninov, Alexander', cyrillic: 'Гречанинов, Александр', dates: '1864–1956' },
      { latin: 'Glazunov, Alexander', cyrillic: 'Глазунов, Александр', dates: '1865–1936' },
      { latin: 'Rubinstein, Anton', cyrillic: 'Рубинштейн, Антон', dates: '1829–1894' },
      { latin: 'Balakirev, Mily', cyrillic: 'Балакирев, Милий', dates: '1837–1910' },
      { latin: 'Prokofiev, Sergei', cyrillic: 'Прокофьев, Сергей', dates: '1891–1953' },
      { latin: 'Shostakovich, Dmitri', cyrillic: 'Шостакович, Дмитрий', dates: '1906–1975' },
      { latin: 'Stravinsky, Igor', cyrillic: 'Стравинский, Игорь', dates: '1882–1971' },
      { latin: 'Scriabin, Alexander', cyrillic: 'Скрябин, Александр', dates: '1872–1915' },
      { latin: 'Kabalevsky, Dmitri', cyrillic: 'Кабалевский, Дмитрий', dates: '1904–1987' },
      { latin: 'Sviridov, Georgy', cyrillic: 'Свиридов, Георгий', dates: '1915–1998' },
      { latin: 'Varlamov, Alexander', cyrillic: 'Варламов, Александр', dates: '1801–1848' },
      { latin: 'Gurilev, Alexander', cyrillic: 'Гурилёв, Александр', dates: '1803–1858' },
      { latin: 'Bulakhov, Pyotr', cyrillic: 'Булахов, Пётр', dates: '1822–1885' },
      { latin: 'Titov, Nikolai', cyrillic: 'Титов, Николай', dates: '1800–1875' }
    ];

    const POETS = [
      { latin: 'Pushkin, Alexander', cyrillic: 'Пушкин, Александр', dates: '1799–1837' },
      { latin: 'Lermontov, Mikhail', cyrillic: 'Лермонтов, Михаил', dates: '1814–1841' },
      { latin: 'Tyutchev, Fyodor', cyrillic: 'Тютчев, Фёдор', dates: '1803–1873' },
      { latin: 'Fet, Afanasy', cyrillic: 'Фет, Афанасий', dates: '1820–1892' },
      { latin: 'Tolstoy, Alexei K.', cyrillic: 'Толстой, Алексей К.', dates: '1817–1875' },
      { latin: 'Nekrasov, Nikolai', cyrillic: 'Некрасов, Николай', dates: '1821–1878' },
      { latin: 'Koltsov, Alexei', cyrillic: 'Кольцов, Алексей', dates: '1809–1842' },
      { latin: 'Maykov, Apollon', cyrillic: 'Майков, Аполлон', dates: '1821–1897' },
      { latin: 'Pleshcheyev, Alexei', cyrillic: 'Плещеев, Алексей', dates: '1825–1893' },
      { latin: 'Polonsky, Yakov', cyrillic: 'Полонский, Яков', dates: '1819–1898' },
      { latin: 'Mey, Lev', cyrillic: 'Мей, Лев', dates: '1822–1862' },
      { latin: 'Apukhtin, Alexei', cyrillic: 'Апухтин, Алексей', dates: '1840–1893' },
      { latin: 'Rathaus, Daniil', cyrillic: 'Ратгауз, Даниил', dates: '1868–1937' },
      { latin: 'Galina, Glafira', cyrillic: 'Галина, Глафира', dates: '1870–1942' },
      { latin: 'Balmont, Konstantin', cyrillic: 'Бальмонт, Константин', dates: '1867–1942' },
      { latin: 'Bryusov, Valery', cyrillic: 'Брюсов, Валерий', dates: '1873–1924' },
      { latin: 'Blok, Alexander', cyrillic: 'Блок, Александр', dates: '1880–1921' },
      { latin: 'Akhmatova, Anna', cyrillic: 'Ахматова, Анна', dates: '1889–1966' },
      { latin: 'Tsvetaeva, Marina', cyrillic: 'Цветаева, Марина', dates: '1892–1941' },
      { latin: 'Yesenin, Sergei', cyrillic: 'Есенин, Сергей', dates: '1895–1925' },
      { latin: 'Mandelstam, Osip', cyrillic: 'Мандельштам, Осип', dates: '1891–1938' },
      { latin: 'Pasternak, Boris', cyrillic: 'Пастернак, Борис', dates: '1890–1960' },
      { latin: 'Zhukovsky, Vasily', cyrillic: 'Жуковский, Василий', dates: '1783–1852' },
      { latin: 'Baratynsky, Yevgeny', cyrillic: 'Баратынский, Евгений', dates: '1800–1844' },
      { latin: 'Delvig, Anton', cyrillic: 'Дельвиг, Антон', dates: '1798–1831' },
      { latin: 'Khomyakov, Alexei', cyrillic: 'Хомяков, Алексей', dates: '1804–1860' },
      { latin: 'Golenishchev-Kutuzov, Arseny', cyrillic: 'Голенищев-Кутузов, Арсений', dates: '1848–1913' },
      { latin: 'Merezhkovsky, Dmitry', cyrillic: 'Мережковский, Дмитрий', dates: '1865–1941' },
      { latin: 'Gippius, Zinaida', cyrillic: 'Гиппиус, Зинаида', dates: '1869–1945' },
      { latin: 'Sologub, Fyodor', cyrillic: 'Сологуб, Фёдор', dates: '1863–1927' },
      { latin: 'Bely, Andrei', cyrillic: 'Белый, Андрей', dates: '1880–1934' },
      { latin: 'Bunin, Ivan', cyrillic: 'Бунин, Иван', dates: '1870–1953' },
      { latin: 'Shevchenko, Taras', cyrillic: 'Шевченко, Тарас', dates: '1814–1861' },
      { latin: 'Heine, Heinrich', cyrillic: 'Гейне, Генрих', dates: '1797–1856' },
      { latin: 'Goethe, Johann Wolfgang', cyrillic: 'Гёте, Иоганн Вольфганг', dates: '1749–1832' }
    ];


    /* ========================================
       STRESS DICTIONARY (OpenRussian, 51,644 words)
       CC-BY-SA-4.0 License
       ======================================== */
;

    /* ========================================
       GRAYSON ENGINE
       ======================================== */
    const GraysonEngine = {
      
      inventory: Object.freeze({
        vowels_stressed: {
          'а': 'ɑ', 'а_interpalatal': 'a',
          'о': 'o',
          'е': 'ɛ', 'е_interpalatal': 'e',
          'ё': 'o',
          'и': 'i',
          'ы': 'ɨ',
          'у': 'u',
          'ю': 'u',
          'я': 'ɑ', 'я_interpalatal': 'a',
          'э': 'ɛ'
        },
        vowels_unstressed: {
          'а_pretonic': 'ɑ', 'а_remote': 'ʌ',
          'о_pretonic': 'ɑ', 'о_remote': 'ʌ',
          'е_unstressed': 'ɪ',
          'и': 'i',
          'ы_unstressed': 'ɨ',
          'у_unstressed': 'u',
          'ю_unstressed': 'u',
          'я_unstressed': 'ɪ',
          'э_unstressed': 'ɪ'
        },
        consonants: {
          'б': 'b', 'п': 'p',
          'в': 'v', 'ф': 'f',
          'д': 'd', 'т': 't',
          'г': 'ɡ', 'к': 'k',
          'з': 'z', 'с': 's',
          'ж': 'ʒ', 'ш': 'ʃ',
          'х': 'x',
          'ц': 'ts',
          'ч': 'tʃʲ',
          'щ': 'ʃʲʃʲ',
          'л': 'l', 'л_hard': 'ɫ', 'л_soft': 'lʲ',
          'м': 'm',
          'н': 'n', 'н_soft': 'ɲ',
          'р': 'r',
          'й': 'j'
        },
        markers: {
          'palatalization': 'ʲ',
          'stress': 'ˈ'
        }
      }),
      
      vowels: new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я']),
      consonants: new Set(['б', 'в', 'г', 'д', 'ж', 'з', 'й', 'к', 'л', 'м', 'н', 'п', 'р', 'с', 'т', 'ф', 'х', 'ц', 'ч', 'ш', 'щ']),
      alwaysSoft: new Set(['ч', 'щ', 'й']),
      alwaysHard: new Set(['ж', 'ш', 'ц']),
      
      // Clitic data with canonical IPA for isolated forms (Grayson p. 248-257)
      // Canonical forms use pretonic reduction for proclitics, posttonic for enclitics
      cliticData: new Map([
        // Proclitics - canonical form assumes pretonic position
        // Short glosses curated for PDF display (v5.11.10)
        ['в', { type: 'proclitic', canonicalIpa: 'v', gloss: 'in/into' }],
        ['во', { type: 'proclitic', canonicalIpa: 'vɑ', gloss: 'in/into' }],
        ['к', { type: 'proclitic', canonicalIpa: 'k', gloss: 'to/toward' }],
        ['ко', { type: 'proclitic', canonicalIpa: 'kɑ', gloss: 'to/toward' }],
        ['с', { type: 'proclitic', canonicalIpa: 's', gloss: 'with/from' }],
        ['со', { type: 'proclitic', canonicalIpa: 'sɑ', gloss: 'with/from' }],
        ['о', { type: 'proclitic', canonicalIpa: 'ɑ', gloss: 'about' }],
        ['об', { type: 'proclitic', canonicalIpa: 'ɑb', gloss: 'about' }],
        ['обо', { type: 'proclitic', canonicalIpa: 'ɑbɑ', gloss: 'about' }],
        ['у', { type: 'proclitic', canonicalIpa: 'u', gloss: 'at/by' }],
        ['на', { type: 'proclitic', canonicalIpa: 'nɑ', gloss: 'on/onto' }],
        ['за', { type: 'proclitic', canonicalIpa: 'zɑ', gloss: 'behind/for' }],
        ['по', { type: 'proclitic', canonicalIpa: 'pɑ', gloss: 'along/by' }],
        ['до', { type: 'proclitic', canonicalIpa: 'dɑ', gloss: 'until/to' }],
        ['из', { type: 'proclitic', canonicalIpa: 'iz', gloss: 'from/out of' }],
        ['изо', { type: 'proclitic', canonicalIpa: 'izɑ', gloss: 'from/out of' }],
        ['от', { type: 'proclitic', canonicalIpa: 'ɑt', gloss: 'from' }],
        ['ото', { type: 'proclitic', canonicalIpa: 'ɑtɑ', gloss: 'from' }],
        ['без', { type: 'proclitic', canonicalIpa: 'bʲɪz', gloss: 'without' }],
        ['не', { type: 'proclitic', canonicalIpa: 'ɲɪ', gloss: 'not' }],
        ['ни', { type: 'proclitic', canonicalIpa: 'ɲi', gloss: 'nor/not' }],
        ['над', { type: 'proclitic', canonicalIpa: 'nɑt', gloss: 'above' }],
        ['надо', { type: 'proclitic', canonicalIpa: 'nɑdɑ', gloss: 'above' }],
        ['под', { type: 'proclitic', canonicalIpa: 'pɑt', gloss: 'under' }],
        ['подо', { type: 'proclitic', canonicalIpa: 'pɑdɑ', gloss: 'under' }],
        ['при', { type: 'proclitic', canonicalIpa: 'prʲi', gloss: 'at/near' }],
        ['про', { type: 'proclitic', canonicalIpa: 'prɑ', gloss: 'about' }],
        ['для', { type: 'proclitic', canonicalIpa: 'dlʲɑ', gloss: 'for' }],
        ['через', { type: 'proclitic', canonicalIpa: 'tʃʲɪrʲɪz', gloss: 'through' }],
        ['перед', { type: 'proclitic', canonicalIpa: 'pʲɪrʲɪt', gloss: 'before' }],
        ['передо', { type: 'proclitic', canonicalIpa: 'pʲɪrʲɪdɑ', gloss: 'before' }],
        // Enclitics - canonical form assumes posttonic position
        ['ли', { type: 'enclitic', canonicalIpa: 'lʲi', gloss: '(question)' }],
        ['ль', { type: 'enclitic', canonicalIpa: 'lʲ', gloss: '(question)' }],
        ['же', { type: 'enclitic', canonicalIpa: 'ʒɨ', gloss: '(emphasis)' }],
        ['бы', { type: 'enclitic', canonicalIpa: 'bɨ', gloss: 'would' }],
        ['б', { type: 'enclitic', canonicalIpa: 'b', gloss: 'would' }],
        ['то', { type: 'enclitic', canonicalIpa: 'tɑ', gloss: '(then)' }],
        ['ка', { type: 'enclitic', canonicalIpa: 'kɑ', gloss: '(urging)' }],
        ['таки', { type: 'enclitic', canonicalIpa: 'tɑkʲi', gloss: 'after all' }],
      ]),
      
      // Derived Sets for backwards compatibility (computed once, not on every access)
      proclitics: null, // Initialized below
      enclitics: null,  // Initialized below
      
      // Regressive palatalization categorical restrictions (Grayson p. 209; Derwing & Priestly pp. 76-87)
      // These consonants BLOCK regressive palatalization — consonants before them do not soften
      // NOTE: Grayson's example сестрёнка /sʲtʲrʲ/ appears to be an error; D&P pp. 85-87 confirms
      // that р blocks regressive palatalization. <em>Ilya</em> follows D&P: сестрёнка → /strʲ/
      regressivePalatalizationBlockers: new Set(['р', 'л']), // р and л block regressive palatalization (except doubled)
      
      // Categorical restrictions for regressive palatalization (Grayson p. 209)
      // Velars only palatalize before palatalized velars
      velars: new Set(['к', 'г', 'х']),
      // Labials only palatalize before palatalized labials
      labials: new Set(['б', 'п', 'в', 'ф', 'м']),
      // Dentals palatalize more freely
      dentals: new Set(['т', 'д', 'с', 'з', 'н', 'ц']),
      // н only palatalizes before palatalized н or dental
      
      // Special consonant clusters (Grayson p. 225-247)
      // These are detected and transcribed as units before letter-by-letter processing
      specialClusters: {
        'сч': 'ʃʲʃʲ',   // Same as щ (p. 230-231)
        'зч': 'ʃʲʃʲ',   // Same as щ (p. 230-231)
        // Sibilant mergers (Grayson pp. 235-236)
        'сш': 'ʃː',     // с + ш → long unvoiced postalveolar (p. 235)
        'зш': 'ʃː',     // з + ш → long unvoiced postalveolar (devoices, p. 235)
        'сж': 'ʒː',     // с + ж → long voiced postalveolar (voices, p. 236)
        'зж': 'ʒː',     // з + ж → long voiced postalveolar (p. 236)
      },
      
      // Reflexive verb suffix clusters (Grayson p. 237-238)
      // "The clusters -тс-/-дс- and -тьс-/-дьс- resemble /ts/ but have an elongated stop"
      // These are ONLY checked at word end (suffix position)
      reflexiveSuffixes: {
        'ться': 'tːsʌ',  // купаться → /kuˈpɑtːsʌ/
        'тся': 'tːsʌ',   // боится → /bɑˈitːsʌ/
      },
      
      // Word-specific cluster overrides (p. 239-240)
      wordSpecificClusters: {
        'конечно': { 'чн': 'ʃn' },
        'скучно': { 'чн': 'ʃn' },
        'скучный': { 'чн': 'ʃn' },
        'нарочно': { 'чн': 'ʃn' },
        'яичница': { 'чн': 'ʃn' },
        'что': { 'чт': 'ʃt' },
        'чтоб': { 'чт': 'ʃt' },
        'чтобы': { 'чт': 'ʃt' },
        'ничто': { 'чт': 'ʃt' },
        // русский exception (Grayson p. 233): single /s/, not geminate
        // Also overrides Old Muscovite -кий rule — uses modern soft кʲ
        'русский': { 'сс': 's' },
        'русская': { 'сс': 's' },
        'русское': { 'сс': 's' },
        'русские': { 'сс': 's' },
        'русского': { 'сс': 's' },
        'русскому': { 'сс': 's' },
        'русским': { 'сс': 's' },
        'русскими': { 'сс': 's' },
        'русской': { 'сс': 's' },
        'русских': { 'сс': 's' },
        'русскую': { 'сс': 's' },
        'русском': { 'сс': 's' },
        // Silent consonant exceptions (Grayson p. 235-236)
        // сердце family: рдц → рц (д silent)
        'сердце': { 'рдц': 'rts' },
        'сердца': { 'рдц': 'rts' },
        'сердцу': { 'рдц': 'rts' },
        'сердцем': { 'рдц': 'rts' },
        // солнце family: лнц → нц (л silent)
        'солнце': { 'лнц': 'nts' },
        'солнца': { 'лнц': 'nts' },
        'солнцу': { 'лнц': 'nts' },
        'солнцем': { 'лнц': 'nts' },
        // здравствуй family: вств → ств (first в silent)
        'здравствуй': { 'вств': 'stv' },
        'здравствуйте': { 'вств': 'stv' },
        'здравствуют': { 'вств': 'stv' },
        // чувство family: вств → ств (first в silent)
        'чувство': { 'вств': 'stv' },
        'чувства': { 'вств': 'stv' },
        'чувствам': { 'вств': 'stv' },
        'чувствами': { 'вств': 'stv' },
        'чувствах': { 'вств': 'stv' },
        'чувствую': { 'вств': 'stv' },
        'чувствует': { 'вств': 'stv' },
        'чувствовать': { 'вств': 'stv' },
        // бесчувственный family: вств → ств (first в silent)
        'бесчувственный': { 'вств': 'stv' },
        'бесчувственная': { 'вств': 'stv' },
        'бесчувственное': { 'вств': 'stv' },
        'бесчувственные': { 'вств': 'stv' },
        'бесчувственного': { 'вств': 'stv' },
        'бесчувственной': { 'вств': 'stv' },
        'бесчувственному': { 'вств': 'stv' },
        'бесчувственным': { 'вств': 'stv' },
        'бесчувственными': { 'вств': 'stv' },
        'бесчувственных': { 'вств': 'stv' },
        'бесчувственную': { 'вств': 'stv' },
        'бесчувственном': { 'вств': 'stv' },
        // Silent т in стн cluster (Grayson p. 235)
        // честный family (honest)
        'честный': { 'стн': 'sn' },
        'честная': { 'стн': 'sn' },
        'честное': { 'стн': 'sn' },
        'честные': { 'стн': 'sn' },
        'честного': { 'стн': 'sn' },
        'честной': { 'стн': 'sn' },
        'честному': { 'стн': 'sn' },
        'честным': { 'стн': 'sn' },
        'честными': { 'стн': 'sn' },
        'честных': { 'стн': 'sn' },
        'честную': { 'стн': 'sn' },
        'честном': { 'стн': 'sn' },
        'честно': { 'стн': 'sn' },
        // известный family (famous)
        'известный': { 'стн': 'sn' },
        'известная': { 'стн': 'sn' },
        'известное': { 'стн': 'sn' },
        'известные': { 'стн': 'sn' },
        'известного': { 'стн': 'sn' },
        'известной': { 'стн': 'sn' },
        'известному': { 'стн': 'sn' },
        'известным': { 'стн': 'sn' },
        'известными': { 'стн': 'sn' },
        'известных': { 'стн': 'sn' },
        'известную': { 'стн': 'sn' },
        'известном': { 'стн': 'sn' },
        'известно': { 'стн': 'sn' },
        // грустный family (sad)
        'грустный': { 'стн': 'sn' },
        'грустная': { 'стн': 'sn' },
        'грустное': { 'стн': 'sn' },
        'грустные': { 'стн': 'sn' },
        'грустного': { 'стн': 'sn' },
        'грустной': { 'стн': 'sn' },
        'грустному': { 'стн': 'sn' },
        'грустным': { 'стн': 'sn' },
        'грустными': { 'стн': 'sn' },
        'грустных': { 'стн': 'sn' },
        'грустную': { 'стн': 'sn' },
        'грустном': { 'стн': 'sn' },
        'грустно': { 'стн': 'sn' },
        // местный family (local)
        'местный': { 'стн': 'sn' },
        'местная': { 'стн': 'sn' },
        'местное': { 'стн': 'sn' },
        'местные': { 'стн': 'sn' },
        'местного': { 'стн': 'sn' },
        'местной': { 'стн': 'sn' },
        'местному': { 'стн': 'sn' },
        'местным': { 'стн': 'sn' },
        'местными': { 'стн': 'sn' },
        'местных': { 'стн': 'sn' },
        'местную': { 'стн': 'sn' },
        'местном': { 'стн': 'sn' },
        // частный family (private)
        'частный': { 'стн': 'sn' },
        'частная': { 'стн': 'sn' },
        'частное': { 'стн': 'sn' },
        'частные': { 'стн': 'sn' },
        'частного': { 'стн': 'sn' },
        'частной': { 'стн': 'sn' },
        'частному': { 'стн': 'sn' },
        'частным': { 'стн': 'sn' },
        'частными': { 'стн': 'sn' },
        'частных': { 'стн': 'sn' },
        'частную': { 'стн': 'sn' },
        'частном': { 'стн': 'sn' },
        'частно': { 'стн': 'sn' },
        // прелестный family (lovely)
        'прелестный': { 'стн': 'sn' },
        'прелестная': { 'стн': 'sn' },
        'прелестное': { 'стн': 'sn' },
        'прелестные': { 'стн': 'sn' },
        'прелестного': { 'стн': 'sn' },
        'прелестной': { 'стн': 'sn' },
        'прелестному': { 'стн': 'sn' },
        'прелестным': { 'стн': 'sn' },
        'прелестными': { 'стн': 'sn' },
        'прелестных': { 'стн': 'sn' },
        'прелестную': { 'стн': 'sn' },
        'прелестном': { 'стн': 'sn' },
        // Silent д in здн cluster (Grayson p. 235)
        // поздно family (late)
        'поздно': { 'здн': 'zn' },
        'поздний': { 'здн': 'zn' },
        'поздняя': { 'здн': 'zn' },
        'позднее': { 'здн': 'zn' },
        'поздние': { 'здн': 'zn' },
        'позднего': { 'здн': 'zn' },
        'поздней': { 'здн': 'zn' },
        'позднему': { 'здн': 'zn' },
        'поздним': { 'здн': 'zn' },
        'поздними': { 'здн': 'zn' },
        'поздних': { 'здн': 'zn' },
        'позднюю': { 'здн': 'zn' },
        'позднем': { 'здн': 'zn' },
        // праздник family (holiday)
        'праздник': { 'здн': 'zn' },
        'праздника': { 'здн': 'zn' },
        'праздникам': { 'здн': 'zn' },
        'праздниками': { 'здн': 'zn' },
        'праздниках': { 'здн': 'zn' },
        'праздники': { 'здн': 'zn' },
        'праздников': { 'здн': 'zn' },
        'праздником': { 'здн': 'zn' },
        'праздникам': { 'здн': 'zn' },
        'праздниках': { 'здн': 'zn' },
        'праздничный': { 'здн': 'zn' },
        'праздничная': { 'здн': 'zn' },
        'праздничное': { 'здн': 'zn' },
        'праздничные': { 'здн': 'zn' },
        'праздничного': { 'здн': 'zn' },
        'праздничной': { 'здн': 'zn' },
        'праздничному': { 'здн': 'zn' },
        'праздничным': { 'здн': 'zn' },
        'праздничными': { 'здн': 'zn' },
        'праздничных': { 'здн': 'zn' },
        'праздничную': { 'здн': 'zn' },
        'праздничном': { 'здн': 'zn' },
        // звёздный family (starry) - also has здн
        'звёздный': { 'здн': 'zn' },
        'звёздная': { 'здн': 'zn' },
        'звёздное': { 'здн': 'zn' },
        'звёздные': { 'здн': 'zn' },
        'звёздного': { 'здн': 'zn' },
        'звёздной': { 'здн': 'zn' },
        'звёздному': { 'здн': 'zn' },
        'звёздным': { 'здн': 'zn' },
        'звёздными': { 'здн': 'zn' },
        'звёздных': { 'здн': 'zn' },
        'звёздную': { 'здн': 'zn' },
        'звёздном': { 'здн': 'zn' },
      },
      
      // Exception words where normal phonological rules don't apply (Grayson Appendix F)
      exceptionWords: {
        'счастье': { vowelOverrides: { 2: 'ɑ' } },
        'счастья': { vowelOverrides: { 2: 'ɑ' } },
        'счастлив': { vowelOverrides: { 2: 'ɑ' } },
        'счастливый': { vowelOverrides: { 2: 'ɑ' } },
        // русский exception (Grayson p. 233): uses modern -кий (soft), not Old Muscovite
        'русский': { skipVelarAdjectival: true },
        'русская': { skipVelarAdjectival: true },
        'русское': { skipVelarAdjectival: true },
        'русские': { skipVelarAdjectival: true },
        'русского': { skipVelarAdjectival: true },
        'русскому': { skipVelarAdjectival: true },
        'русским': { skipVelarAdjectival: true },
        'русскими': { skipVelarAdjectival: true },
        'русской': { skipVelarAdjectival: true },
        'русских': { skipVelarAdjectival: true },
        'русскую': { skipVelarAdjectival: true },
        'русском': { skipVelarAdjectival: true },
      },
      
      // Find special clusters in a word
      findSpecialClusters(word) {
        const cleanWord = word.toLowerCase();
        const clusters = [];
        
        // Check word-specific clusters first (higher priority)
        const wordOverrides = this.wordSpecificClusters[cleanWord];
        if (wordOverrides) {
          for (const [cluster, ipa] of Object.entries(wordOverrides)) {
            let idx = cleanWord.indexOf(cluster);
            while (idx !== -1) {
              clusters.push({ 
                startIndex: idx, 
                endIndex: idx + cluster.length - 1,
                cluster: cluster, 
                ipa: ipa 
              });
              idx = cleanWord.indexOf(cluster, idx + 1);
            }
          }
        }
        
        // Check reflexive suffixes (only at word end)
        for (const [suffix, ipa] of Object.entries(this.reflexiveSuffixes)) {
          if (cleanWord.endsWith(suffix)) {
            const startIdx = cleanWord.length - suffix.length;
            clusters.push({
              startIndex: startIdx,
              endIndex: cleanWord.length - 1,
              cluster: suffix,
              ipa: ipa
            });
            break; // Only one reflexive suffix per word
          }
        }
        
        // Check universal clusters
        for (const [cluster, ipa] of Object.entries(this.specialClusters)) {
          let idx = cleanWord.indexOf(cluster);
          while (idx !== -1) {
            // Skip if already covered
            const alreadyCovered = clusters.some(c => 
              (idx >= c.startIndex && idx <= c.endIndex) ||
              (idx + cluster.length - 1 >= c.startIndex && idx + cluster.length - 1 <= c.endIndex)
            );
            if (!alreadyCovered) {
              clusters.push({ 
                startIndex: idx, 
                endIndex: idx + cluster.length - 1,
                cluster: cluster, 
                ipa: ipa 
              });
            }
            idx = cleanWord.indexOf(cluster, idx + 1);
          }
        }
        
        return clusters.sort((a, b) => a.startIndex - b.startIndex);
      },
      
      // Check for vowel override in exception words
      getVowelOverride(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const exception = this.exceptionWords[cleanWord];
        if (exception?.vowelOverrides?.[charIndex] !== undefined) {
          return exception.vowelOverrides[charIndex];
        }
        return null;
      },
      
      // Check for -ая/-яя suffix exception (Grayson p. 124)
      // Feminine adjective endings are ALWAYS sung as /ɑjɑ/, never reduced
      isAyaSuffixVowel(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Check if word ends in -ая or -яя
        if (len >= 2) {
          const ending = cleanWord.slice(-2);
          if (ending === 'ая' || ending === 'яя') {
            // Check if this charIndex is one of the two final vowels
            if (charIndex === len - 2 || charIndex === len - 1) {
              return true;
            }
          }
        }
        return false;
      },
      
      // Check for Old Muscovite adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
      // When profile is 'stage': velars stay hard, и → [ɨ], й → [j]
      // Returns: { isVelarAdjectival: bool, charRole: 'velar'|'i'|'j'|null }
      checkVelarAdjectival(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Check if this word is an exception (e.g., русский uses modern -кий)
        const exception = this.exceptionWords[cleanWord];
        if (exception?.skipVelarAdjectival) {
          return { isVelarAdjectival: false, charRole: null };
        }
        
        // Check if word ends in -кий, -гий, or -хий
        if (len >= 3) {
          const ending = cleanWord.slice(-3);
          const velars = ['кий', 'гий', 'хий'];
          
          if (velars.includes(ending)) {
            const suffixStart = len - 3;
            
            // Check which part of the suffix this charIndex is
            if (charIndex === suffixStart) {
              return { isVelarAdjectival: true, charRole: 'velar' };
            } else if (charIndex === suffixStart + 1) {
              return { isVelarAdjectival: true, charRole: 'i' };
            } else if (charIndex === suffixStart + 2) {
              return { isVelarAdjectival: true, charRole: 'j' };
            }
          }
        }
        return { isVelarAdjectival: false, charRole: null };
      },
      
      // Check for genitive ending -ого/-его where г → /v/ (Grayson p. 243)
      // Exception: много, строго, etc. where -ого is NOT a genitive ending
      checkGenitiveEnding(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Exceptions: words where -ого/-его is NOT a genitive ending
        const exceptions = new Set([
          'много', 'немного', 'строго', 'нестрого', 'убого', 
          'отлого', 'полого', 'дорого', 'недорого', 'другого' // 'другого' IS genitive, but listed in some sources
        ]);
        
        // Remove другого from exceptions - it IS a genitive form
        exceptions.delete('другого');
        
        if (exceptions.has(cleanWord)) {
          return false;
        }
        
        // Check if word ends in -ого or -его
        if (len >= 3) {
          const ending3 = cleanWord.slice(-3);
          if (ending3 === 'ого' || ending3 === 'его') {
            // The г is at position len - 2 (second to last character)
            const gPosition = len - 2;
            return charIndex === gPosition;
          }
        }
        
        return false;
      },
      
      // Look up stress from dictionary
      // Handles both old format and new kaikki format (including homographs)
      lookupStress(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // Helper to normalize entry format
        const normalizeEntry = (entry, source = 'dictionary') => {
          if (!entry) return null;
          
          // Handle homographs (arrays) - return first match for now, mark as homograph
          if (Array.isArray(entry)) {
            const firstEntry = entry[0];
            return {
              stress: firstEntry.stress ?? firstEntry.s,
              gloss: firstEntry.gloss ?? firstEntry.g ?? '',
              pos: firstEntry.pos ?? firstEntry.p ?? '',
              lemma: firstEntry.lemma ?? firstEntry.l ?? '',
              source: source,
              isHomograph: true,
              allEntries: entry,
              canonicalForm: cleanWord
            };
          }
          
          // Single entry
          return {
            stress: entry.stress ?? entry.s,
            gloss: entry.gloss ?? entry.g ?? '',
            pos: entry.pos ?? entry.p ?? '',
            lemma: entry.lemma ?? entry.l ?? '',
            source: entry.source || source,
            isHomograph: false,
            canonicalForm: cleanWord
          };
        };
        
        // Phase 1: Try exact match first (handles все/всё disambiguation)
        const exactEntry = STRESS_DICTIONARY[cleanWord];
        if (exactEntry) {
          return normalizeEntry(exactEntry, 'dictionary');
        }
        
        // Phase 1b: Check SINGER_SUPPLEMENT
        const supplementEntry = SINGER_SUPPLEMENT[cleanWord];
        if (supplementEntry) {
          return normalizeEntry(supplementEntry, 'supplement');
        }
        
        // Phase 2: Word not found — try ё-restoration
        // Russian publishers often omit the dieresis, printing ⟨е⟩ where ⟨ё⟩ should appear
        const chars = [...cleanWord];
        for (let i = 0; i < chars.length; i++) {
          if (chars[i] === 'е') {
            // Try substituting this е with ё
            const candidate = [...chars];
            candidate[i] = 'ё';
            const candidateWord = candidate.join('');
            
            const restoredEntry = STRESS_DICTIONARY[candidateWord] || SINGER_SUPPLEMENT[candidateWord];
            if (restoredEntry) {
              const result = normalizeEntry(restoredEntry, 'yo-restored');
              if (result) {
                result.canonicalForm = candidateWord;
                result.originalInput = cleanWord;
              }
              return result;
            }
          }
        }
        
        // Phase 2b: Try ё→е normalization
        // Some dictionaries store the е-form even when ё is correct
        // If user types ёлка but dictionary has елка, try that
        if (cleanWord.includes('ё')) {
          const normalizedWord = cleanWord.replace(/ё/g, 'е');
          const normalizedEntry = STRESS_DICTIONARY[normalizedWord] || SINGER_SUPPLEMENT[normalizedWord];
          if (normalizedEntry) {
            const result = normalizeEntry(normalizedEntry, 'yo-normalized');
            if (result) {
              result.canonicalForm = cleanWord; // Keep the ё form as canonical
              result.originalInput = cleanWord;
            }
            return result;
          }
        }
        
        // Phase 3: No match found
        return null;
      },
      
      // Apply the case pattern from original word to canonical form
      // Preserves uppercase/lowercase pattern when restoring ё
      applyCasePattern(original, canonical) {
        // Strip punctuation from original to get just letters
        const origLetters = original.replace(/[.,!?;:"""''–—]/g, '');
        const canonLetters = canonical;
        
        // If lengths don't match, just return canonical (shouldn't happen with е→ё)
        if (origLetters.length !== canonLetters.length) {
          return canonical;
        }
        
        // Apply case from original to canonical, character by character
        const result = [];
        for (let i = 0; i < canonLetters.length; i++) {
          const origChar = origLetters[i];
          const canonChar = canonLetters[i];
          
          // Check if original was uppercase
          if (origChar === origChar.toUpperCase() && origChar !== origChar.toLowerCase()) {
            // Original was uppercase — apply to canonical
            result.push(canonChar.toUpperCase());
          } else {
            result.push(canonChar.toLowerCase());
          }
        }
        
        // Re-append any trailing punctuation from original
        const trailingPunct = original.match(/[.,!?;:"""''–—]+$/);
        return result.join('') + (trailingPunct ? trailingPunct[0] : '');
      },
      
      isVowel(char) {
        return this.vowels.has(char?.toLowerCase());
      },
      
      isConsonant(char) {
        return this.consonants.has(char?.toLowerCase());
      },
      
      isPalatalized(char, nextChar) {
        char = char?.toLowerCase();
        nextChar = nextChar?.toLowerCase();
        
        if (this.alwaysSoft.has(char)) return true;
        if (this.alwaysHard.has(char)) return false;
        if (nextChar === 'ь') return true;
        if (['е', 'ё', 'и', 'ю', 'я'].includes(nextChar)) return true;
        
        return false;
      },
      
      // Full regressive palatalization analysis for a word (Grayson p. 207-209; D&P pp. 76-87)
      // Returns a Map of character indices that should be palatalized
      analyzeRegressivePalatalization(word) {
        const chars = [...word.toLowerCase()];
        const softIndices = new Map(); // index -> true if should be palatalized
        
        // Step 1: Mark directly palatalized consonants (before indicator letters or ь)
        for (let i = 0; i < chars.length; i++) {
          if (this.isConsonant(chars[i])) {
            if (this.isPalatalized(chars[i], chars[i + 1])) {
              softIndices.set(i, true);
            }
          }
        }
        
        // Step 2: Process regressive palatalization right-to-left through clusters
        // Working backwards, check if palatalization can step through
        for (let i = chars.length - 2; i >= 0; i--) {
          const char = chars[i];
          const nextChar = chars[i + 1];
          
          if (!this.isConsonant(char)) continue;
          if (softIndices.has(i)) continue; // Already soft
          
          // Check if next consonant is soft
          const nextIsSoft = softIndices.has(i + 1);
          if (!nextIsSoft) continue;
          
          // Check for blockers (Grayson p. 209; D&P pp. 85-87)
          // р and л block regressive palatalization (confirmed by D&P)
          if (this.regressivePalatalizationBlockers.has(nextChar)) {
            continue; // Blocked - don't palatalize through р or л
          }
          
          // Check categorical restrictions (Grayson p. 209)
          if (!this.canRegressivelyPalatalize(char, nextChar)) {
            continue; // Categorical mismatch
          }
          
          // Check for boundaries
          if (this.alwaysHard.has(char)) continue; // ж, ш, ц never palatalize
          if (chars[i + 1] === 'ъ') continue; // Hard sign blocks (except в, с, з - handled separately)
          
          // This consonant can be regressively palatalized
          softIndices.set(i, true);
        }
        
        return softIndices;
      },
      
      // Check if consonant can regressively palatalize before another consonant (Grayson p. 209)
      canRegressivelyPalatalize(consonant, triggerConsonant) {
        consonant = consonant?.toLowerCase();
        triggerConsonant = triggerConsonant?.toLowerCase();
        
        // Always-hard consonants never palatalize
        if (this.alwaysHard.has(consonant)) return false;
        
        // л: only regressively palatalizes when doubled (лль)
        // (Grayson p. 209 rule 1)
        if (consonant === 'л') {
          return triggerConsonant === 'л'; // Only before another л
        }
        
        // р: never regressively palatalizes except when doubled (ррь)
        // (Grayson p. 209 rule 2; D&P pp. 85-87)
        // NOTE: Progressive palatalization (after front vowel in cluster) is handled separately
        if (consonant === 'р') {
          return triggerConsonant === 'р'; // Only before another р
        }
        
        // н: only before palatalized н or dental (Grayson p. 209 rule 3)
        if (consonant === 'н') {
          return triggerConsonant === 'н' || this.dentals.has(triggerConsonant);
        }
        
        // Velars (к, г, х): only before palatalized velar (Grayson p. 209 rule 4)
        if (this.velars.has(consonant)) {
          return this.velars.has(triggerConsonant);
        }
        
        // Labials (б, п, в, ф, м): only before palatalized labial (Grayson p. 209 rule 5)
        if (this.labials.has(consonant)) {
          return this.labials.has(triggerConsonant);
        }
        
        // Dentals (т, д, с, з): only before palatalized dental (Grayson p. 209)
        // Dentals do NOT palatalize before labials (e.g., д before в in дверь stays hard)
        if (this.dentals.has(consonant)) {
          return this.dentals.has(triggerConsonant);
        }
        
        // Others: can palatalize more freely
        return true;
      },
      
      // Check if a consonant at given index is palatalized (considering regressive)
      isConsonantPalatalized(word, index, softIndices) {
        if (softIndices && softIndices.has(index)) {
          return true;
        }
        const chars = [...word.toLowerCase()];
        return this.isPalatalized(chars[index], chars[index + 1]);
      },
      
      // Protected suffixes that must stay together as syllable units (Grayson p. 237-238)
      // Format: { cyrillic: 'suffix', placeholder: '◊' }
      // The placeholder replaces consonants, keeping the vowel visible for syllable counting
      protectedSuffixes: [
        { suffix: 'ться', consonants: 'ться', placeholder: '◊', vowelKept: 'я' }, // купаться
        { suffix: 'тся', consonants: 'тс', placeholder: '◊', vowelKept: 'я' },   // боится
      ],
      
      // Main syllabification entry point
      // Wraps the open-syllable logic with morphological exception handling
      syllabify(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // STEP 1: Check for protected suffixes and replace with placeholders
        let processedWord = cleanWord;
        let activeProtection = null;
        
        for (const protection of this.protectedSuffixes) {
          if (cleanWord.endsWith(protection.suffix)) {
            // Replace the consonant portion with placeholder, keep vowel
            // e.g., "боится" → "бои◊я" (тс replaced with ◊, я kept)
            const suffixStart = cleanWord.length - protection.suffix.length;
            const beforeSuffix = cleanWord.slice(0, suffixStart);
            processedWord = beforeSuffix + protection.placeholder + protection.vowelKept;
            activeProtection = { ...protection, startIndex: suffixStart };
            break; // Only one suffix per word
          }
        }
        
        // STEP 2: Apply open-syllable rules to processed word
        const rawSyllables = this.syllabifyOpenSyllable(processedWord);
        
        // STEP 3: Restore protected suffix in final syllable
        if (activeProtection) {
          const lastIdx = rawSyllables.length - 1;
          // Replace placeholder+vowel back to original suffix
          rawSyllables[lastIdx] = rawSyllables[lastIdx].replace(
            activeProtection.placeholder + activeProtection.vowelKept,
            activeProtection.suffix
          );
        }
        
        return rawSyllables;
      },
      
      // Core open-syllable logic (Maximum Onset Principle)
      // This is the original syllabify, now renamed and called by the wrapper
      syllabifyOpenSyllable(word) {
        const chars = [...word];
        const syllables = [];
        let current = '';
        
        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];
          current += char;
          
          if (this.isVowel(char)) {
            let j = i + 1;
            // Advance through consonants AND soft/hard signs (they attach to consonants)
            while (j < chars.length && !this.isVowel(chars[j])) {
              j++;
            }
            
            // If we've reached the end of the word, attach all remaining chars to this syllable
            if (j >= chars.length) {
              current += chars.slice(i + 1).join('');
              syllables.push(current);
              break;
            }
            
            // We have consonants between this vowel and the next
            const cluster = chars.slice(i + 1, j);
            if (cluster.length === 0) {
              // No consonants between vowels (e.g., two vowels in a row)
              syllables.push(current);
              current = '';
            } else if (cluster.length === 1) {
              // Single consonant goes with next syllable (CV.CV pattern)
              syllables.push(current);
              current = '';
            } else {
              // Multiple consonants: keep last one for next syllable, rest stay with current
              // But soft/hard signs always stay with preceding consonant
              let splitPoint = cluster.length - 1;
              // If the last char is a soft/hard sign, move split point back
              while (splitPoint > 0 && (cluster[splitPoint] === 'ь' || cluster[splitPoint] === 'ъ')) {
                splitPoint--;
              }
              // Keep at least one consonant for the next syllable (unless it's all signs)
              if (splitPoint === cluster.length - 1) {
                splitPoint = Math.max(1, cluster.length - 1);
              }
              current += cluster.slice(0, splitPoint).join('');
              syllables.push(current);
              current = '';
              i = i + splitPoint;
            }
          }
        }
        
        if (current && !syllables.includes(current)) {
          syllables.push(current);
        }
        
        return syllables.length > 0 ? syllables : [word];
      },
      
      countVowels(word) {
        return [...word.toLowerCase()].filter(c => this.isVowel(c)).length;
      },
      
      // Detect if word contains ё and return its syllable index
      // ё always carries stress in Russian — this is non-negotiable
      findYoSyllable(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const syllables = this.syllabify(cleanWord);
        for (let i = 0; i < syllables.length; i++) {
          if (syllables[i].includes('ё')) {
            return i;
          }
        }
        return -1; // No ё found
      },
      
      // Check if word contains ё (for UI decisions)
      hasYo(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        return cleanWord.includes('ё');
      },
      
      getSyllablePosition(index, stressIndex, total) {
        if (index === stressIndex) return 'stressed';
        if (stressIndex === -1) return 'unstressed';
        if (index === stressIndex - 1) return 'pretonic';
        // Grayson p. 266, fn. 306: immediate post-tonic а stays /ɑ/ to distinguish from о
        if (index === stressIndex + 1) return 'posttonic-immediate';
        return 'remote';
      },
      
      // Transcribe vowel based on position and palatal context
      // Grayson Ch. 3: Fronting to [a] or [e] requires INTERPALATAL position
      // (sandwiched between two palatalized consonants or followed by й)
      transcribeVowel(vowel, position, isPrecededByPalatalized, isFollowedByPalatalized, precedingConsonant) {
        vowel = vowel.toLowerCase();
        
        // Interpalatal = preceded by soft C AND followed by soft C (Grayson p. 207)
        // Note: For word-initial position, the /j/ glide counts as "preceded by soft"
        const isInterpalatal = isPrecededByPalatalized && isFollowedByPalatalized;
        
        // Always-hard consonants ж, ш, ц (Grayson p. 102-103)
        const isAfterAlwaysHard = ['ж', 'ш', 'ц'].includes(precedingConsonant);
        
        if (position === 'stressed') {
          // а → [a] only when interpalatal (Grayson p. 104)
          if (vowel === 'а') return isInterpalatal ? 'a' : 'ɑ';
          if (vowel === 'о') return 'o';
          
          // RULE B: -е- requires INTERPALATAL for [e] (Grayson p. 207)
          // "е and its cluster /jɛ/ shift to [e]/[je] when interpalatal 
          // (between two palatalized consonants or palatalizing agents)"
          if (vowel === 'е') return isInterpalatal ? 'e' : 'ɛ';
          
          if (vowel === 'ё') return 'o';
          // и after ж/ш/ц → ɨ (Grayson p. 93-95)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у') return 'u';
          if (vowel === 'ю') return 'u';
          // я → [a] only when interpalatal (Grayson p. 104)
          if (vowel === 'я') return isInterpalatal ? 'a' : 'ɑ';
          
          // RULE A: -э- only checks FOLLOWING consonant for [e] (Grayson p. 207)
          // "-э- shifts from /ɛ/ to [e] when followed by a palatalized consonant"
          // (Note: -э- cannot follow soft consonants orthographically)
          if (vowel === 'э') return isFollowedByPalatalized ? 'e' : 'ɛ';
        } else if (position === 'pretonic') {
          if (vowel === 'а' || vowel === 'о') return 'ɑ';
          // е after ж/ш/ц → ɨ (Grayson p. 102-103)
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'я' || vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          // и after ж/ш/ц → ɨ (Grayson p. 102)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        } else if (position === 'posttonic-immediate') {
          // Grayson p. 266, footnote 306: "This guide suggests that -а- in 
          // the immediate-post-stress position be read as /ɑ/ in order to 
          // aurally differentiate from words that have the letter -о- in 
          // the same position."
          // Example: блюдa /ˈblʲu dɑ/ (platters) vs блюдо /ˈblʲu dʌ/ (a platter)
          if (vowel === 'а') return 'ɑ';
          if (vowel === 'я') return 'ɑ';  // я follows а pattern (underlying /ja/)
          if (vowel === 'о') return 'ʌ';
          // Other vowels follow remote patterns
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        } else {
          // Remote unstressed positions (Grayson p. 109-112)
          if (vowel === 'а') return 'ʌ';
          if (vowel === 'о') return 'ʌ';
          // е after ж/ш/ц → ɨ (Grayson p. 102-103)
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'я' || vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          // и after ж/ш/ц → ɨ (Grayson p. 102)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        }
        
        return vowel;
      },
      
      transcribeConsonant(consonant, nextChar, prevChar, isStressedSyllable, isSoftFromRegressive = false, nextCharInWord = null) {
        consonant = consonant.toLowerCase();
        prevChar = prevChar?.toLowerCase();
        // Combine direct palatalization with regressive palatalization analysis
        const softDirect = this.isPalatalized(consonant, nextChar);
        const soft = softDirect || isSoftFromRegressive;
        const base = this.inventory.consonants[consonant] || consonant;
        
        // Progressive palatalization of р (Grayson p. 209, footnote 277)
        // "Do not regressively palatalize /r/ within a cluster except... 
        // directly following -и-, -е-, or -э- (in the stressed syllable only)"
        // Examples: смерть /sʲmʲerʲtʲ/, терпеть /tʲirʲˈpʲetʲ/, кирпич /kʲirʲˈpʲitʃʲ/
        // NOTE: This applies only when р is IN A CLUSTER (followed by consonant)
        // Word-final р after front vowel does NOT palatalize: мир /mʲir/ not /mʲirʲ/
        // v5.11.21: Use nextCharInWord to check across syllable boundaries
        if (consonant === 'р' && isStressedSyllable) {
          const frontVowels = ['и', 'е', 'э'];
          // Check both syllable-local nextChar AND word-level nextCharInWord
          const effectiveNextChar = nextChar || nextCharInWord;
          const nextIsConsonant = effectiveNextChar && this.consonants.has(effectiveNextChar.toLowerCase());
          if (frontVowels.includes(prevChar) && nextIsConsonant) {
            return 'rʲ'; // Progressive palatalization in cluster only
          }
        }
        
        if (consonant === 'л') {
          return soft ? 'lʲ' : 'ɫ';
        }
        if (consonant === 'н' && soft) {
          return 'ɲ';
        }
        
        if (soft && !this.alwaysSoft.has(consonant)) {
          return base + 'ʲ';
        }
        
        return base;
      },
      
      // Final consonant devoicing (Grayson Ch. 4 Sec. 4, pp. 199-202)
      // "In Russian, as in German, final consonants are generally unvoiced, 
      // regardless of spelling. This does not apply to sonorants."
      voicedToVoiceless: Object.freeze({
        'b': 'p',    // б → п (p. 199-200)
        'bʲ': 'pʲ',  // бь → пь
        'v': 'f',    // в → ф (p. 200)
        'vʲ': 'fʲ',  // вь → фь
        'd': 't',    // д → т (p. 201)
        'dʲ': 'tʲ',  // дь → ть
        'ɡ': 'k',    // г → к (p. 201) — note: гь does not occur
        'z': 's',    // з → с (p. 202)
        'zʲ': 'sʲ',  // зь → сь
        'ʒ': 'ʃ'     // ж → ш (p. 202) — ж never palatalizes, so жь also → ш
      }),
      
      // Reverse mapping for voicing (voiceless → voiced)
      voicelessToVoiced: Object.freeze({
        'p': 'b',    // п → б
        'pʲ': 'bʲ',  // пь → бь
        'f': 'v',    // ф → в
        'fʲ': 'vʲ',  // фь → вь
        't': 'd',    // т → д
        'tʲ': 'dʲ',  // ть → дь
        'k': 'ɡ',    // к → г
        's': 'z',    // с → з
        'sʲ': 'zʲ',  // сь → зь
        'ʃ': 'ʒ'     // ш → ж
      }),
      
      // Sets for classification (Grayson Ch. 6 Sec. 1, pp. 213-214)
      // Sonorants: "do not influence the voicing of preceding, unvoiced consonants 
      // and are never devoiced themselves in lyric diction"
      sonorantIPA: new Set(['ɫ', 'lʲ', 'm', 'mʲ', 'n', 'nʲ', 'ɲ', 'r', 'rʲ', 'j']),
      
      // Voiced obstruents (can trigger voicing of preceding consonants)
      voicedObstruents: new Set(['b', 'bʲ', 'd', 'dʲ', 'ɡ', 'z', 'zʲ', 'ʒ']),
      
      // Voiceless obstruents (can trigger devoicing of preceding consonants)
      voicelessObstruents: new Set(['p', 'pʲ', 't', 'tʲ', 'k', 's', 'sʲ', 'ʃ', 'x', 'ts', 'tʃ', 'ʃtʃ']),
      
      // /v/ phonemes: "has no assimilative voicing influence of its own, 
      // but is influenced by most other consonants" (Grayson p. 214)
      vPhonemes: new Set(['v', 'vʲ', 'f', 'fʲ']),
      
      // Regressive voicing assimilation within words (Grayson Ch. 6 Sec. 1, pp. 214-224)
      // "The baseline approach to consonant clusters in Russian is to pronounce each 
      // consonant member in the cluster and to determine the voicing of all the 
      // consonants based upon the status of the last member of the cluster."
      applyRegressiveVoicing(ipa) {
        // Parse IPA into segments (consonants may be multi-char like tʃ, ʃtʃ, or have ʲ)
        const segments = this.parseIPASegments(ipa);
        if (segments.length < 2) return ipa;
        
        // Process clusters: find sequences of consonants
        // Note: stress marks (ˈ) can appear mid-cluster and must be preserved
        let result = [];
        let i = 0;
        
        while (i < segments.length) {
          const seg = segments[i];
          
          // If it's a vowel, just add it
          if (this.isIPAVowel(seg)) {
            result.push(seg);
            i++;
            continue;
          }
          
          // If it's a stress mark at start (before any consonant), just add it
          if (seg === 'ˈ') {
            result.push(seg);
            i++;
            continue;
          }
          
          // Found a consonant - collect the cluster (including any stress marks)
          let cluster = [seg];
          let stressPositions = []; // Track where stress marks appear in cluster
          let j = i + 1;
          while (j < segments.length && !this.isIPAVowel(segments[j])) {
            if (segments[j] === 'ˈ') {
              // Record position and skip for now (will reinsert after assimilation)
              stressPositions.push(cluster.length);
            } else {
              cluster.push(segments[j]);
            }
            j++;
          }
          
          // Apply voicing assimilation to this cluster (consonants only)
          if (cluster.length > 1) {
            cluster = this.assimilateClusterVoicing(cluster);
          }
          
          // Reinsert stress marks at their original positions
          for (let k = stressPositions.length - 1; k >= 0; k--) {
            cluster.splice(stressPositions[k], 0, 'ˈ');
          }
          
          result.push(...cluster);
          i = j;
        }
        
        return result.join('');
      },
      
      // Parse IPA string into segments (handling multi-char consonants)
      parseIPASegments(ipa) {
        const segments = [];
        let i = 0;
        
        while (i < ipa.length) {
          // Check for multi-char consonants first (longest match)
          if (ipa.slice(i, i + 3) === 'ʃtʃ') {
            segments.push('ʃtʃ');
            i += 3;
          } else if (ipa.slice(i, i + 2) === 'tʃ') {
            segments.push('tʃ');
            i += 2;
          } else if (ipa.slice(i, i + 2) === 'ts') {
            segments.push('ts');
            i += 2;
          } else if (ipa[i + 1] === 'ʲ' && ipa[i + 2] === 'ː') {
            // Consonant + palatalization + length (e.g., ʃʲː)
            segments.push(ipa.slice(i, i + 3));
            i += 3;
          } else if (ipa[i + 1] === 'ʲ') {
            // Consonant + palatalization marker
            segments.push(ipa.slice(i, i + 2));
            i += 2;
          } else if (ipa[i + 1] === 'ː') {
            // Consonant + length marker (e.g., ʃː, ʒː)
            segments.push(ipa.slice(i, i + 2));
            i += 2;
          } else {
            segments.push(ipa[i]);
            i++;
          }
        }
        
        return segments;
      },
      
      // Check if IPA segment is a vowel
      isIPAVowel(seg) {
        const ipaVowels = new Set(['ɑ', 'a', 'o', 'ɛ', 'e', 'i', 'ɪ', 'ɨ', 'u', 'ʊ', 'ʌ']);
        return ipaVowels.has(seg);
      },
      
      // Assimilate voicing within a consonant cluster (Grayson p. 214-215)
      // "the voicing of the entire cluster is that of the final member"
      assimilateClusterVoicing(cluster) {
        // Find the last non-sonorant, non-/v/ consonant - this is the "agent"
        let agentIndex = -1;
        for (let i = cluster.length - 1; i >= 0; i--) {
          const seg = cluster[i];
          if (this.sonorantIPA.has(seg)) continue;
          if (this.vPhonemes.has(seg)) continue;
          agentIndex = i;
          break;
        }
        
        // No agent found (all sonorants or /v/) - no assimilation
        if (agentIndex === -1) return cluster;
        
        const agent = cluster[agentIndex];
        const agentIsVoiced = this.voicedObstruents.has(agent);
        
        // Apply voicing/devoicing to all preceding consonants (and /v/ phonemes)
        const result = [...cluster];
        for (let i = 0; i < agentIndex; i++) {
          const seg = result[i];
          
          // Sonorants never change
          if (this.sonorantIPA.has(seg)) continue;
          
          if (agentIsVoiced) {
            // Voice the consonant if it's voiceless
            if (this.voicelessToVoiced[seg]) {
              result[i] = this.voicelessToVoiced[seg];
            }
          } else {
            // Devoice the consonant if it's voiced
            if (this.voicedToVoiceless[seg]) {
              result[i] = this.voicedToVoiceless[seg];
            }
          }
        }
        
        return result;
      },
      
      // Apply final devoicing to IPA string
      applyFinalDevoicing(ipa) {
        // Find the final consonant segment (may include palatalization marker)
        // Sonorants (ɫ, lʲ, m, mʲ, n, ɲ, r, rʲ, j) are never devoiced
        const sonorantPattern = /[ɫmnrj]ʲ?$/;
        if (sonorantPattern.test(ipa)) {
          return ipa; // Sonorants don't devoice
        }
        
        // Remove any trailing spaces for matching
        const trimmedIpa = ipa.trimEnd();
        
        // Check for voiced consonants at end and replace
        for (const [voiced, voiceless] of Object.entries(this.voicedToVoiceless)) {
          if (trimmedIpa.endsWith(voiced)) {
            return trimmedIpa.slice(0, -voiced.length) + voiceless;
          }
        }
        
        return ipa;
      },
      
      transcribe(word, stressIndex = -1, isClitic = false, procliticPosition = null) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // Check for isolated clitic — use canonical form from registry
        // (Phrase-context clitics have procliticPosition set by the caller)
        const cliticInfo = this.cliticData.get(cleanWord);
        if (cliticInfo && isClitic && !procliticPosition) {
          // Return canonical citation form for isolated clitic
          return {
            ipa: cliticInfo.canonicalIpa,
            ipaUnderlying: cliticInfo.canonicalIpa,
            syllables: [{
              cyrillic: cleanWord,
              ipa: cliticInfo.canonicalIpa,
              isStressed: false
            }],
            transcriptionLog: [{
              cyrillic: cleanWord,
              ipa: cliticInfo.canonicalIpa,
              source: 'isolated-clitic',
              note: 'Canonical citation form — contextual pronunciation varies'
            }],
            source: 'isolated-clitic'
          };
        }
        
        const syllables = this.syllabify(cleanWord);
        const vowelCount = this.countVowels(cleanWord);
        
        // Find special clusters (e.g., сч → /ʃʲʃʲ/)
        const specialClusters = this.findSpecialClusters(cleanWord);
        
        // ё always carries stress — override any other stress assignment
        const yoSyllable = this.findYoSyllable(cleanWord);
        let effectiveStress;
        if (yoSyllable !== -1) {
          // ё found: stress is locked to that syllable
          effectiveStress = yoSyllable;
        } else if (vowelCount === 1 && !isClitic) {
          // Monosyllable (non-clitic): stress on only syllable
          effectiveStress = 0;
        } else {
          // Normal case: use provided stress index
          effectiveStress = stressIndex;
        }
        
        // Analyze regressive palatalization for the whole word (Grayson p. 207-209)
        const softIndices = this.analyzeRegressivePalatalization(cleanWord);
        
        // Build a map of character position in full word to track palatalization
        let charIndexInWord = 0;
        
        let ipa = '';
        let syllableData = [];
        let transcriptionLog = [];  // Phase 1: Phoneme Ribbon data
        
        syllables.forEach((syl, sylIdx) => {
          // For proclitics with host-stress-aware reduction, use procliticPosition
          // This overrides the default 'unstressed' position for accurate vowel reduction
          let position;
          if (isClitic && procliticPosition) {
            position = procliticPosition;  // 'pretonic' or 'remote' based on host word stress
          } else {
            position = this.getSyllablePosition(sylIdx, effectiveStress, syllables.length);
          }
          let sylIpa = '';
          const chars = [...syl];
          
          if (position === 'stressed' && vowelCount > 1) {
            sylIpa += 'ˈ';
          }
          
          for (let i = 0; i < chars.length; i++) {
            const char = chars[i];
            const nextChar = chars[i + 1];
            const globalIndex = charIndexInWord + i; // Position in full word
            
            // Log soft/hard signs before skipping
            if (char === 'ь' || char === 'ъ') {
              transcriptionLog.push({
                char: char,
                ipa: '',  // Signs produce no sound of their own (v5.11.1)
                features: {
                  type: 'sign',
                  signType: char === 'ь' ? 'soft' : 'hard',
                  silent: true  // Mark as silent for ribbon display
                },
                syllableIndex: sylIdx,
                position: globalIndex
              });
              continue;
            }
            
            // Check if this character is part of a special cluster
            const clusterInfo = specialClusters.find(c => 
              globalIndex >= c.startIndex && globalIndex <= c.endIndex
            );
            
            if (clusterInfo) {
              // First char of cluster outputs the IPA and logs the cluster
              if (globalIndex === clusterInfo.startIndex) {
                sylIpa += clusterInfo.ipa;
                
                transcriptionLog.push({
                  char: clusterInfo.cluster,
                  ipa: clusterInfo.ipa,
                  features: {
                    type: 'cluster',
                    clusterChars: clusterInfo.cluster.length
                  },
                  syllableIndex: sylIdx,
                  position: globalIndex
                });
              }
              continue;
            }
            
            if (this.isVowel(char)) {
              const prevCharInSyllable = chars[i - 1];
              // Use word-level previous char for j-glide and interpalatal detection
              const prevCharInWord = cleanWord[globalIndex - 1];
              const needsGlide = ['е', 'ё', 'ю', 'я'].includes(char) && 
                                 (globalIndex === 0 || this.isVowel(prevCharInWord) || prevCharInWord === 'ь' || prevCharInWord === 'ъ');
              
              if (needsGlide) sylIpa += 'j';
              
              // Initialize vowel tracking
              let vowelIpa = null;
              let vowelFeatures = {
                type: 'vowel',
                position: position,
                interpalatal: false,
                afterHard: false,
                exception: null
              };
              
              // Check for exception word vowel override
              const vowelOverride = this.getVowelOverride(cleanWord, globalIndex);
              if (vowelOverride !== null) {
                vowelIpa = vowelOverride;
                vowelFeatures.exception = 'word-override';
              }
              
              // Check for -ая/-яя suffix exception (Grayson p. 124)
              // These endings are ALWAYS /ɑjɑ/, never reduced
              if (vowelIpa === null && this.isAyaSuffixVowel(cleanWord, globalIndex)) {
                vowelIpa = 'ɑ';
                vowelFeatures.exception = 'aya-suffix';
              }
              
              // Check for Old Muscovite velar adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
              // When profile adjectival='stage': и → [ɨ] after hard velar
              const profileParams = ProfileController.getParams();
              const velarAdj = this.checkVelarAdjectival(cleanWord, globalIndex);
              if (vowelIpa === null && velarAdj.isVelarAdjectival && velarAdj.charRole === 'i' && profileParams.adjectival === 'stage') {
                vowelIpa = 'ɨ';
                vowelFeatures.exception = 'velar-adjectival';
              }
              
              // Normal vowel transcription (if no exception applied)
              if (vowelIpa === null) {
                // Check preceding consonant palatalization (using regressive analysis)
                // Use word-level previous char, not within-syllable
                const prevConsonant = this.isConsonant(prevCharInWord) ? prevCharInWord : null;
                const prevGlobalIndex = globalIndex - 1;
                
                // Check if preceded by a special cluster (for interpalatal)
                const prevCluster = specialClusters.find(c => c.endIndex === prevGlobalIndex);
                
                // Iotated vowels at word-initial or after vowel/ъ/ь produce /j/ glide
                // The /j/ glide counts as a palatalizing agent (Grayson p. 125)
                const iotatedVowels = ['е', 'ё', 'ю', 'я'];
                const isIotated = iotatedVowels.includes(char);
                const isWordInitialOrAfterVowel = globalIndex === 0 || 
                  this.isVowel(prevCharInWord) || prevCharInWord === 'ъ' || prevCharInWord === 'ь';
                const precededByJGlide = isIotated && isWordInitialOrAfterVowel;
                
                const isPrecededByPal = prevCluster ?
                  prevCluster.ipa.includes('ʲ') :
                  (prevConsonant ? 
                    (softIndices.has(prevGlobalIndex) || this.isPalatalized(prevConsonant, char)) : 
                    precededByJGlide);  // Word-initial iotated → preceded by /j/
                
                // Check following consonant palatalization (Grayson p. 104, 106: interpalatal requires BOTH)
                // Find the next consonant after this vowel - must search in FULL WORD, not just current syllable
                let followingConsonant = null;
                let followingConsonantGlobalIndex = -1;
                let charAfterFollowingC = null;
                const wordChars = [...cleanWord];
                for (let j = globalIndex + 1; j < wordChars.length; j++) {
                  if (wordChars[j] === 'ь' || wordChars[j] === 'ъ') continue;
                  if (this.isConsonant(wordChars[j])) {
                    followingConsonant = wordChars[j];
                    followingConsonantGlobalIndex = j;
                    charAfterFollowingC = wordChars[j + 1];
                    break;
                  }
                  if (this.isVowel(wordChars[j])) break; // Hit another vowel first
                }
                
                // Check if the following consonant is part of a special cluster
                // If so, check the cluster's IPA for palatalization, not the Cyrillic letter
                const followingCluster = followingConsonant ? 
                  specialClusters.find(c => 
                    followingConsonantGlobalIndex >= c.startIndex && 
                    followingConsonantGlobalIndex <= c.endIndex
                  ) : null;
                
                let isFollowedByPal = false;
                if (followingConsonant === 'й') {
                  // й always counts as palatalized
                  isFollowedByPal = true;
                } else if (followingCluster) {
                  // Check the cluster's IPA output for palatalization
                  // e.g., чн→/ʃn/ starts with /ʃ/ which is hard (no ʲ at start)
                  // But сч→/ʃʲʃʲ/ starts with /ʃʲ/ which is soft
                  const clusterIPA = followingCluster.ipa;
                  // The first sound in the cluster is what follows the vowel
                  isFollowedByPal = clusterIPA.length > 1 && clusterIPA[1] === 'ʲ';
                } else if (followingConsonant) {
                  // Normal case: check the Cyrillic consonant
                  isFollowedByPal = softIndices.has(followingConsonantGlobalIndex) || 
                    this.isPalatalized(followingConsonant, charAfterFollowingC);
                } else {
                  // No following consonant found - check if next vowel is iotated
                  // Iotated vowels (е, ё, ю, я) produce /j/ glide which is a palatalizing agent
                  // This handles cases like её where /j/-[vowel]-/j/ is interpalatal
                  const iotatedVowels = ['е', 'ё', 'ю', 'я'];
                  for (let j = globalIndex + 1; j < wordChars.length; j++) {
                    if (wordChars[j] === 'ь' || wordChars[j] === 'ъ') continue;
                    if (this.isVowel(wordChars[j])) {
                      isFollowedByPal = iotatedVowels.includes(wordChars[j]);
                      break;
                    }
                    if (this.isConsonant(wordChars[j])) break;
                  }
                }
                
                // Capture interpalatal and afterHard features
                const prevConsonantForFeatures = this.isConsonant(prevCharInWord) ? prevCharInWord : null;
                vowelFeatures.interpalatal = isPrecededByPal && isFollowedByPal;
                vowelFeatures.afterHard = ['ж', 'ш', 'ц'].includes(prevConsonantForFeatures);
                
                vowelIpa = this.transcribeVowel(char, position, isPrecededByPal, isFollowedByPal, prevConsonantForFeatures);
              }
              
              sylIpa += vowelIpa;
              
              // Populate transcriptionLog for vowel
              transcriptionLog.push({
                char: char,
                ipa: vowelIpa,
                features: vowelFeatures,
                syllableIndex: sylIdx,
                position: globalIndex
              });
            } else if (this.isConsonant(char)) {
              const prevChar = chars[i - 1];
              const nextCharInWord = cleanWord[globalIndex + 1]; // For cross-syllable checks
              const isStressedSyl = (position === 'stressed');
              // Pass regressive palatalization info
              let isSoftFromRegressive = softIndices.has(globalIndex);
              
              // Check for Old Muscovite velar adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
              // When profile adjectival='stage': velar stays HARD (not palatalized)
              const profileParams = ProfileController.getParams();
              const velarAdj = this.checkVelarAdjectival(cleanWord, globalIndex);
              
              // Check for genitive ending -ого/-его: г → /v/ (Grayson p. 243)
              const isGenitiveG = (char === 'г') && this.checkGenitiveEnding(cleanWord, globalIndex);
              
              let consonantIpa;
              if (isGenitiveG) {
                // Genitive г → /v/
                consonantIpa = 'v';
              } else if (velarAdj.isVelarAdjectival && velarAdj.charRole === 'velar' && profileParams.adjectival === 'stage') {
                // Force hard velar: output base consonant without palatalization
                consonantIpa = this.inventory.consonants[char] || char;
              } else {
                consonantIpa = this.transcribeConsonant(char, nextChar, prevChar, isStressedSyl, isSoftFromRegressive, nextCharInWord);
              }
              sylIpa += consonantIpa;
              
              // Populate transcriptionLog for consonant
              const isSoft = consonantIpa.includes('ʲ') || consonantIpa === 'ɲ';
              let softTrigger = null;
              if (isSoft) {
                // Priority: direct triggers first, then regressive
                // A consonant before a front vowel is soft because of the vowel, not regressive assimilation
                if (nextChar === 'ь') {
                  softTrigger = 'ь';
                } else if (['е', 'ё', 'ю', 'я', 'и'].includes(nextChar)) {
                  softTrigger = nextChar;
                } else if (isSoftFromRegressive) {
                  softTrigger = 'regressive';
                }
              }
              
              transcriptionLog.push({
                char: char,
                ipa: consonantIpa,
                features: {
                  type: 'consonant',
                  soft: isSoft,
                  softTrigger: softTrigger,
                  genitiveEnding: isGenitiveG
                },
                syllableIndex: sylIdx,
                position: globalIndex
              });
            }
          }
          
          charIndexInWord += syl.length;
          
          syllableData.push({
            cyrillic: syl,
            ipa: sylIpa.replace(/^ˈ/, ''),
            isStressed: position === 'stressed'
          });
          
          ipa += sylIpa;
        });
        
        // Step 2 (Grayson p. 247): Apply regressive voicing assimilation
        ipa = this.applyRegressiveVoicing(ipa);
        
        // Sync syllable IPAs with word-level assimilation (v5.10.20)
        // Cross-syllable clusters (e.g., кз in вок-зал) are only caught at word level
        // Re-split the assimilated word IPA back into syllables
        const assimilatedSegments = this.parseIPASegments(ipa.replace(/ˈ/g, ''));
        let segmentIdx = 0;
        syllableData.forEach(syl => {
          // Count how many segments this syllable originally had
          const originalSegments = this.parseIPASegments(syl.ipa);
          const segmentCount = originalSegments.length;
          
          // Extract that many segments from the assimilated word
          const newSegments = assimilatedSegments.slice(segmentIdx, segmentIdx + segmentCount);
          syl.ipa = newSegments.join('');
          segmentIdx += segmentCount;
        });
        
        // Sync transcriptionLog to match surface IPA after voicing assimilation (v5.10.20)
        // The log was built before assimilation, so consonant entries may have stale IPA
        transcriptionLog.forEach(entry => {
          if (entry.features?.type === 'consonant') {
            const originalIpa = entry.ipa;
            // Check if this consonant was devoiced
            if (this.voicedToVoiceless[originalIpa]) {
              // Look at what's in the syllable data to see if it changed
              const sylData = syllableData[entry.syllableIndex];
              if (sylData && !sylData.ipa.includes(originalIpa)) {
                // The original voiced consonant is not in the syllable anymore
                // Check if the devoiced version is there
                const devoiced = this.voicedToVoiceless[originalIpa];
                if (sylData.ipa.includes(devoiced)) {
                  entry.ipa = devoiced;
                  entry.features.voicingAssimilation = true;
                  entry.features.devoiced = true;
                }
              }
            }
            // Check if this consonant was voiced
            if (this.voicelessToVoiced[originalIpa]) {
              const sylData = syllableData[entry.syllableIndex];
              if (sylData && !sylData.ipa.includes(originalIpa)) {
                const voiced = this.voicelessToVoiced[originalIpa];
                if (sylData.ipa.includes(voiced)) {
                  entry.ipa = voiced;
                  entry.features.voicingAssimilation = true;
                  entry.features.voiced = true;
                }
              }
            }
          }
        });
        
        // Step 3-4 will be special clusters and palatalization (future phases)
        
        // Final consonant devoicing (Grayson Ch. 4 Sec. 4, pp. 199-202)
        // For clitics, devoicing is deferred to cross-word stage (boundary-dependent)
        // For standalone words, apply devoicing now
        let ipaSurface = ipa;
        if (!isClitic) {
          // Exception: бог → /box/ (Grayson p. 242) — г becomes /x/ not /k/
          // This is a Church Slavonic preservation
          if (cleanWord === 'бог' && ipa.endsWith('ɡ')) {
            ipaSurface = ipa.slice(0, -1) + 'x';
            // Update syllable data to show /x/ not /ɡ/
            const lastSyl = syllableData[syllableData.length - 1];
            if (lastSyl && lastSyl.ipa.endsWith('ɡ')) {
              lastSyl.ipa = lastSyl.ipa.slice(0, -1) + 'x';
            }
            // Update transcriptionLog for the final г
            const lastConsonantEntry = transcriptionLog.findLast(e => e.char === 'г');
            if (lastConsonantEntry) {
              lastConsonantEntry.ipa = 'x';
              lastConsonantEntry.features.bogException = true;
              lastConsonantEntry.features.finalDevoicing = false; // Not standard devoicing
            }
          } else {
            ipaSurface = this.applyFinalDevoicing(ipa);
          }
        }
        
        return { ipa: ipaSurface, ipaUnderlying: ipa, syllables: syllableData, transcriptionLog };
      },
      
      /**
       * Auto-detect boundary types for a line of words.
       * Called after initial transcription, before cross-word assimilation.
       * 
       * Rules (in priority order):
       * 1. User-set boundaries are never overwritten
       * 2. Final word → always 'hard'
       * 3. Punctuation after word → 'hard'
       * 4. Current word is proclitic → 'clitic'
       * 5. Next word is enclitic → 'clitic'
       * 6. Otherwise → 'hard' (conservative default)
       */
      autoDetectBoundaries(words) {
        const punctuationRegex = /[.,!?;:"""''–—]$/;
        
        words.forEach((word, i) => {
          // Rule 1: Preserve user-set boundaries
          if (word.boundarySource === 'user') return;
          
          const isLastWord = (i === words.length - 1);
          const cleanWord = word.cyrillic.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
          const hasPunctuation = punctuationRegex.test(word.cyrillic);
          const isProclitic = this.proclitics.has(cleanWord);
          
          // Check if next word is enclitic
          const nextWord = words[i + 1];
          const nextCleanWord = nextWord 
            ? nextWord.cyrillic.replace(/[.,!?;:"""''–—]/g, '').toLowerCase() 
            : null;
          const nextIsEnclitic = nextCleanWord && this.enclitics.has(nextCleanWord);
          
          // Apply rules in priority order
          if (isLastWord) {
            word.rightBoundary = 'hard';
            word.boundarySource = 'auto';
          } else if (hasPunctuation) {
            word.rightBoundary = 'hard';
            word.boundarySource = 'punctuation';
          } else if (isProclitic) {
            word.rightBoundary = 'clitic';
            word.boundarySource = 'auto';
          } else if (nextIsEnclitic) {
            word.rightBoundary = 'clitic';
            word.boundarySource = 'auto';
          } else {
            // Default: SOFT — assimilation happens automatically
            // User can insert barriers when music has rests
            word.rightBoundary = 'soft';
            word.boundarySource = 'auto';
          }
        });
      },
      
      // ========================================
      // CROSS-WORD BOUNDARY ASSIMILATION
      // Grayson p. 248-257
      // ========================================
      
      // Voiceless → Voiced (for cross-boundary voicing)
      crossWordVoicingMap: {
        'p': 'b', 'pʲ': 'bʲ',
        'f': 'v', 'fʲ': 'vʲ',
        't': 'd', 'tʲ': 'dʲ',
        's': 'z', 'sʲ': 'zʲ',
        'ʃ': 'ʒ',
        'k': 'ɡ', 'kʲ': 'ɡʲ',
        'x': 'ɣ', 'xʲ': 'ɣʲ',      // Cross-boundary allophone
        'ts': 'dz',                 // Cross-boundary allophone
        'tʃʲ': 'dʒʲ'                // Cross-boundary allophone
      },
      
      // Voiced → Voiceless (for cross-boundary devoicing)
      crossWordDevoicingMap: {
        'b': 'p', 'bʲ': 'pʲ',
        'v': 'f', 'vʲ': 'fʲ',
        'd': 't', 'dʲ': 'tʲ',
        'z': 's', 'zʲ': 'sʲ',
        'ʒ': 'ʃ',
        'ɡ': 'k', 'ɡʲ': 'kʲ',
        'g': 'k', 'gʲ': 'kʲ'        // Handle both ɡ and g
      },
      
      // Consonant sets for cross-word assimilation
      crossWordVoicelessSet: new Set(['p', 'pʲ', 'f', 'fʲ', 't', 'tʲ', 's', 'sʲ', 'ʃ', 'ʃʲ', 'k', 'kʲ', 'x', 'xʲ', 'ts', 'tʃʲ', 'ʃʲʃʲ']),
      crossWordVoicedObstruentSet: new Set(['b', 'bʲ', 'd', 'dʲ', 'g', 'gʲ', 'ɡ', 'ɡʲ', 'z', 'zʲ', 'ʒ', 'ʒʲ']),
      crossWordSonorantSet: new Set(['m', 'mʲ', 'n', 'nʲ', 'ɲ', 'l', 'lʲ', 'ɫ', 'r', 'rʲ', 'j']),
      crossWordVSet: new Set(['v', 'vʲ']),
      
      /**
       * Extract final consonant(s) from IPA string.
       * Returns null if word ends in vowel.
       */
      getFinalConsonant(ipa) {
        // Remove stress marks first
        const clean = ipa.replace(/[ˈˌ]/g, '');
        // Match final consonant cluster (including affricates and palatalization)
        // Order matters: try longer sequences first
        const patterns = [
          'ʃʲʃʲ', 'tʃʲ', 'dʒʲ', 'ts', 'dz',  // Affricates
          'bʲ', 'pʲ', 'vʲ', 'fʲ', 'dʲ', 'tʲ', 'gʲ', 'ɡʲ', 'kʲ', 'zʲ', 'sʲ', 'ʒʲ', 'ʃʲ', 'xʲ', 'mʲ', 'nʲ', 'lʲ', 'rʲ',  // Palatalized
          'b', 'p', 'v', 'f', 'd', 't', 'g', 'ɡ', 'k', 'z', 's', 'ʒ', 'ʃ', 'x', 'm', 'n', 'ɲ', 'l', 'ɫ', 'r', 'j'  // Plain
        ];
        
        for (const pat of patterns) {
          if (clean.endsWith(pat)) {
            return pat;
          }
        }
        return null;
      },
      
      /**
       * Extract initial consonant(s) from IPA string.
       * Returns null if word starts with vowel.
       */
      getInitialConsonant(ipa) {
        // Remove stress marks first
        const clean = ipa.replace(/[ˈˌ]/g, '');
        // Match initial consonant cluster
        const patterns = [
          'ʃʲʃʲ', 'tʃʲ', 'dʒʲ', 'ts', 'dz',
          'bʲ', 'pʲ', 'vʲ', 'fʲ', 'dʲ', 'tʲ', 'gʲ', 'ɡʲ', 'kʲ', 'zʲ', 'sʲ', 'ʒʲ', 'ʃʲ', 'xʲ', 'mʲ', 'nʲ', 'lʲ', 'rʲ',
          'b', 'p', 'v', 'f', 'd', 't', 'g', 'ɡ', 'k', 'z', 's', 'ʒ', 'ʃ', 'x', 'm', 'n', 'ɲ', 'l', 'ɫ', 'r', 'j'
        ];
        
        for (const pat of patterns) {
          if (clean.startsWith(pat)) {
            return pat;
          }
        }
        return null;
      },
      
      /**
       * Check if consonant is voiceless.
       */
      isVoicelessConsonant(c) {
        return this.crossWordVoicelessSet.has(c);
      },
      
      /**
       * Check if consonant is voiced obstruent (can trigger voicing).
       */
      isVoicedObstruent(c) {
        return this.crossWordVoicedObstruentSet.has(c);
      },
      
      /**
       * Check if consonant is sonorant (neutral for voicing).
       */
      isSonorantConsonant(c) {
        return this.crossWordSonorantSet.has(c);
      },
      
      /**
       * Check if consonant is /v/ (special: no assimilative influence per Grayson).
       */
      isVPhoneme(c) {
        return this.crossWordVSet.has(c);
      },
      
      /**
       * Apply voicing to final consonant of IPA string.
       */
      applyVoicingToFinal(ipa, finalC) {
        const voiced = this.crossWordVoicingMap[finalC];
        if (!voiced) return ipa;
        return ipa.slice(0, -finalC.length) + voiced;
      },
      
      /**
       * Apply devoicing to final consonant of IPA string.
       */
      applyDevoicingToFinal(ipa, finalC) {
        const devoiced = this.crossWordDevoicingMap[finalC];
        if (!devoiced) return ipa;
        return ipa.slice(0, -finalC.length) + devoiced;
      },
      
      /**
       * Apply cross-word voicing assimilation to a line of words.
       * Modifies word objects in place, setting ipaSurface.
       * 
       * Grayson p. 248-257:
       * - Voicing determined by RIGHTMOST consonant (regressive)
       * - Only crosses 'soft' or 'clitic' boundaries
       * - Sonorants and /v/ are neutral (don't trigger, but DO undergo)
       */
      applyCrossWordAssimilation(words) {
        // Initialize: copy ipaUnderlying to ipaSurface, set skipFinalDevoicing
        words.forEach(word => {
          word.ipaSurface = word.ipaUnderlying;
          word.skipFinalDevoicing = false;
        });
        
        // Process each boundary
        for (let i = 0; i < words.length - 1; i++) {
          const leftWord = words[i];
          const rightWord = words[i + 1];
          
          // Skip hard boundaries
          if (leftWord.rightBoundary === 'hard') continue;
          
          const leftFinal = this.getFinalConsonant(leftWord.ipaSurface);
          const rightInitial = this.getInitialConsonant(rightWord.ipaSurface);
          
          // Skip if either word lacks consonant at boundary
          if (!leftFinal || !rightInitial) continue;
          
          // Skip if right initial is sonorant or /v/ (no assimilative influence)
          if (this.isSonorantConsonant(rightInitial) || this.isVPhoneme(rightInitial)) continue;
          
          // SIBILANT MERGERS (Grayson pp. 235-236)
          // с/з + ш → /ʃː/, с/з + ж → /ʒː/
          // These take priority over voicing assimilation (complete merger, not just voicing change)
          const sibilantMergers = {
            's':  { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'z':  { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'sʲ': { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'zʲ': { 'ʃ': 'ʃː', 'ʒ': 'ʒː' }
          };
          
          if (sibilantMergers[leftFinal]?.[rightInitial]) {
            // Complete merger: delete left final, geminate right initial
            // Example: с шумом → /ʃːumʌm/ (not /s ʃumʌm/)
            const geminate = sibilantMergers[leftFinal][rightInitial];
            leftWord.ipaSurface = leftWord.ipaSurface.slice(0, -leftFinal.length);
            
            // Handle stress marks: getInitialConsonant strips stress marks before matching,
            // but ipaSurface may start with ˈ or ˌ. Preserve stress position.
            const rightSurface = rightWord.ipaSurface;
            const stressMatch = rightSurface.match(/^[ˈˌ]+/);
            const stressPrefix = stressMatch ? stressMatch[0] : '';
            const afterStress = rightSurface.slice(stressPrefix.length);
            const afterConsonant = afterStress.slice(rightInitial.length);
            rightWord.ipaSurface = stressPrefix + geminate + afterConsonant;
            
            leftWord.skipFinalDevoicing = true;
            continue; // Skip voicing assimilation - merger already handled
          }
          
          // Determine assimilation direction
          if (this.isVoicedObstruent(rightInitial) && this.isVoicelessConsonant(leftFinal)) {
            // Voice the left final: слух был → sɫuɣ bɨɫ
            leftWord.ipaSurface = this.applyVoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;
          } else if (this.isVoicelessConsonant(rightInitial) && this.isVoicedObstruent(leftFinal)) {
            // Devoice the left final: друг там → druk tam
            leftWord.ipaSurface = this.applyDevoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;  // Already handled
          } else if (this.isVoicelessConsonant(rightInitial) && this.isVPhoneme(leftFinal)) {
            // Special case: /v/ devoices before voiceless consonants (в шутку → f ʃutku)
            // Grayson: /v/ doesn't TRIGGER voicing, but DOES UNDERGO devoicing
            leftWord.ipaSurface = this.applyDevoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;
          }
        }
        
        // Apply final devoicing to words that didn't undergo cross-word assimilation
        words.forEach((word, i) => {
          const isLastWord = (i === words.length - 1);
          const hasHardBoundary = (word.rightBoundary === 'hard');
          
          if ((isLastWord || hasHardBoundary) && !word.skipFinalDevoicing) {
            word.ipaSurface = this.applyFinalDevoicing(word.ipaSurface);
          }
        });
      }
    };
    
    // Initialize derived clitic Sets from cliticData (DRY - single source of truth)
    GraysonEngine.proclitics = new Set(
      [...GraysonEngine.cliticData.entries()]
        .filter(([_, d]) => d.type === 'proclitic')
        .map(([k, _]) => k)
    );
    GraysonEngine.enclitics = new Set(
      [...GraysonEngine.cliticData.entries()]
        .filter(([_, d]) => d.type === 'enclitic')
        .map(([k, _]) => k)
    );

    /* ========================================
       OCR MODULE - Russian Text Recognition
       Lazy-loads Tesseract.js for image-to-text
       ======================================== */
    const OCRModule = {
      // Configuration
      TESSERACT_VERSION: '5',
      CDN_PRIMARY: 'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js',
      CDN_FALLBACK: 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js',
      INIT_TIMEOUT: 60000, // OCR can be slow
      MAX_IMAGE_WIDTH: 1200,
      CONFIDENCE_SKIP: 40,
      CONFIDENCE_DUBIOUS: 80,
      
      // State
      isLoaded: false,
      isProcessing: false,
      
      // Callbacks
      _onProgress: null,
      _onError: null,
      
      /**
       * Check if OCR is supported in this browser
       */
      isSupported() {
        return !!(
          window.Worker &&
          window.Blob &&
          window.URL &&
          window.FileReader &&
          HTMLCanvasElement.prototype.toBlob
        );
      },
      
      /**
       * Load external script with promise
       */
      loadScript(url) {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = url;
          script.async = true;
          script.onload = resolve;
          script.onerror = () => reject(new Error(`Failed to load: ${url}`));
          document.head.appendChild(script);
        });
      },
      
      /**
       * Initialize - just load the Tesseract.js library
       */
      async init() {
        if (this.isLoaded) return true;
        if (!this.isSupported()) {
          this._onError?.('OCR not supported in this browser');
          return false;
        }
        
        try {
          // Load Tesseract.js library with fallback
          if (!window.Tesseract) {
            console.log('Loading Tesseract.js...');
            try {
              await this.loadScript(this.CDN_PRIMARY);
              console.log('Tesseract.js loaded from primary CDN');
            } catch (e) {
              console.warn('Primary CDN failed, trying fallback...');
              await this.loadScript(this.CDN_FALLBACK);
              console.log('Tesseract.js loaded from fallback CDN');
            }
          }
          
          this.isLoaded = true;
          console.log('OCR module ready');
          return true;
        } catch (err) {
          this.isLoaded = false;
          this._onError?.('OCR unavailable. Please type or paste text.');
          console.error('OCR init failed:', err);
          return false;
        }
      },
      
      /**
       * Resize image to max width while preserving aspect ratio
       */
      async resizeImage(file) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const url = URL.createObjectURL(file);
          
          img.onload = () => {
            URL.revokeObjectURL(url); // Free memory immediately
            
            let { width, height } = img;
            
            // Only downscale, never upscale
            if (width > this.MAX_IMAGE_WIDTH) {
              const ratio = this.MAX_IMAGE_WIDTH / width;
              width = this.MAX_IMAGE_WIDTH;
              height = Math.round(height * ratio);
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            resolve(canvas);
          };
          
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
          };
          
          img.src = url;
        });
      },
      
      /**
       * Preprocess canvas for better OCR (grayscale + contrast)
       */
      preprocessCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Convert to grayscale and boost contrast
        for (let i = 0; i < data.length; i += 4) {
          // Grayscale using luminance formula
          const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
          
          // Simple contrast boost (stretch to 0-255)
          const contrast = Math.min(255, Math.max(0, (gray - 128) * 1.5 + 128));
          
          data[i] = data[i + 1] = data[i + 2] = contrast;
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
      },
      
      /**
       * Fix common OCR errors and filter non-Russian content
       */
      cleanRussianText(text) {
        if (!text) return '';
        
        // Helper: calculate Cyrillic density of a string (0-1)
        const cyrillicDensity = (str) => {
          const letters = str.match(/[a-zA-Zа-яА-ЯёЁ]/g) || [];
          if (letters.length === 0) return 0;
          const cyrillic = str.match(/[а-яА-ЯёЁ]/g) || [];
          return cyrillic.length / letters.length;
        };
        
        // Helper: detect garbage patterns (garbled English→Cyrillic)
        const isGarbage = (str) => {
          // Contains $ or multiple punctuation mixed with letters
          if (/\$/.test(str)) return true;
          if (/[!?]{2,}/.test(str)) return true;
          // Parentheses with mostly non-Cyrillic inside
          if (/\([^)]*\)/.test(str)) {
            const parenContent = str.match(/\(([^)]*)\)/)?.[1] || '';
            if (cyrillicDensity(parenContent) < 0.3) return true;
          }
          // Backslash (common OCR error)
          if (/\\/.test(str)) return true;
          return false;
        };
        
        let result = text;
        
        // Filter lines: keep only those with >50% Cyrillic letters
        result = result.split('\n').filter(line => {
          const trimmed = line.trim();
          if (!trimmed) return false;
          
          // Skip garbage patterns
          if (isGarbage(trimmed)) {
            console.log('OCR filter: removing garbage line:', trimmed);
            return false;
          }
          
          // Check Cyrillic density
          const density = cyrillicDensity(trimmed);
          if (density < 0.5) {
            console.log('OCR filter: removing low-density line:', trimmed, `(${(density*100).toFixed(0)}%)`);
            return false;
          }
          
          return true;
        }).join('\n');
        
        // Latin→Cyrillic fixes (only between Cyrillic chars)
        const latinToCyrillic = [
          [/(?<=[а-яА-ЯёЁ])3(?=[а-яА-ЯёЁ])/g, 'з'],
          [/(?<=[а-яА-ЯёЁ])e(?=[а-яА-ЯёЁ])/gi, 'е'],
          [/(?<=[а-яА-ЯёЁ])c(?=[а-яА-ЯёЁ])/gi, 'с'],
          [/(?<=[а-яА-ЯёЁ])o(?=[а-яА-ЯёЁ])/gi, 'о'],
          [/(?<=[а-яА-ЯёЁ])p(?=[а-яА-ЯёЁ])/gi, 'р'],
          [/(?<=[а-яА-ЯёЁ])x(?=[а-яА-ЯёЁ])/gi, 'х'],
          [/(?<=[а-яА-ЯёЁ])a(?=[а-яА-ЯёЁ])/gi, 'а'],
          [/(?<=[а-яА-ЯёЁ])y(?=[а-яА-ЯёЁ])/gi, 'у'],
          [/(?<=[а-яА-ЯёЁ])H(?=[а-яА-ЯёЁ])/g, 'Н'],
          [/(?<=[а-яА-ЯёЁ])B(?=[а-яА-ЯёЁ])/g, 'В'],
          [/(?<=[а-яА-ЯёЁ])K(?=[а-яА-ЯёЁ])/g, 'К'],
          [/(?<=[а-яА-ЯёЁ])M(?=[а-яА-ЯёЁ])/g, 'М'],
        ];
        
        for (const [pattern, replacement] of latinToCyrillic) {
          result = result.replace(pattern, replacement);
        }
        
        // Filter out garbage words within lines
        result = result.split('\n').map(line => {
          return line.split(/\s+/).filter(word => {
            // Keep if word contains at least one Cyrillic letter
            if (/[а-яА-ЯёЁ]/.test(word)) return true;
            // Filter out pure numbers (page numbers like "219")
            if (/^\d+$/.test(word)) return false;
            // Filter out single non-Cyrillic characters
            if (word.length === 1 && !/[а-яА-ЯёЁ]/.test(word)) return false;
            // Keep punctuation
            if (/^[.,!?;:\-—–]+$/.test(word)) return true;
            return false;
          }).join(' ');
        }).filter(line => line.trim()).join('\n');
        
        // Structural cleanup
        result = result
          .replace(/[ \t]+/g, ' ')           // Collapse spaces
          .replace(/\n{3,}/g, '\n\n')        // Max 2 newlines
          .replace(/^\s+|\s+$/gm, '');       // Trim lines
        
        return result;
      },
      
      /**
       * Main entry point: process image file → Russian text
       * Uses Tesseract.recognize() which handles worker lifecycle internally
       */
      async processImage(file, onProgress) {
        if (this.isProcessing) {
          console.warn('OCR already processing');
          return null;
        }
        
        if (!this.isLoaded) {
          const loaded = await this.init();
          if (!loaded) {
            throw new Error('OCR initialization failed');
          }
        }
        
        this.isProcessing = true;
        
        try {
          // Step 1: Resize image
          onProgress?.('processing', 0);
          console.log('Resizing image...');
          const canvas = await this.resizeImage(file);
          
          // Step 2: Preprocess for better recognition
          onProgress?.('processing', 0.1);
          console.log('Preprocessing image...');
          this.preprocessCanvas(canvas);
          
          // Step 3: Run Tesseract using simple recognize() API
          // Use rus+eng to handle mixed content (headers, metadata)
          // Then filter to keep only Cyrillic-dominant lines
          onProgress?.('recognizing text', 0.2);
          console.log('Running OCR recognition (rus+eng)...');
          
          const result = await Tesseract.recognize(canvas, 'rus+eng', {
            logger: m => {
              console.log('Tesseract:', m.status, m.progress);
              if (m.status) {
                onProgress?.(m.status, m.progress);
              }
            }
          });
          
          // Step 4: Use full text (preserves line structure) instead of rebuilding from words
          onProgress?.('cleaning', 0.9);
          console.log('Processing results...');
          
          // Use data.text which preserves line breaks and layout
          let text = result.data.text || '';
          
          // Step 5: Clean up the text
          text = this.cleanRussianText(text);
          
          // Validate we got Cyrillic content
          if (!/[а-яА-ЯёЁ]{3,}/.test(text)) {
            throw new Error('No Cyrillic text found in image');
          }
          
          console.log('OCR complete, extracted', text.length, 'characters');
          return text;
          
        } finally {
          this.isProcessing = false;
        }
      },
      
      /**
       * Set error callback
       */
      onError(callback) {
        this._onError = callback;
      }
    };

    /* ========================================
       RULE REGISTRY - Phoneme Ribbon Blurbs
       Maps transcription features → educational blurbs
       ======================================== */
    const RuleRegistry = {
      // Blurb data - keyed by "IPA:rule:char"
      // Full 85 entries from PHONEME_BLURBS_DRAFT.md
      blurbs: {
        // ========================================
        // SECTION 1: VOWELS — STRESSED (Entries 1–10)
        // ========================================
        
        // Entry 1 | Dark-a
        'ɑ:stressed:а': { blurb: 'Stressed ⟨а⟩ is pronounced /ɑ/, the default sung Russian "a". This is the familiar backed variant in the word "father."', citation: 'pp. 81–85', notable: false },
        
        // Entry 2 | Bright-a
        'a:stressed-interpalatal:а': { blurb: 'The default dark-a /ɑ/ phoneme fronts to its brighter /a/ allophone whenever it sits between two palatalizing agents; these may be any combination of: a soft sign ⟨ь⟩, a palatalized consonant, or a /j/-glide. Bright-a /a/ is the more singable analog for the spoken Russian /æ/.', citation: 'pp. 81–85, 125', notable: true },
        
        // Entry 3 | Stressed-o
        'o:stressed:о': { blurb: 'Stressed ⟨о⟩ is pronounced /o/. Grayson (p. 86) explicitly states that stressed /o/ is "transcribed simply as /o/," not as open-mid /ɔ/.', citation: 'p. 86', notable: false },
        
        // Entry 4 | Stressed-o (ё spelling)
        'o:stressed:ё': { blurb: 'The letter ⟨ё⟩ is always stressed. It is pronounced /o/, identical to stressed ⟨о⟩. The diaeresis signals that this vowel is a member of the \'soft\' series (⟨я е и ё ю⟩) and typically follows a palatalized consonant (exceptions: the always-hard ⟨ж⟩ and ⟨ш⟩). Word-initially, a /j/-glide precedes this vowel as /jo/.', citation: 'pp. 85–86', notable: false },
        
        // Entry 5 | Open-e
        'ɛ:stressed:е': { blurb: 'The default pronunciation of stressed ⟨е⟩ is /ɛ/, as in ⟨bed⟩ /bɛd/ (English), ⟨mer⟩ /mɛʁ/ "sea" (French), ⟨Geld⟩ /gɛlt/ "money" (German), or ⟨è⟩ /ɛ/ "is" (Italian).', citation: 'pp. 87–90', notable: false },
        
        // Entry 6 | Close-e
        'e:stressed-interpalatal:е': { blurb: 'When stressed ⟨е⟩ occurs between two palatalized consonants (interpalatal context), it is pronounced /e/, the close-mid front vowel. This raising is a natural coarticulatory effect.', citation: 'pp. 87–90, 125', notable: true },
        
        // Entry 7 | Stressed-i
        'i:stressed:и': { blurb: 'Stressed ⟨и⟩ is usually pronounced /i/.', citation: 'p. 96', notable: false },
        
        // Entry 8 | Barred-i
        'ɨ:stressed:ы': { blurb: "Stressed ⟨ы⟩ is pronounced /ɨ/, the close central unrounded vowel. North American English speakers may recognize this vowel in the words 'milk' or 'will' when spoken quickly. Velar-i is as ubiquitous in sung Russian as it is challenging to master. See <em>Ilya</em>'s LEARN module for more.", citation: 'pp. 93–95', notable: false },
        
        // Entry 9 | Stressed-u
        'u:stressed:у': { blurb: 'The letter ⟨у⟩ is always pronounced /u/, whether stressed or unstressed.', citation: 'pp. 91–93', notable: false },
        
        // Entry 10 | Stressed-u (ю spelling)
        'u:stressed:ю': { blurb: 'Stressed ⟨ю⟩ is pronounced /u/, identical to stressed ⟨у⟩. The spelling signals that this vowel follows a palatalized consonant (or word-initially, that a /j/-glide precedes it).', citation: 'pp. 91–92', notable: false },
        
        // ========================================
        // SECTION 2: VOWELS — UNSTRESSED (Entries 11–25)
        // ========================================
        
        // Entry 11 | Pre-tonic о → /ɑ/
        'ɑ:pretonic:о': { blurb: 'When ⟨о⟩ appears in pretonic position (the syllable immediately before the stress), it is pronounced /ɑ/. This is akanye /ˈɑ kʌ ɲɪ/, one of the defining features of sung Russian pronunciation.', citation: 'pp. 108, 127', notable: true },
        
        // Entry 12 | Word-initial о → /ɑ/
        'ɑ:initial:о': { blurb: 'Whenever unstressed ⟨о⟩ begins a word, it is pronounced /ɑ/. This is an aspect of akanye /ˈɑ kʌ ɲɪ/, one of the defining features of sung Russian pronunciation.', citation: 'pp. 108, 127', notable: true },
        
        // Entry 13 | Pre-tonic а → /ɑ/
        'ɑ:pretonic:а': { blurb: 'When ⟨а⟩ appears in pretonic position (the syllable immediately before the stress), it is pronounced /ɑ/.', citation: 'pp. 97–102', notable: false },
        
        // Entry 11b | Pretonic interpalatal а → /a/
        'a:pretonic-interpalatal:а': { blurb: 'When ⟨а⟩ appears in pretonic position between two palatalized consonants (interpalatal context), it is pronounced /a/. This fronting is a natural coarticulatory effect.', citation: 'pp. 108, 127', notable: false },
        
        // Entry 14 | Word-initial а → /ɑ/
        'ɑ:initial:а': { blurb: 'Whenever unstressed ⟨а⟩ begins a word, it is pronounced /ɑ/.', citation: 'pp. 108, 127', notable: false },
        
        // Entry 15 | Post-stress immediate а → /ɑ/
        'ɑ:post-stress-immediate:а': { blurb: 'When ⟨а⟩ appears in the syllable immediately following the stress, it is pronounced /ɑ/.', citation: 'pp. 108, 127', notable: false },
        
        // Entry 16 | Turned-v (remote о)
        'ʌ:remote:о': { blurb: 'When unstressed ⟨о⟩ is remote from the stress, it reduces to /ʌ/. This is an aspect of akanye /ˈɑ kʌ ɲɪ/, one of the defining features of sung Russian pronunciation. <em>Ilya</em> uses turned-v /ʌ/ rather than schwa /ə/ to avoid confusion with the lip-rounded French vowel.', citation: 'pp. 108, 127', notable: true },
        
        // Entry 17 | Turned-v (remote а)
        'ʌ:remote:а': { blurb: 'When unstressed ⟨а⟩ is remote from the stress, it reduces to /ʌ/. This is an aspect of akanye /ˈɑ kʌ ɲɪ/, one of the defining features of sung Russian pronunciation. <em>Ilya</em> uses turned-v /ʌ/ rather than schwa /ə/ to avoid confusion with the lip-rounded French vowel.', citation: 'pp. 108, 127', notable: true },
        
        // Entry 18 | Unstressed е → /ɪ/
        'ɪ:ikanye:е': { blurb: 'When ⟨е⟩ is unstressed, it reduces to /ɪ/. This is an aspect of ikanye /ˈi kʌ ɲɪ/, a defining feature of sung Russian pronunciation.', citation: 'pp. 97–107', notable: true },
        
        // Entry 19 | Reflexive я → [ʌ]
        'ʌ:reflexive:я': { blurb: 'The reflexive verb endings ⟨-тся⟩ and ⟨-ться⟩ always feature /ʌ/ as their vowel sound. This /ʌ/ derives from ⟨я⟩, which exceptionally reduces to /ʌ/ (not /ɪ/) in this context. See Entry 73 for a complete explanation of these endings.', citation: 'pp. 237–238, 281–282', notable: true },
        
        // Entry 20 | Unstressed я → /ɪ/
        'ɪ:ikanye:я': { blurb: 'When ⟨я⟩ is unstressed (except in reflexive endings), it reduces to /ɪ/. This is an aspect of ikanye /ˈi kʌ ɲɪ/, a defining feature of sung Russian pronunciation.', citation: 'pp. 97–107', notable: true },
        
        // Entry 21 | Unstressed и → /i/
        'i:unstressed:и': { blurb: 'Unstressed ⟨и⟩ remains /i/. Unlike other vowels, ⟨и⟩ never reduces in sung Russian (Grayson p. 96): "neither syllabic stress nor position affects the reading as /i/, in sung Russian."', citation: 'p. 96', notable: true },
        
        // Entry 22 | Unstressed ы → /ɨ/
        'ɨ:unstressed:ы': { blurb: 'Unstressed ⟨ы⟩ is pronounced /ɨ/, the same as stressed ⟨ы⟩. This vowel does not reduce.', citation: 'pp. 93–95', notable: false },
        
        // Entry 23 | Unstressed у → /u/
        'u:unstressed:у': { blurb: 'Unstressed ⟨у⟩ is pronounced /u/. This vowel does not reduce significantly in sung Russian.', citation: 'pp. 91–92', notable: false },
        
        // Entry 24 | Unstressed ю → /u/
        'u:unstressed:ю': { blurb: 'Unstressed ⟨ю⟩ is pronounced /u/, identical to unstressed ⟨у⟩. This vowel does not reduce significantly in sung Russian.', citation: 'pp. 91–92', notable: false },
        
        // Entry 25 | Unstressed э → /ɪ/
        'ɪ:unstressed:э': { blurb: 'When ⟨э⟩ is unstressed, it reduces to /ɪ/. This relatively rare letter (found mainly in loanwords) follows the same reduction pattern as ⟨е⟩.', citation: 'pp. 97–107', notable: false },
        
        // ========================================
        // SECTION 3: VOWELS — J-GLIDE (Entries 26–33)
        // ========================================
        
        // Entry 26 | Word-initial stressed я → /jɑ/
        'jɑ:initial:я': { blurb: 'When stressed ⟨я⟩ begins a word, it is pronounced /jɑ/.', citation: 'pp. 114–124', notable: false },
        
        // Entry 27 | Word-initial stressed е → /jɛ/
        'jɛ:initial:е': { blurb: 'When stressed ⟨е⟩ begins a word, it is pronounced /jɛ/.', citation: 'pp. 114–124', notable: false },
        
        // Entry 28 | Word-initial stressed ё → /jo/
        'jo:initial:ё': { blurb: 'When stressed ⟨ё⟩ begins a word, it is pronounced /jo/.', citation: 'pp. 114–124', notable: false },
        
        // Entry 29 | Word-initial stressed ю → /ju/
        'ju:initial:ю': { blurb: 'Whenever ⟨ю⟩ begins a word, it is pronounced /ju/.', citation: 'pp. 114–124', notable: false },
        
        // Entry 30 | Word-initial unstressed е → /jɪ/
        'jɪ:unstressed-initial:е': { blurb: 'Whenever unstressed ⟨е⟩ begins a word, it is pronounced /jɪ/. This is an aspect of ikanye /ˈi kʌ ɲɪ/, a defining feature of sung Russian pronunciation.', citation: 'pp. 114–124', notable: true },
        
        // Entry 31 | Word-initial unstressed я → /jɪ/
        'jɪ:unstressed-initial:я': { blurb: 'Whenever unstressed ⟨я⟩ begins a word, it is pronounced /jɪ/. The reduction of this unstressed vowel is an aspect of ikanye /ˈi kʌ ɲɪ/, a defining feature of sung Russian pronunciation.', citation: 'pp. 114–124', notable: true },
        
        // Entry 32 | /j/-glide after vowel
        'j:after-vowel:е': { blurb: 'Whenever ⟨е⟩ immediately follows another vowel, a /j/ glide is inserted before the vowel sound (e.g., ⟨моего⟩ /mʌjɪˈvo/ "my/mine" and ⟨оперное⟩ /ˈopɛrnʌjɪ/ "operatic").', citation: 'pp. 114–124', notable: false },
        
        // Entry 33 | /j/-glide insertion after ъ/ь
        'j:after-sign:е': { blurb: 'Whenever ⟨е⟩ immediately follows a hard sign ⟨ъ⟩ or soft sign ⟨ь⟩, a /j/ glide is inserted before the vowel sound (e.g., ⟨въезд⟩ /vjɛst/ "entrance," ⟨пьеса⟩ /pʲˈjɛsʌ/ "play").', citation: 'pp. 114–124', notable: false },
        
        // ========================================
        // SECTION 4: CONSONANTS — SOFT/PALATALIZED (Entries 34–50)
        // ========================================
        
        // Entry 34 | Palatal nasal
        'ɲ:soft:н': { blurb: 'Soft ⟨н⟩ is a true palatal nasal /ɲ/, not simply /n/ with a palatalization marker. Grayson\'s transcription distinguishes palatalized /nʲ/ (dental, rare) from palatal /ɲ/ (default soft н).', citation: 'pp. 183–184', notable: false },
        
        // Entry 35 | Palatalized (\'soft\')-l
        'lʲ:soft:л': { blurb: 'Soft ⟨л⟩ is pronounced /lʲ/. Unlike hard ⟨л⟩ [ɫ], which is velarized, soft /lʲ/ has a clear, bright quality similar to the "l" in "million."', citation: 'pp. 150–151', notable: false },
        
        // Entry 36 | Palatalized (\'soft\')-r
        'rʲ:soft:р': { blurb: 'Soft ⟨р⟩ is pronounced /rʲ/, a palatalized trill. The tongue maintains the trilled articulation while the body of the tongue rises toward the palate.', citation: 'pp. 156–158', notable: false },
        
        // Entry 37 | Palatalized (\'soft\')-s
        'sʲ:soft:с': { blurb: 'Predictably, ⟨с⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant).', citation: 'pp. 155–156', notable: false },
        
        // Entry 38 | Palatalized (\'soft\')-t
        'tʲ:soft:т': { blurb: 'Predictably, ⟨т⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Like \'hard\' /t/, \'soft\' /tʲ/ is dental (tongue on teeth).', citation: 'pp. 140–145', notable: false },
        
        // Entry 39 | Palatalized (\'soft\')-d
        'dʲ:soft:д': { blurb: 'Predictably, ⟨д⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Like \'hard\' /d/, \'soft\' /dʲ/ is dental (tongue on teeth).', citation: 'pp. 146–147', notable: false },
        
        // Entry 40 | Palatalized (\'soft\')-p
        'pʲ:soft:п': { blurb: 'Predictably, ⟨п⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Like hard /p/, soft /pʲ/ is unaspirated.', citation: 'pp. 147–148', notable: false },
        
        // Entry 41 | Palatalized (\'soft\')-b
        'bʲ:soft:б': { blurb: 'Predictably, ⟨б⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant).', citation: 'pp. 140–141', notable: false },
        
        // Entry 42 | Palatalized (\'soft\')-v
        'vʲ:soft:в': { blurb: 'The letter ⟨в⟩ is phonemically weak: processes happen to it, but it doesn\'t usually transmit them. Accordingly, ⟨в⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Note: the single-letter preposition ⟨в⟩ "in/into" does accept palatalization across the word boundary (e.g., ⟨в небе⟩ /vʲ ˈɲebʲɪ/ "in the sky"). This behaviour applies equally to the preposition ⟨в⟩ and the prefix ⟨в-⟩ (e.g., ⟨вниз⟩ /vɲis/ "down," ⟨внести⟩ /vɲiˈsʲtʲi/ "to bring in"), but never to content words that end in ⟨в⟩ (e.g., ⟨гнев⟩ /ɡɲɛf/ "wrath," ⟨залив⟩ /zʌˈlʲif/ "bay," and ⟨рукав⟩ /ruˈkɑf/ "sleeve").', citation: 'pp. 181–182', notable: false },
        
        // Entry 43 | Palatalized (\'soft\')-f
        'fʲ:soft:ф': { blurb: 'Predictably, ⟨ф⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant).', citation: 'pp. 181–182', notable: false },
        
        // Entry 44 | Palatalized (\'soft\')-m
        'mʲ:soft:м': { blurb: 'Predictably, ⟨м⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). In isolation, /mʲ/ is practically indistinguishable from unpalatalized /m/ to the ear.', citation: 'p. 185', notable: false },
        
        // Entry 45 | Palatalized (\'soft\')-k
        'kʲ:soft:к': { blurb: '⟨К⟩ /k/ is one of the three sung Russian velar consonants alongside ⟨г⟩ /ɡ/ and ⟨х⟩ /x/ (or its voiced allophone [ɣ]). While ⟨к⟩ softens before some palatalizing agents (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩) or the soft sign ⟨ь⟩), only another velar consonant can regressively palatalize it. Like hard /k/, soft /kʲ/ is unaspirated.', citation: 'pp. 187–188, 209', notable: false },
        
        // Entry 46 | Palatalized (\'soft\')-g
        'ɡʲ:soft:г': { blurb: '⟨Г⟩ /ɡ/ is one of the three sung Russian velar consonants alongside ⟨к⟩ /k/ and ⟨х⟩ /x/ (or its voiced allophone [ɣ]). While ⟨г⟩ softens before some palatalizing agents (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩) or the soft sign ⟨ь⟩), only another velar consonant can regressively palatalize it. Note: Grayson\'s preferred IPA symbol is opentail [ɡ], although the International Phonetic Association accepts Latin [g] as equally valid.', citation: 'pp. 187–188, 209', notable: false },
        
        // Entry 47 | Palatalized (\'soft\')-x
        'xʲ:soft:х': { blurb: '⟨Х⟩ /x/ (or its voiced allophone [ɣ]) is one of the three sung Russian velar consonants alongside ⟨к⟩ /k/ and ⟨г⟩ /ɡ/. While ⟨х⟩ softens before some palatalizing agents (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩) or the soft sign ⟨ь⟩), only another velar consonant can regressively palatalize it. Russian /xʲ/ is velar, articulated midway between German ich-laut /ç/ (palatal) and ach-laut /χ/ (uvular); avoid substituting either.', citation: 'pp. 189, 209', notable: false },
        
        // Entry 48 | Palatalized (\'soft\')-z
        'zʲ:soft:з': { blurb: 'Predictably, ⟨з⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Note: the prepositions ⟨из⟩ "from" and ⟨без⟩ "without" do accept palatalization across the word boundary (e.g., ⟨из них⟩ /izʲ ɲix/ "from them"). This behaviour never applies to content words that end in ⟨з⟩.', citation: 'pp. 177–178', notable: false },
        
        // Entry 49 | Intrinsically soft ч
        'tʃʲ:always-soft:ч': { blurb: 'The letter ⟨ч⟩ /tʃʲ/ is intrinsically palatalized. Grayson notates it with the indivisible trigraph /tʃʲ/.', citation: 'pp. 175–176', notable: false },
        
        // Entry 50 | Intrinsically soft щ
        'ʃʲʃʲ:always-soft:щ': { blurb: 'The letter ⟨щ⟩ /ʃʲʃʲ/ is intrinsically palatalized and intrinsically geminate. Grayson prefers to notate this soft consonant as /ʃʲʃʲ/ to emphasize that Russians rearticulate the sound, but it is equally valid to notate it as /ʃʲː/ to reduce visual clutter. You may choose your own preference in the <em>Ilya</em> dashboard. Note: a dated Peterburgian or Church Slavonic pronunciation /ʃʲtʃʲ/ exists, but this is not <em>Ilya</em>\'s default for sung Russian.', citation: 'pp. 171–173', notable: false },
        
        // ========================================
        // SECTION 5: CONSONANTS — HARD/UNPALATALIZED (Entries 51–69)
        // ========================================
        
        // Entry 51 | Intrinsically hard ж
        'ʒ:always-hard:ж': { blurb: 'The letter ⟨ж⟩ /ʒ/ is intrinsically hard: it cannot soften, regardless of what follows. When it is followed by ⟨и⟩ or unstressed ⟨е⟩ (as is common due to traditional Russian spelling rules), ⟨ж⟩ remains unpalatalized /ʒ/ while these vowels are sung instead as the more compatible /ɨ/ (e.g., ⟨жить⟩ /ʒɨtʲ/ "to live," ⟨жена⟩ /ʒɨˈnɑ/ "wife").', citation: 'pp. 161–166', notable: false },
        
        // Entry 52 | Intrinsically hard ш
        'ʃ:always-hard:ш': { blurb: 'The letter ⟨ш⟩ /ʃ/ is intrinsically hard: it cannot soften, regardless of what follows. When it is followed by ⟨и⟩ or unstressed ⟨е⟩ (as is common due to traditional Russian spelling rules), ⟨ш⟩ remains unpalatalized /ʃ/ while these vowels are sung instead as the more compatible /ɨ/ (e.g., ⟨шить⟩ /ʃɨtʲ/ "to sew," ⟨шептать⟩ /ʃɨpˈtɑtʲ/ "to whisper").', citation: 'pp. 161–163', notable: false },
        
        // Entry 53 | Intrinsically hard ц
        'ts:always-hard:ц': { blurb: 'The letter ⟨ц⟩ /ts/ is intrinsically hard: it cannot soften, regardless of what follows. This digraph notates a single phoneme, /ts/, which can be confusing to Anglophones who routinely encounter mid-word /ts/ (i.e. /t/ + /s/) at a morpheme boundary (e.g., ⟨отсюда⟩ /ɑtʲˈsʲudʌ/ "from here"). Structurally, these very common cases are the result of the meeting of two separate phonemes, not the affricate ⟨ц⟩ /ts/, even though they are visually indistinguishable. When ⟨ц⟩ is followed by ⟨и⟩ or unstressed ⟨е⟩ (as is common due to traditional Russian spelling rules), it remains unpalatalized /ts/ and these vowels are sung instead as the more compatible /ɨ/ (e.g., ⟨цирк⟩ /tsɨrk/ "circus," ⟨цена⟩ /tsɨˈnɑ/ "price").', citation: 'pp. 166–168', notable: false },
        
        // Entry 54 | Unpalatalized (\'hard\')-l, a.k.a. velar-l
        'ɫ:hard:л': { blurb: 'Velarized hard-l [ɫ] is the default for ⟨л⟩ when no palatalizing agent follows. Note: the phoneme [l] never exists unqualified in sung Russian: it is always either \'soft\' (palatalized) /lʲ/ or \'hard\' (velarized) [ɫ], never a standalone [l].', citation: 'pp. 150–151', notable: false },
        
        // Entry 55 | /j/-glide
        'j:glide:й': { blurb: 'The letter ⟨й⟩ represents the familiar palatal glide /j/. Although English speakers often call this phoneme a semi-vowel, Russians consider /j/ a consonant. In native Russian words, ⟨й⟩ only appears after vowels, typically as the closing element in diphthongs (e.g., ⟨мой⟩ /moj/ "my/mine," ⟨чайка⟩ /ˈtʃʲajkʌ/ "seagull").', citation: 'p. 96', notable: false },
        
        // Entry 56 | Unpalatalized (\'hard\')-s
        's:hard:с': { blurb: 'Unpalatalized ⟨с⟩ /s/ is the default when no palatalizing agent follows.', citation: 'p. 155', notable: false },
        
        // Entry 57 | Unpalatalized (\'hard\')-z
        'z:hard:з': { blurb: 'Unpalatalized ⟨з⟩ /z/ is the default when no palatalizing agent follows.', citation: 'p. 140', notable: false },
        
        // Entry 58 | Unpalatalized (\'hard\')-t
        't:hard:т': { blurb: 'Unpalatalized ⟨т⟩ /t/ is the default when no palatalizing agent follows. Russian /t/ is dental (tongue on teeth, not alveolar as in English), but <em>Ilya</em> notates it as plain /t/.', citation: 'p. 140', notable: false },
        
        // Entry 59 | Unpalatalized (\'hard\')-d
        'd:hard:д': { blurb: 'Unpalatalized ⟨д⟩ /d/ is the default when no palatalizing agent follows. Russian /d/ is dental (tongue on teeth, not alveolar as in English), but <em>Ilya</em> notates it as plain /d/.', citation: 'p. 146', notable: false },
        
        // Entry 60 | Unpalatalized (\'hard\')-p
        'p:hard:п': { blurb: 'Unpalatalized ⟨п⟩ /p/ is the default when no palatalizing agent follows. Russian /p/ is unaspirated (like Italian), unlike English /pʰ/.', citation: 'p. 147', notable: false },
        
        // Entry 61 | Unpalatalized (\'hard\')-b
        'b:hard:б': { blurb: 'Unpalatalized ⟨б⟩ /b/ is the default when no palatalizing agent follows.', citation: 'p. 140', notable: false },
        
        // Entry 62 | Unpalatalized (\'hard\')-k
        'k:hard:к': { blurb: 'Unpalatalized ⟨к⟩ /k/ is the default when no palatalizing agent follows. Russian /k/ is unaspirated (like Italian), unlike English /kʰ/.', citation: 'p. 140', notable: false },
        
        // Entry 63 | Unpalatalized (\'hard\')-g
        'ɡ:hard:г': { blurb: 'Unpalatalized ⟨г⟩ /ɡ/ is the default when no palatalizing agent follows. Note: Grayson\'s preferred IPA symbol is opentail [ɡ], although the International Phonetic Association accepts Latin [g] as equally valid.', citation: 'p. 145', notable: false },
        
        // Entry 64 | Unpalatalized (\'hard\')-x
        'x:hard:х': { blurb: 'The letter ⟨х⟩ /x/ (or its voiced allophone [ɣ]) is one of the three sung Russian velar consonants alongside ⟨к⟩ /k/ and ⟨г⟩ /ɡ/. Unpalatalized /x/ is the default when no palatalizing agent follows, although this phoneme may undergo regressive voicing assimilation to become [ɣ]. This voiceless velar fricative resembles German ach-laut /χ/, but Russian /x/ is articulated further forward on the velum.', citation: 'p. 149', notable: false },
        
        // Entry 65 | Unpalatalized (\'hard\')-f
        'f:hard:ф': { blurb: 'Unpalatalized ⟨ф⟩ /f/ is the default when no palatalizing agent follows. All Russian words spelled with ⟨ф⟩ are loanwords.', citation: 'p. 148', notable: false },
        
        // Entry 66 | Unpalatalized (\'hard\')-v
        'v:hard:в': { blurb: 'Unpalatalized ⟨в⟩ /v/ is the default when no palatalizing agent follows. Note: ⟨в⟩ is phonemically weak. While it undergoes devoicing like any voiced consonant does (e.g., ⟨кров⟩ /krof/ "shelter"), ⟨в⟩ does not transmit voicing to preceding consonants (e.g., ⟨свет⟩ /svʲɛt/ "light," not */zvʲɛt/; ⟨твой⟩ /tvoj/ "your," not */dvoj/).', citation: 'pp. 152–153', notable: false },
        
        // Entry 67 | Unpalatalized (\'hard\')-m
        'm:hard:м': { blurb: 'Unpalatalized ⟨м⟩ /m/ is the default when no palatalizing agent follows.', citation: 'p. 140', notable: false },
        
        // Entry 68 | Unpalatalized (\'hard\')-n
        'n:hard:н': { blurb: 'Unpalatalized ⟨н⟩ /n/ is the default when no palatalizing agent follows. Russian /n/ is dental (tongue on teeth, not alveolar as in English), but <em>Ilya</em> notates it as plain /n/.', citation: 'p. 154', notable: false },
        
        // Entry 69 | Unpalatalized (\'hard\')-r
        'r:hard:р': { blurb: 'Unpalatalized ⟨р⟩ /r/ is the default when no palatalizing agent follows. Russian /r/ is a trilled alveolar, like Italian or Spanish /r/.', citation: 'p. 155', notable: false },
        
        // ========================================
        // SECTION 6: SIGNS (Entries 70–71)
        // ========================================
        
        // Entry 70 | Hard sign
        'hard-sign:ъ': { blurb: 'The hard sign ⟨ъ⟩ has no sound of its own. It serves as a silent boundary marker, preserving the unpalatalized state of its preceding consonant while signalling the insertion of a /j/-glide before the following vowel (e.g., ⟨съел⟩ /sjɛɫ/ "ate").', citation: 'pp. 192–194', notable: false },
        
        // Entry 71 | Soft sign
        'soft-sign:ь': { blurb: 'The soft sign ⟨ь⟩ /ʲ/ is silent yet phonetically consequential. It palatalizes its preceding consonant. When followed by a vowel, it also signals the insertion of a /j/-glide between the now-palatalized consonant and the following vowel (e.g., ⟨пьеса⟩ /pʲˈjɛsʌ/ "play"; note the contiguous /ʲ/ and /j/, which are not interchangeable). Exception: after the intrinsically hard consonants ⟨ж⟩ and ⟨ш⟩, the soft sign is purely orthographic and does not indicate palatalization. Ignore it.', citation: 'pp. 195–198', notable: false },
        
        // ========================================
        // SECTION 7: ALLOPHONES & PROCESSES (Entry 72)
        // ========================================
        
        // Entry 72 | Gamma
        'ɣ:allophone:х': { blurb: 'Just as /k/ becomes [ɡ] before a voiced consonant, ⟨х⟩ becomes [ɣ]. This voiced velar fricative [ɣ] is an allophone of /x/ without its own dedicated letterform.', citation: 'p. 215', notable: false },
        
        // ========================================
        // SECTION 8: SPECIAL CLUSTERS & EXCEPTIONS (Entries 73–85)
        // ========================================
        
        // Entry 73 | Reflexive verb endings ⟨-тся⟩ and ⟨-ться⟩
        'tːs:cluster:тс': { blurb: 'The reflexive verb endings ⟨-тся⟩ and ⟨-ться⟩ are two orthographic representations of the same cluster, both pronounced /tːsʌ/. (The soft sign in ⟨-ться⟩ is ignored: no palatalization occurs.) Either spelling features an elongated /tː/ followed by /s/; by contrast, the similar affricate /ts/ is quicker to pronounce.', citation: 'pp. 237–238', notable: true },
        
        // Entry 74 | ⟨чн⟩ → /ʃn/ exceptions
        'ʃn:cluster:чн': { blurb: 'In a subset of common words, the cluster ⟨чн⟩ is pronounced /ʃn/ rather than the expected /tʃʲn/. This subset includes ⟨конечно⟩ /kɑˈɲeʃnʌ/ "of course," ⟨скучно⟩ /ˈskuʃnʌ/ "boring," ⟨яичница⟩ /jɪˈiʃɲitsʌ/ "fried eggs," and a handful of others.', citation: 'pp. 240–241', notable: true },
        
        // Entry 75 | ⟨чт⟩ → /ʃt/ exceptions
        'ʃt:cluster:чт': { blurb: 'In a subset of common words, the cluster ⟨чт⟩ is pronounced /ʃt/ rather than the expected /tʃʲt/. This subset includes ⟨что⟩ /ʃto/ "what," ⟨чтобы⟩ /ˈʃtobɨ/ "in order to," ⟨ничто⟩ /ɲiˈʃto/ "nothing," and a handful of others.', citation: 'p. 241', notable: true },
        
        // Entry 76 | ⟨бог⟩ → /box/
        'x:exception:бог': { blurb: 'In the word ⟨бог⟩ /box/ "God," the final ⟨г⟩ is pronounced /x/ rather than the expected devoiced /k/. This pronunciation is preserved from Church Slavonic tradition.', citation: 'p. 242', notable: true },
        
        // Entry 77 | Genitive endings where ⟨г⟩ is /v/
        'v:genitive:г': { blurb: 'In the very common genitive singular endings ⟨-его⟩ and ⟨-ого⟩, the letter ⟨г⟩ is pronounced /v/, not /ɡ/. This applies to adjectives, pronouns, and ordinal numbers (e.g., ⟨его⟩ /jɪˈvo/ "his/him," ⟨сегодня⟩ /sʲɪˈvodɲʌ/ "today," ⟨красного⟩ /ˈkrɑsnʌvʌ/ "of the red"). Beware the common word ⟨много⟩ /ˈmnoɡʌ/ "much/many," where the identical-looking cluster is not a genitive ending, so it retains the voiced velar plosive /ɡ/ we would otherwise expect.', citation: 'p. 243', notable: true },
        
        // Entry 78 | ⟨сш⟩ → /ʃː/ assimilation
        'sːʃ:cluster:сш': { blurb: 'When ⟨с⟩ precedes ⟨ш⟩, the /s/ transforms to match the /ʃ/ that follows, lengthening it (e.g., ⟨сшить⟩ /ʃːɨtʲ/ "to sew together").', citation: 'p. 230', notable: false },
        
        // Entry 79 | ⟨зж⟩ → /ʒː/ assimilation
        'zːʒ:cluster:зж': { blurb: 'When ⟨з⟩ precedes ⟨ж⟩, the /z/ transforms to match the /ʒ/ that follows, lengthening it (e.g., ⟨изжога⟩ /ɪˈʒːoɡʌ/ "heartburn").', citation: 'p. 230', notable: false },
        
        // Entry 80 | ⟨сч⟩ → /ʃʲʃʲ/ assimilation
        'ʃʲʃʲ:cluster:сч': { blurb: 'When ⟨с⟩ precedes ⟨ч⟩, the cluster assimilates to /ʃʲʃʲ/ (or /ʃʲː/ if you prefer), identical to ⟨щ⟩ (e.g., ⟨счастье⟩ /ˈʃʲːɑsʲtʲjɪ/ "happiness" (note the exceptional /ɑ/ in this common word), ⟨считать⟩ /ʃʲːɪˈtɑtʲ/ "to count," and ⟨расчёт⟩ /rʌˈʃʲːot/ "calculation").', citation: 'p. 231', notable: false },
        
        // Entry 80b | ⟨зч⟩ → /ʃʲʃʲ/ assimilation
        'ʃʲʃʲ:cluster:зч': { blurb: 'When ⟨з⟩ precedes ⟨ч⟩, the cluster assimilates to /ʃʲʃʲ/, identical to ⟨щ⟩ (e.g., ⟨резчик⟩ /ˈrʲeʃʲʃʲɪk/ "carver," ⟨образчик⟩ /ɐˈbraʃʲʃʲɪk/ "sample"). The voiced ⟨з⟩ fully assimilates to match the following ⟨ч⟩.', citation: 'pp. 230–231', notable: false },
        
        // Entry 81 | Silent ⟨л⟩ in the ⟨лнц⟩ cluster
        'silent:cluster:лнц': { blurb: '⟨л⟩ is silent in the cluster ⟨лнц⟩; this is an exceptional rule of one.', citation: 'p. 235', notable: true },
        'nts:cluster:лнц': { blurb: '⟨л⟩ is silent in the cluster ⟨лнц⟩; this is an exceptional rule of one.', citation: 'p. 235', notable: true },
        
        // Entry 82 | Silent ⟨д⟩ in the ⟨рдц⟩ cluster
        'silent:cluster:рдц': { blurb: '⟨д⟩ is silent in the cluster ⟨рдц⟩; this is an exceptional rule of one.', citation: 'p. 235', notable: true },
        'rts:cluster:рдц': { blurb: '⟨д⟩ is silent in the cluster ⟨рдц⟩; this is an exceptional rule of one.', citation: 'p. 235', notable: true },
        
        // Entry 83 | Silent ⟨т⟩ in the ⟨стн⟩ cluster
        'silent:cluster:стн': { blurb: 'In the cluster ⟨стн⟩, the ⟨т⟩ is silent (e.g., ⟨честный⟩ /ˈtʃʲesnɨj/ "honest," ⟨известный⟩ /ɪzˈvʲesnɨj/ "famous," and ⟨грустный⟩ /ˈɡrusnɨj/ "sad").', citation: 'p. 235', notable: true },
        
        // Entry 84 | Silent ⟨д⟩ in the ⟨здн⟩ cluster
        'silent:cluster:здн': { blurb: 'In the cluster ⟨здн⟩, the ⟨д⟩ is silent (e.g., ⟨поздно⟩ /ˈpoznʌ/ "late," ⟨праздник⟩ /ˈprazɲɪk/ "holiday").', citation: 'p. 235', notable: true },
        
        // Entry 85 | Silent ⟨в⟩ in the ⟨вств⟩ cluster
        'silent:cluster:вств': { blurb: 'In the cluster ⟨вств⟩, the first ⟨в⟩ is silent (e.g., ⟨чувство⟩ /ˈtʃʲustvʌ/ "feeling," ⟨здравствуй⟩ /ˈzdrastvuj/ "hello").', citation: 'p. 236', notable: true },
        
        // ========================================
        // LEGACY ENTRIES (Phonological Processes)
        // Retained for backward compatibility with deriveRule()
        // ========================================
        'ɑ:stressed:я': { blurb: 'Stressed ⟨я⟩ following a soft consonant is pronounced /ɑ/. The preceding consonant carries the palatalization.', citation: 'pp. 81–85', notable: false },
        'ɛ:stressed:э': { blurb: 'Stressed ⟨э⟩ is pronounced /ɛ/, the open-mid front vowel.', citation: 'pp. 87–90', notable: false },
        'a:interpalatal:а': { blurb: '⟨а⟩ fronts to /a/ when sandwiched between two palatalizing agents.', citation: 'pp. 81–85, 125', notable: true },
        'a:interpalatal:я': { blurb: '⟨я⟩ fronts to /a/ when sandwiched between two palatalizing agents.', citation: 'pp. 81–85, 125', notable: true },
        'e:interpalatal:е': { blurb: '⟨е⟩ closes to /e/ when sandwiched between two palatalizing agents.', citation: 'pp. 87–90, 125', notable: true },
        'e:interpalatal:э': { blurb: 'When stressed ⟨э⟩ is word-initial before a palatalized consonant, it fronts from /ɛ/ to /e/ (e.g., ⟨эти⟩ → /ˈetʲi/, in contrast to ⟨это⟩ → /ˈɛtʌ/).', citation: 'pp. 87–90, 125', notable: false },
        'ʌ:post-stress:о': { blurb: 'Post-stress ⟨о⟩ reduces to /ʌ/.', citation: 'pp. 108, 127', notable: true },
        'ɪ:unstressed:е': { blurb: 'Unstressed ⟨е⟩ reduces to /ɪ/.', citation: 'pp. 97–107', notable: true },
        'ɪ:unstressed:я': { blurb: 'Unstressed ⟨я⟩ reduces to /ɪ/.', citation: 'pp. 97–107', notable: true },
        'ɨ:after-hard:и': { blurb: 'When ⟨и⟩ follows an intrinsically hard consonant (⟨ж⟩, ⟨ш⟩, or ⟨ц⟩), it is pronounced /ɨ/. The hard consonant retracts the cardinal-i to velar-i.', citation: 'pp. 93–96', notable: true },
        'ɨ:after-hard:е': { blurb: 'When unstressed ⟨е⟩ follows an intrinsically hard consonant (⟨ж⟩, ⟨ш⟩, or ⟨ц⟩), it is pronounced /ɨ/.', citation: 'pp. 97–107', notable: true },
        'devoicing:process': { blurb: 'In Russian, as in German, final consonants are generally devoiced regardless of spelling (e.g., ⟨год⟩ → /ɡot/, ⟨кровь⟩ → /krofʲ/). Exception: sonorants (/m/, /mʲ/, /n/, /ɲ/, /ɫ/, /lʲ/, /r/, /rʲ/) are never devoiced.', citation: 'p. 199', notable: false },
        
        // Final devoicing blurbs (v5.5.1)
        'k:final-devoicing:г': { blurb: 'Word-final ⟨г⟩ is devoiced to /k/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        'p:final-devoicing:б': { blurb: 'Word-final ⟨б⟩ is devoiced to /p/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        'f:final-devoicing:в': { blurb: 'Word-final ⟨в⟩ is devoiced to /f/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        'fʲ:final-devoicing:в': { blurb: 'Word-final soft ⟨в⟩ is devoiced to /fʲ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        't:final-devoicing:д': { blurb: 'Word-final ⟨д⟩ is devoiced to /t/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        'tʲ:final-devoicing:д': { blurb: 'Word-final soft ⟨д⟩ is devoiced to /tʲ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        's:final-devoicing:з': { blurb: 'Word-final ⟨з⟩ is devoiced to /s/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        'sʲ:final-devoicing:з': { blurb: 'Word-final soft ⟨з⟩ is devoiced to /sʲ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        'ʃ:final-devoicing:ж': { blurb: 'Word-final ⟨ж⟩ is devoiced to /ʃ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.', citation: 'p. 199', notable: false },
        
        // Regressive devoicing within words (v5.10.20)
        'f:regressive-devoicing:в': { blurb: '⟨в⟩ is devoiced to /f/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant (e.g., ⟨завтра⟩ → /ˈzɑftrʌ/).', citation: 'pp. 215–221', notable: false },
        'p:regressive-devoicing:б': { blurb: '⟨б⟩ is devoiced to /p/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        'k:regressive-devoicing:г': { blurb: '⟨г⟩ is devoiced to /k/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        't:regressive-devoicing:д': { blurb: '⟨д⟩ is devoiced to /t/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        's:regressive-devoicing:з': { blurb: '⟨з⟩ is devoiced to /s/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        'ʃ:regressive-devoicing:ж': { blurb: '⟨ж⟩ is devoiced to /ʃ/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        
        // Regressive voicing within words (v5.10.21) - voiceless becomes voiced
        'ɡ:regressive-voicing:к': { blurb: '⟨к⟩ is voiced to /ɡ/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant (e.g., ⟨вокзал⟩ → /vɑɡˈzɑɫ/).', citation: 'pp. 215–221', notable: false },
        'b:regressive-voicing:п': { blurb: '⟨п⟩ is voiced to /b/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        'd:regressive-voicing:т': { blurb: '⟨т⟩ is voiced to /d/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        'v:regressive-voicing:ф': { blurb: '⟨ф⟩ is voiced to /v/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        'z:regressive-voicing:с': { blurb: '⟨с⟩ is voiced to /z/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        'ʒ:regressive-voicing:ш': { blurb: '⟨ш⟩ is voiced to /ʒ/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.', citation: 'pp. 215–221', notable: false },
        
        'voicing:within-word': { blurb: 'Within words, voiced and voiceless consonants assimilate regressively: a voiceless consonant becomes voiced before a voiced consonant (e.g., ⟨вокзал⟩ → /vɑɡˈzɑɫ/), and a voiced consonant becomes voiceless before a voiceless consonant (e.g., ⟨водка⟩ → /ˈvotkʌ/). Exception: ⟨в⟩ does not trigger voicing in preceding consonants (e.g., ⟨свет⟩ → /svʲɛt/, not */zvʲɛt/).', citation: 'pp. 215–221', notable: false },
        'voicing:cross-word': { blurb: 'Voicing assimilation also operates across word boundaries within a single thought or phrase: a final consonant voices before an initial voiced consonant (e.g., ⟨ваш дом⟩ → /vaʒ dom/) or devoices before an initial voiceless consonant (e.g., ⟨год прошёл⟩ → /ɡot prɑˈʃoɫ/). As within words, ⟨в⟩ does not trigger voicing in preceding consonants. In <em>Ilya</em>, you can insert breaks in cross-word assimilation through the popups to mirror the composer\'s phrasing.', citation: 'pp. 248–254', notable: false },
        'ː:geminate': { blurb: 'Geminate (doubled) consonants are pronounced with extended duration. Grayson describes this as "speaking the single consonant twice without any break in between" — a rearticulation rather than simply holding the sound longer. Notation using either doubled symbols (/nn/) or the length mark (/nː/) is acceptable; <em>Ilya</em> uses the length mark (e.g., ⟨ванна⟩ → /ˈvɑnːʌ/) to lessen visual clutter. Notable exception: the very common word ⟨русский⟩ and all of its declensions are pronounced with a single /s/, not a geminate: /ˈruskɨj/.', citation: 'pp. 225–226, 233', notable: true },
        'tːsʌ:reflexive:тся': { blurb: 'The reflexive verb endings ⟨-тся⟩ and ⟨-ться⟩ are both pronounced /tːsʌ/. These clusters resemble the affricate ⟨ц⟩ (/ts/), but have an elongated stop on the /t/ portion (e.g., ⟨боится⟩ → /bɑˈitːsʌ/, ⟨купаться⟩ → /kuˈpɑtːsʌ/). The soft sign in ⟨-ться⟩ has no effect in this construct. Ignore it.', citation: 'pp. 237–238', notable: true },
        'deletion:cluster': { blurb: 'Certain consonant clusters contain "silent" letters that are not pronounced. Common examples: ⟨солнце⟩ → /ˈsontsɨ/ (⟨л⟩ silent), ⟨сердце⟩ → /ˈsʲertsɨ/ (⟨д⟩ silent), ⟨праздник⟩ → /ˈprazʲɲik/ (⟨д⟩ silent), ⟨чувство⟩ → /ˈtʃʲustvʌ/ (first ⟨в⟩ silent), ⟨здравствуйте⟩ → /ˈzdrastvujtʲe/ (first ⟨в⟩ silent).', citation: 'pp. 235–247', notable: true },
        'none:hard-sign:ъ': { blurb: 'The hard sign ⟨ъ⟩ has no sound of its own. It serves as a visual boundary marker: the consonant before it stays hard, and a /j/ glide is articulated before the following vowel (e.g., ⟨съел⟩ → /sjɛɫ/). ⟨Ъ⟩ once appeared at the end of every Russian Cyrillic word ending in a hard consonant; these final hard signs were eliminated by post-1917 spelling reforms (<em>Ilya</em> silently removes them), but hard signs within words still work as described.', citation: 'pp. 192–194', notable: false },
        'ʲ:soft-sign:ь': { blurb: 'The soft sign ⟨ь⟩ has no sound of its own, but it causes an obvious sound shift by palatalizing the preceding consonant. When followed by a vowel from the soft series (е, ё, ю, я), a /j/ glide is articulated between the palatalized consonant and the vowel (e.g., ⟨вьюга⟩ → /vʲˈjuɡʌ/). Note: the superscript [ʲ] (palatalization marker) and the baseline /j/ (palatal glide) are distinct symbols and not interchangeable.', citation: 'pp. 195–198', notable: false }
      },
      
      // Derive rule name from transcriptionLog features
      // Expected softTrigger values:
      // - Soft vowels: 'е', 'ё', 'ю', 'я', 'и'
      // - Soft sign: 'ь'
      // - Regressive palatalization: 'regressive'
      deriveRule(features, char) {
        if (features.type === 'vowel') {
          // Check for exception rules first
          if (features.exception) return features.exception;
          
          // Stressed vowels
          if (features.position === 'stressed') {
            return features.interpalatal ? 'interpalatal' : 'stressed';
          }
          
          // Unstressed vowels
          if (features.afterHard) return 'after-hard';
          if (features.position === 'pretonic') return 'pretonic';
          if (features.position === 'initial') return 'initial';
          if (features.position === 'remote') return 'remote';
          return 'unstressed';
        }
        
        if (features.type === 'consonant') {
          const lowerChar = char?.toLowerCase();
          
          // Final devoicing takes precedence (v5.5.1)
          if (features.finalDevoicing) {
            return 'final-devoicing';
          }
          
          // Always-soft consonants (ч, щ)
          if (['ч', 'щ'].includes(lowerChar)) {
            return 'always-soft';
          }
          // Always-hard consonants (ж, ш, ц)
          if (['ж', 'ш', 'ц'].includes(lowerChar)) {
            return 'always-hard';
          }
          // Glide й
          if (lowerChar === 'й') {
            return 'glide';
          }
          // Soft consonants → 'soft'
          if (features.soft) {
            return 'soft';
          }
          // Hard consonants → 'hard'
          return 'hard';
        }
        
        if (features.type === 'sign') {
          return features.signType === 'soft' ? 'soft-sign' : 'hard-sign';
        }
        
        if (features.type === 'cluster') {
          return 'cluster';
        }
        
        return 'unknown';
      },
      
      // Look up blurb data for a transcriptionLog entry
      lookupBlurb(entry) {
        const { features, char, ipa } = entry;
        
        // Check for regressive devoicing assimilation (v5.10.20)
        if (features?.voicingAssimilation && features?.devoiced) {
          const key = `${ipa}:regressive-devoicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for regressive voicing assimilation (v5.10.21)
        if (features?.voicingAssimilation && features?.voiced) {
          const key = `${ipa}:regressive-voicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for final devoicing
        if (features?.finalDevoicing) {
          const key = `${ipa}:final-devoicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for genitive ending г → /v/ (Grayson p. 243)
        if (features?.genitiveEnding) {
          const key = `${ipa}:genitive:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for бог exception г → /x/ (Grayson p. 242)
        if (features?.bogException) {
          const key = `x:exception:бог`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        const rule = this.deriveRule(features, char);
        const key = `${ipa}:${rule}:${char}`;
        
        return this.blurbs[key] || {
          blurb: `${char} → ${ipa}`,
          citation: null,
          notable: false
        };
      },
      
      // Build display log with blurb data (memoizable)
      // Expands cluster entries into per-character rows for educational clarity
      buildDisplayLog(transcriptionLog) {
        // Cluster breakdowns for educational display
        // Maps cluster string to array of per-character entries
        const CLUSTER_BREAKDOWNS = {
          // Silent consonant clusters (Grayson pp. 235-236)
          'рдц': [
            { char: 'р', ipa: 'r', features: { type: 'consonant', soft: false } },
            { char: 'д', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'ц', ipa: 'ts', features: { type: 'consonant', soft: false, alwaysHard: true } }
          ],
          'лнц': [
            { char: 'л', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'н', ipa: 'n', features: { type: 'consonant', soft: false } },
            { char: 'ц', ipa: 'ts', features: { type: 'consonant', soft: false, alwaysHard: true } }
          ],
          'вств': [
            { char: 'в', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'с', ipa: 's', features: { type: 'consonant', soft: false } },
            { char: 'т', ipa: 't', features: { type: 'consonant', soft: false } },
            { char: 'в', ipa: 'v', features: { type: 'consonant', soft: false } }
          ],
          // Geminate simplification (Grayson p. 233)
          'сс': [
            { char: 'с', ipa: 's', features: { type: 'consonant', soft: false } },
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, geminateSimplified: true } }
          ],
          // Assimilated clusters - TRUE MERGERS (Grayson pp. 230-231)
          // Both letters merge into ONE sound - use merged display
          'сч': {
            type: 'merged',
            mergedIpa: 'ʃʲʃʲ',
            members: [
              { char: 'с', features: { type: 'consonant', soft: true, clusterAssimilation: true } },
              { char: 'ч', features: { type: 'consonant', soft: true, alwaysSoft: true } }
            ]
          },
          'зч': {
            type: 'merged',
            mergedIpa: 'ʃʲʃʲ',
            members: [
              { char: 'з', features: { type: 'consonant', soft: true, clusterAssimilation: true } },
              { char: 'ч', features: { type: 'consonant', soft: true, alwaysSoft: true } }
            ]
          },
          // Sibilant mergers (Grayson pp. 235-236)
          'сш': [
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ш' } },
            { char: 'ш', ipa: 'ʃː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'зш': [
            { char: 'з', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ш', devoices: true } },
            { char: 'ш', ipa: 'ʃː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'сж': [
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ж', voices: true } },
            { char: 'ж', ipa: 'ʒː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'зж': [
            { char: 'з', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ж' } },
            { char: 'ж', ipa: 'ʒː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          // Word-specific чн → шн (Grayson p. 239)
          'чн': [
            { char: 'ч', ipa: 'ʃ', features: { type: 'consonant', soft: false, clusterAssimilation: true } },
            { char: 'н', ipa: 'n', features: { type: 'consonant', soft: false } }
          ],
          // Word-specific чт → шт (Grayson p. 240)
          'чт': [
            { char: 'ч', ipa: 'ʃ', features: { type: 'consonant', soft: false, clusterAssimilation: true } },
            { char: 'т', ipa: 't', features: { type: 'consonant', soft: false } }
          ]
        };
        
        const expandedLog = [];
        
        transcriptionLog.forEach(entry => {
          // Check if this is a cluster that should be expanded
          if (entry.features?.type === 'cluster' && CLUSTER_BREAKDOWNS[entry.char]) {
            const breakdown = CLUSTER_BREAKDOWNS[entry.char];
            
            // Check if this is a "merged" cluster (both letters → one sound)
            if (breakdown.type === 'merged') {
              // Get the shared blurb for this merged cluster
              const clusterBlurb = this.lookupBlurb({
                char: entry.char,
                ipa: breakdown.mergedIpa,
                features: { type: 'cluster' }
              });
              
              breakdown.members.forEach((charEntry, idx) => {
                const isFirst = idx === 0;
                const isLast = idx === breakdown.members.length - 1;
                
                expandedLog.push({
                  char: charEntry.char,
                  ipa: isFirst ? breakdown.mergedIpa : '', // Only first row shows IPA
                  features: charEntry.features,
                  syllableIndex: entry.syllableIndex,
                  position: entry.position + idx,
                  // Cluster grouping metadata
                  clusterSource: entry.char,
                  clusterMerged: true,
                  clusterStart: isFirst,
                  clusterEnd: isLast,
                  clusterContinuation: !isFirst,
                  // Blurb only on first row (will be shared visually)
                  blurbData: isFirst ? clusterBlurb : { blurb: '', citation: null, notable: false }
                });
              });
            } else {
              // Standard array format (silent letter clusters, etc.)
              breakdown.forEach((charEntry, idx) => {
                expandedLog.push({
                  char: charEntry.char,
                  ipa: charEntry.ipa,
                  features: charEntry.features,
                  syllableIndex: entry.syllableIndex,
                  position: entry.position + idx,
                  // Mark as part of cluster for potential styling
                  clusterSource: entry.char,
                  blurbData: this.lookupClusterCharBlurb(charEntry, entry.char)
                });
              });
            }
          } else {
            // Regular entry, add blurb data
            expandedLog.push({
              ...entry,
              blurbData: this.lookupBlurb(entry)
            });
          }
        });
        
        return expandedLog;
      },
      
      // Look up blurb for a character within an expanded cluster
      lookupClusterCharBlurb(charEntry, clusterSource) {
        const { char, ipa, features } = charEntry;
        
        // Silent letters get the deletion:cluster blurb
        if (features.silent && features.deletionCluster) {
          return {
            blurb: `In the cluster ⟨${clusterSource}⟩, the letter ⟨${char}⟩ is silent and not pronounced. This is one of several consonant clusters in Russian where a letter is written but has no phonetic realization.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        // Geminate simplified
        if (features.silent && features.geminateSimplified) {
          return {
            blurb: `In ⟨русский⟩ and its declensions, the doubled ⟨сс⟩ is pronounced as a single /s/, not as a geminate. This is an exception to the normal geminate rule.`,
            citation: 'p. 233',
            notable: true
          };
        }
        
        // Cluster assimilation (сч, зч → щ sound)
        if (features.clusterAssimilation && clusterSource === 'сч') {
          return {
            blurb: `The cluster ⟨сч⟩ is pronounced like ⟨щ⟩: a long soft hushing sound /ʃʲʃʲ/. The ⟨с⟩ fully assimilates to match the following ⟨ч⟩.`,
            citation: 'pp. 230–231',
            notable: true
          };
        }
        
        if (features.clusterAssimilation && clusterSource === 'зч') {
          return {
            blurb: `The cluster ⟨зч⟩ is pronounced like ⟨щ⟩: a long soft hushing sound /ʃʲʃʲ/. The ⟨з⟩ fully assimilates to match the following ⟨ч⟩.`,
            citation: 'pp. 230–231',
            notable: true
          };
        }
        
        // Sibilant mergers (Grayson pp. 235-236)
        if (features.sibilantMerger) {
          const mergeTarget = features.mergesInto;
          const voiceChange = features.voices ? ' (voicing)' : features.devoices ? ' (devoicing)' : '';
          return {
            blurb: `The ⟨${char}⟩ merges completely into the following ⟨${mergeTarget}⟩${voiceChange}, lengthening it to /ʒː/ or /ʃː/.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        if (features.receivesLength) {
          return {
            blurb: `This ⟨${char}⟩ receives length from the preceding sibilant, producing a geminate /ʒː/ or /ʃː/.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        // чн → шн assimilation
        if (features.clusterAssimilation && clusterSource === 'чн') {
          return {
            blurb: `In certain common words (⟨конечно⟩, ⟨скучно⟩, ⟨нарочно⟩, ⟨яичница⟩), the cluster ⟨чн⟩ is pronounced /ʃn/ rather than /tʃn/. This is a historical pronunciation retained in everyday speech.`,
            citation: 'p. 239',
            notable: true
          };
        }
        
        // чт → шт assimilation
        if (features.clusterAssimilation && clusterSource === 'чт') {
          return {
            blurb: `In ⟨что⟩, ⟨чтобы⟩, and ⟨ничто⟩, the cluster ⟨чт⟩ is pronounced /ʃt/ rather than /tʃt/. This is one of the most common pronunciation exceptions in Russian.`,
            citation: 'p. 240',
            notable: true
          };
        }
        
        // Default: look up regular blurb
        return this.lookupBlurb({ char, ipa, features });
      }
    };

    /* ========================================
       IPA TOKENIZER
       Parses IPA strings into draggable atomic units
       Affricates and palatalized consonants travel as single tokens
       ======================================== */
    const IpaTokenizer = {
      // Affricates that must travel as single units (longest first for matching)
      AFFRICATES: ['ʃtʃ', 'tʃ', 'ts', 'dʒ'],
      
      // IPA vowels (including variants)
      VOWELS: new Set([
        'a', 'ɑ', 'æ', 'e', 'ɛ', 'i', 'ɪ', 'o', 'ɔ', 'u', 'ʊ', 'ɨ', 'ə', 'ʌ'
      ]),
      
      // Modifiers that attach to preceding consonant
      MODIFIERS: new Set(['ʲ', 'ʷ', 'ˠ', 'ː']),
      
      // Check if character is a vowel
      isVowel(char) {
        return this.VOWELS.has(char);
      },
      
      /**
       * Tokenize an IPA string into atomic units
       * Each token: { symbol: string, isVowel: boolean, isGeminate: boolean }
       * 
       * Example: 'krɐsá' → ['k', 'r', 'ɐ', 's', 'á']
       * Example: 'vʲjotːsʌ' → ['vʲ', 'j', 'o', 'tː', 's', 'ʌ']
       * Example: 'tʃajtʃ' → ['tʃ', 'a', 'j', 'tʃ']
       */
      tokenize(ipa) {
        // Strip stress marks for tokenization (they stay with vowels)
        const clean = ipa.replace(/[ˈˌ]/g, '');
        const tokens = [];
        let i = 0;
        
        while (i < clean.length) {
          // Check for affricates first (longest match wins)
          let foundAffricate = false;
          for (const affricate of this.AFFRICATES) {
            if (clean.slice(i, i + affricate.length) === affricate) {
              let symbol = affricate;
              i += affricate.length;
              
              // Check for following modifiers (palatalization, length)
              while (i < clean.length && this.MODIFIERS.has(clean[i])) {
                symbol += clean[i];
                i++;
              }
              
              tokens.push({
                symbol,
                isVowel: false,
                isGeminate: symbol.includes('ː')
              });
              foundAffricate = true;
              break;
            }
          }
          if (foundAffricate) continue;
          
          // Check for vowels
          if (this.isVowel(clean[i])) {
            tokens.push({
              symbol: clean[i],
              isVowel: true,
              isGeminate: false
            });
            i++;
            continue;
          }
          
          // Consonant - collect following modifiers
          let symbol = clean[i];
          i++;
          
          while (i < clean.length && this.MODIFIERS.has(clean[i])) {
            symbol += clean[i];
            i++;
          }
          
          tokens.push({
            symbol,
            isVowel: false,
            isGeminate: symbol.includes('ː')
          });
        }
        
        return tokens;
      },
      
      /**
       * Parse tokens into onset/nucleus/coda structure
       * Returns: { onset: [...], nucleus: token, coda: [...] }
       */
      parseSegments(tokens) {
        const vowelIdx = tokens.findIndex(t => t.isVowel);
        
        if (vowelIdx === -1) {
          // No vowel (edge case - shouldn't happen in valid syllables)
          return { onset: tokens, nucleus: null, coda: [] };
        }
        
        return {
          onset: tokens.slice(0, vowelIdx),
          nucleus: tokens[vowelIdx],
          coda: tokens.slice(vowelIdx + 1)
        };
      },
      
      /**
       * Reconstruct IPA string from tokens
       */
      join(tokens) {
        return tokens.map(t => t.symbol).join('');
      }
    };

    /* ========================================
       BOUNDARY STACK
       Manages display-only syllable boundary offsets
       Source data is NEVER mutated - only cut points change
       ======================================== */
    const BoundaryStack = {
      // Storage: Map of wordId → array of boundary offsets
      // Positive offset = stole consonant from right
      // Negative offset = gave consonant to right
      _offsets: new Map(),
      
      /**
       * Get boundary offsets for a word (creates default if none)
       */
      getOffsets(wordId, syllableCount) {
        if (!this._offsets.has(wordId)) {
          // Default: all offsets are 0 (no adjustment)
          this._offsets.set(wordId, new Array(syllableCount).fill(0));
        }
        return this._offsets.get(wordId);
      },
      
      /**
       * Shift a boundary (move consonant between syllables)
       * direction: 'left' (steal from right) or 'right' (give to right)
       * boundaryIdx: which boundary (0 = between syl0 and syl1)
       */
      shiftBoundary(wordId, boundaryIdx, direction, syllableCount) {
        const offsets = this.getOffsets(wordId, syllableCount);
        
        if (direction === 'left') {
          offsets[boundaryIdx]++;  // Steal one consonant from right syllable
        } else {
          offsets[boundaryIdx]--;  // Give one consonant to right syllable
        }
        
        return offsets;
      },
      
      /**
       * Reset all boundaries for a word to default
       */
      reset(wordId) {
        this._offsets.delete(wordId);
      },
      
      /**
       * Check if word has any custom boundaries
       */
      hasCustomBoundaries(wordId) {
        const offsets = this._offsets.get(wordId);
        return offsets && offsets.some(o => o !== 0);
      },
      
      /**
       * Clear all stored offsets (session reset)
       */
      clearAll() {
        this._offsets.clear();
      },
      
      /**
       * Apply boundary offsets to render display syllables
       * Takes the original syllable data and returns adjusted display syllables
       * 
       * CRITICAL: This NEVER mutates source data
       * It only computes where to visually cut the token stream
       */
      applyOffsets(wordId, originalSyllables) {
        const syllableCount = originalSyllables.length;
        const offsets = this.getOffsets(wordId, syllableCount);
        
        // If no custom boundaries, return original
        if (!offsets.some(o => o !== 0)) {
          return originalSyllables;
        }
        
        // Flatten all syllables into one token stream (preserving order)
        const allTokens = [];
        const originalBoundaries = [0]; // Indices where each syllable starts
        
        originalSyllables.forEach((syl, idx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          if (idx > 0) {
            originalBoundaries.push(allTokens.length);
          }
          allTokens.push(...tokens);
        });
        originalBoundaries.push(allTokens.length); // End marker
        
        // Calculate adjusted boundaries
        const adjustedBoundaries = originalBoundaries.map((boundary, idx) => {
          if (idx === 0 || idx === originalBoundaries.length - 1) {
            return boundary; // First and last boundaries don't move
          }
          return boundary + offsets[idx - 1];
        });
        
        // Clamp boundaries to valid range
        for (let i = 1; i < adjustedBoundaries.length - 1; i++) {
          adjustedBoundaries[i] = Math.max(
            adjustedBoundaries[i - 1] + 1, // Must have at least 1 token
            Math.min(adjustedBoundaries[i], adjustedBoundaries[i + 1] - 1)
          );
        }
        
        // Build display syllables from adjusted boundaries
        const displaySyllables = [];
        for (let i = 0; i < syllableCount; i++) {
          const start = adjustedBoundaries[i];
          const end = adjustedBoundaries[i + 1];
          const tokens = allTokens.slice(start, end);
          
          displaySyllables.push({
            ...originalSyllables[i],
            ipa: IpaTokenizer.join(tokens),
            displayTokens: tokens,
            isModified: start !== originalBoundaries[i] || end !== originalBoundaries[i + 1]
          });
        }
        
        return displaySyllables;
      }
    };

    /* ========================================
       ======================================== */
    const DocumentState = {
      lines: [],
      userName: 'anonymous',  // Default until wizard/dashboard sets it
      metadata: {
        composer: '',
        composerDates: '',
        title: '',
        opus: '',
        poet: '',
        poetDates: ''
      },
      
      updateStress(lineIndex, wordIndex, newStress) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].stress = newStress;
          // Clear stressSource when stress changes (user must re-attribute)
          this.lines[lineIndex][wordIndex].stressSource = null;
        }
      },
      
      updateStressSource(lineIndex, wordIndex, source) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].stressSource = source;
        }
      },
      
      updateGloss(lineIndex, wordIndex, newGloss) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].gloss = newGloss;
        }
      }
    };


    /* ========================================
       POPUP CONTROLLER
       ======================================== */
    const Popup = {
      isOpen: false,
      currentWord: null,
      stressWasChanged: false,
      attributionSelected: false,
      elements: {},
      lastWordId: null,          // Track which word was last opened (v5.4.0)
      
      // Staging state for confirmation flow (v5.4.0)
      // Tracks pending changes that require explicit "Apply" to commit
      staged: {
        stressSource: null,  // 'composer' | 'user' | null
        boundary: null       // 'soft' | 'hard' | null
      },
      stagedAt: null,        // Timestamp for 5-minute auto-discard
      
      // Helper: check if any staged changes exist
      hasStaged() {
        return this.staged.stressSource !== null || this.staged.boundary !== null;
      },
      
      // Helper: clear all staged changes
      clearStaged() {
        this.staged.stressSource = null;
        this.staged.boundary = null;
        this.stagedAt = null;
      },
      
      // Helper: check if staged changes have expired (5 minutes)
      isStagedExpired() {
        if (!this.stagedAt) return false;
        const FIVE_MINUTES = 5 * 60 * 1000;
        return (Date.now() - this.stagedAt) > FIVE_MINUTES;
      },
      
      init() {
        this.elements = {
          overlay: document.getElementById('popupOverlay'),
          backdrop: document.getElementById('popupBackdrop'),
          card: document.getElementById('popupCard'),
          syllableLabel: document.getElementById('syllableLabel'),
          syllableDisplay: document.getElementById('syllableDisplay'),
          syllableDisplayHeader: document.getElementById('syllableDisplayHeader'),
          cyrillic: document.getElementById('popupCyrillic'),
          glossInline: document.getElementById('glossInline'),
          // REMOVED IN v5.5 REDESIGN: whyToggle, whyPanel, citationRule, citationRef
          // Refine Analysis disclosure (v5.5) - HIDDEN IN v5.11
          refineToggle: document.getElementById('refineAnalysisToggle'),
          refinePanel: document.getElementById('refinePanel'),
          cliticBadge: document.getElementById('cliticBadge'),
          cliticType: document.getElementById('cliticType'),
          whyCliticBanner: document.getElementById('whyCliticBanner'),
          // Compact modules (v5.4.2) - MOVING TO FLAT FOOTER IN v5.11
          stressSourceModule: document.getElementById('stressSourceModule'),
          stressStagedIndicator: document.getElementById('stressStagedIndicator'),
          stressSourceDictionary: document.getElementById('stressSourceDictionary'),
          stressSourceComposer: document.getElementById('stressSourceComposer'),
          stressSourceUser: document.getElementById('stressSourceUser'),
          phraseBoundaryModule: document.getElementById('phraseBoundaryModule'),
          boundaryStagedIndicator: document.getElementById('boundaryStagedIndicator'),
          boundaryLinked: document.getElementById('boundaryLinked'),
          boundarySeparated: document.getElementById('boundarySeparated'),
          // ё toggle module (v5.8) - OLD LOCATION
          yoToggleModule: document.getElementById('yoToggleModule'),
          yoCurrentForm: document.getElementById('yoCurrentForm'),
          yoToggleBtn: document.getElementById('yoToggleBtn'),
          yoToggleLabel: document.getElementById('yoToggleLabel'),
          yoWarning: document.getElementById('yoWarning'),
          // NEW: Footer controls (v5.11)
          variantRow: document.getElementById('variantRow'),
          variantYo: document.getElementById('variantYo'),
          variantYe: document.getElementById('variantYe'),
          assimilationRow: document.getElementById('assimilationRow'),
          nextWordLabel: document.getElementById('nextWordLabel'),
          assimilationLinked: document.getElementById('assimilationLinked'),
          assimilationSeparated: document.getElementById('assimilationSeparated'),
          yoToast: document.getElementById('yoToast'),
          yoUndoBtn: document.getElementById('yoUndoBtn'),
          // Shared commit footer (v5.4.2)
          sharedCommitFooter: document.getElementById('sharedCommitFooter'),
          sharedApplyBtn: document.getElementById('sharedApplyBtn'),
          sharedRevertBtn: document.getElementById('sharedRevertBtn'),
          // Phoneme Ribbon (v5.5 vertical layout)
          ribbonVertical: document.getElementById('ribbonVertical'),
          ribbonGrid: document.getElementById('ribbonVertical') // Alias for backward compatibility
        };
        
        this.elements.backdrop.addEventListener('click', () => this.close());
        
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.isOpen) {
            this.close();
          }
        });
        
        // REMOVED IN v5.5 REDESIGN: whyToggle click handler
        // Refine Analysis disclosure toggle (v5.5)
        this.elements.refineToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          this.elements.refineToggle.classList.toggle('expanded');
          this.elements.refinePanel.classList.toggle('expanded');
        });
        
        this.elements.glossInline.addEventListener('blur', () => {
          if (this.currentWord) {
            const newGloss = this.elements.glossInline.textContent.trim();
            DocumentState.updateGloss(this.currentWord.lineIndex, this.currentWord.wordIndex, newGloss);
            DrawerController.renderToPaper();
          }
        });
        
        this.elements.card.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        // Syllable button interaction: unified pointer handling (v5.11.27)
        // Distance-on-release: <10px = stress, 10-40px = cancel, >40px = drag
        // No separate click handler - all logic in pointerup
        if (this.elements.syllableDisplay) {
          // Drag handling for consonant boundary editing (v5.10.15, refactored v5.11.27)
          this._setupDragHandlers();
        }
        
        // Stress source segment handlers (v5.4.2)
        [this.elements.stressSourceDictionary, this.elements.stressSourceComposer, this.elements.stressSourceUser].forEach(btn => {
          if (btn) {
            btn.addEventListener('click', () => {
              this.stageStressSource(btn.dataset.source);
            });
          }
        });
        
        // Phrase boundary segment handlers (v5.4.2)
        [this.elements.boundaryLinked, this.elements.boundarySeparated].forEach(btn => {
          if (btn) {
            btn.addEventListener('click', () => {
              this.stageBoundary(btn.dataset.boundary);
            });
          }
        });
        
        // ё toggle button handler (v5.8) - OLD LOCATION
        if (this.elements.yoToggleBtn) {
          this.elements.yoToggleBtn.addEventListener('click', () => {
            this.handleYoToggle();
          });
        }
        
        // NEW: Variant row handlers (v5.11)
        if (this.elements.variantYo) {
          this.elements.variantYo.addEventListener('click', () => {
            this.handleVariantToggle('yo');
          });
        }
        if (this.elements.variantYe) {
          this.elements.variantYe.addEventListener('click', () => {
            this.handleVariantToggle('ye');
          });
        }
        
        // NEW: Assimilation row handlers (v5.11)
        if (this.elements.assimilationLinked) {
          this.elements.assimilationLinked.addEventListener('click', () => {
            this.handleAssimilationToggle('soft');
          });
        }
        if (this.elements.assimilationSeparated) {
          this.elements.assimilationSeparated.addEventListener('click', () => {
            this.handleAssimilationToggle('hard');
          });
        }
        
        // NEW: Toast undo handler (v5.11)
        if (this.elements.yoUndoBtn) {
          this.elements.yoUndoBtn.addEventListener('click', () => {
            this.undoYoToggle();
          });
        }
        
        // Shared commit footer handlers (v5.4.2)
        this.elements.sharedApplyBtn.addEventListener('click', () => {
          this.commitAllStaged();
        });
        
        this.elements.sharedRevertBtn.addEventListener('click', () => {
          this.revertAllStaged();
        });
      },
      
      // ========================================
      // STAGING PATTERN METHODS (v5.4.2)
      // Compact Modules with Shared Commit Bar
      // ========================================
      
      // Stage a stress source selection (visual only, no commit)
      stageStressSource(source) {
        if (!this.currentWord) return;
        
        // Get current committed value for comparison
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        const currentCommitted = word?.stressSource || 'dictionary';
        
        // If clicking the already-committed value, do nothing
        if (source === currentCommitted && !this.staged.stressSource) {
          return;
        }
        
        // If clicking the same staged value, treat as toggle off
        if (source === this.staged.stressSource) {
          this.staged.stressSource = null;
          this.updateAllUI();
          return;
        }
        
        // Stage the new selection
        this.staged.stressSource = source;
        this.stagedAt = Date.now();
        
        // Update visual state
        this.updateAllUI();
      },
      
      // Stage a boundary selection (visual only, no commit)
      stageBoundary(boundary) {
        if (!this.currentWord) return;
        
        // Get current committed value for comparison
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        const currentCommitted = word?.rightBoundary || 'soft';
        
        // If clicking the already-committed value, do nothing
        if (boundary === currentCommitted && !this.staged.boundary) {
          return;
        }
        
        // If clicking the same staged value, treat as toggle off
        if (boundary === this.staged.boundary) {
          this.staged.boundary = null;
          this.updateAllUI();
          return;
        }
        
        // Stage the new selection
        this.staged.boundary = boundary;
        this.stagedAt = Date.now();
        
        // Update visual state
        this.updateAllUI();
      },
      
      // Handle ё toggle (v5.8.1)
      // Switches between е and ё forms with crossfade animation
      handleYoToggle() {
        if (!this.currentWord) return;
        
        const lineIdx = this.currentWord.lineIndex;
        const wordIdx = this.currentWord.wordIndex;
        const word = DocumentState.lines[lineIdx]?.[wordIdx];
        if (!word) return;
        
        const currentCyrillic = word.cyrillic;
        const hasYo = currentCyrillic.includes('ё') || currentCyrillic.includes('Ё');
        const originalInput = word.originalInput;
        const dictionaryForm = word.dictionaryForm;
        
        let newCyrillic;
        let newYoSource;
        
        if (hasYo) {
          // Currently has ё — remove it (revert to original or convert ё→е)
          if (originalInput) {
            newCyrillic = originalInput;
          } else {
            newCyrillic = currentCyrillic.replace(/ё/, 'е').replace(/Ё/, 'Е');
          }
          newYoSource = 'user-yo-edit';
        } else if (dictionaryForm) {
          // Has е, dictionary form available — restore ё
          newCyrillic = dictionaryForm;
          newYoSource = 'yo-restored';
        } else {
          // Has е, no dictionary — add ё to first е
          newCyrillic = currentCyrillic.replace(/е/, 'ё').replace(/Е/, 'Ё');
          newYoSource = 'user-yo-edit';
        }
        
        // Update DocumentState
        word.cyrillic = newCyrillic;
        word.yoSource = newYoSource;
        
        // Check if new form has ё (for stress locking)
        const newHasYo = newCyrillic.includes('ё') || newCyrillic.includes('Ё');
        word.hasYo = newHasYo;
        
        // Re-run stress assignment
        if (newHasYo) {
          const yoSyllable = GraysonEngine.findYoSyllable(newCyrillic);
          if (yoSyllable !== -1) {
            word.stress = yoSyllable;
            word.stressSource = newYoSource;
          }
        } else {
          const lookup = GraysonEngine.lookupStress(newCyrillic);
          if (lookup) {
            word.stress = lookup.stress;
            word.stressSource = lookup.source;
          } else {
            word.stress = 0;
            word.stressSource = 'default';
          }
        }
        
        // Crossfade: fade out popup content
        const popupBody = this.elements.card.querySelector('.popup-body');
        popupBody?.classList.add('fading');
        
        // After brief fade, re-render and refresh popup in place
        setTimeout(() => {
          // Re-render the paper
          DrawerController.renderToPaper();
          
          // Find the new word stack element and update currentWord reference
          const wordStacks = document.querySelectorAll('.word-stack');
          let newElement = null;
          wordStacks.forEach(stack => {
            if (stack.dataset.lineIndex === String(lineIdx) && 
                stack.dataset.wordIndex === String(wordIdx)) {
              newElement = stack;
            }
          });
          
          if (newElement) {
            // Build fresh wordData from the new element
            const freshWordData = {
              element: newElement,
              lineIndex: lineIdx,
              wordIndex: wordIdx,
              cyrillic: newElement.dataset.cyrillic,
              ipa: newElement.dataset.ipa,
              gloss: newElement.dataset.gloss,
              syllables: JSON.parse(newElement.dataset.syllables || '[]'),
              isProclitic: newElement.dataset.isProclitic,
              isEnclitic: newElement.dataset.isEnclitic,
              hasYo: newElement.dataset.hasYo,
              stressSource: newElement.dataset.stressSource,
              rightBoundary: newElement.dataset.rightBoundary,
              boundarySource: newElement.dataset.boundarySource,
              originalInput: newElement.dataset.originalInput,
              dictionaryForm: newElement.dataset.dictionaryForm,
              yoSource: newElement.dataset.yoSource
            };
            
            // Update currentWord reference
            this.currentWord = freshWordData;
            
            // Refresh popup content in place
            this.refreshPopupContent(freshWordData);
          }
          
          // Fade back in
          popupBody?.classList.remove('fading');
          
          // Return focus to toggle button
          this.elements.yoToggleBtn?.focus();
        }, 80); // Match fade-out duration
      },
      
      // Refresh popup content without closing (v5.8.1)
      refreshPopupContent(wordData) {
        // Update IPA and Cyrillic displays
        const syllabifiedCyrillic = wordData.syllables.map(s => 
          s.isStressed ? addAcuteToSyllable(s.cyrillic) : s.cyrillic
        ).join(' ');
        const syllabifiedIPA = wordData.syllables.map((s, idx) => {
          const stressedIdx = wordData.syllables.findIndex(syl => syl.isStressed);
          return idx === stressedIdx ? 'ˈ' + s.ipa : s.ipa;
        }).join(' ');
        
        this.elements.cyrillic.textContent = syllabifiedCyrillic;
        
        // Update syllable buttons (now the primary IPA display)
        // Apply any existing boundary customizations (v5.10.23)
        const wordId = `${wordData.lineIndex}-${wordData.wordIndex}`;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, wordData.syllables);
        
        const hasYo = wordData.hasYo === 'true' || wordData.hasYo === true;
        const syllableCount = displaySyllables.length;
        const buttonsDisabled = hasYo && syllableCount > 1;
        
        this.elements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" data-syllable-index="${idx}" ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}</button>`
        ).join('');
        
        // Show customized state and register reset handler if boundaries were adjusted (v5.10.23)
        this._updateCustomizedState();
        
        // Update stress source module visibility (locked when monosyllable or ё)
        const stressLocked = syllableCount === 1 || hasYo;
        this.elements.stressSourceModule.style.display = stressLocked ? 'none' : 'block';
        
        // Refresh ё toggle module
        this.populateYoToggle(wordData);
        
        // Refresh Phoneme Ribbon
        this.renderRibbon(wordData);
      },
      
      // Commit ALL staged changes (shared footer)
      commitAllStaged() {
        if (!this.currentWord) return;
        
        // Commit stress source if staged
        if (this.staged.stressSource) {
          DocumentState.updateStressSource(
            this.currentWord.lineIndex,
            this.currentWord.wordIndex,
            this.staged.stressSource
          );
          this.attributionSelected = true;
        }
        
        // Commit boundary if staged
        if (this.staged.boundary) {
          const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
          if (word && word.boundarySource !== 'punctuation') {
            word.rightBoundary = this.staged.boundary;
            word.boundarySource = 'user';
            this.currentWord.rightBoundary = this.staged.boundary;
            this.currentWord.boundarySource = 'user';
          }
        }
        
        // Clear staged state
        this.clearStaged();
        
        // Re-render to apply changes
        DrawerController.renderToPaper();
        
        // Update visual state
        this.updateAllUI();
      },
      
      // Revert ALL staged changes (shared footer)
      revertAllStaged() {
        this.clearStaged();
        this.updateAllUI();
      },
      
      // Update all UI elements based on current state
      updateAllUI() {
        this.updateStressSourceUI();
        this.updateBoundaryUI();
        this.updateSharedFooterUI();
      },
      
      // Update stress source segment visual states
      updateStressSourceUI() {
        const word = DocumentState.lines[this.currentWord?.lineIndex]?.[this.currentWord?.wordIndex];
        const committedSource = word?.stressSource || 'dictionary';
        const stagedSource = this.staged.stressSource;
        
        // Update segment classes
        const segments = [
          this.elements.stressSourceDictionary,
          this.elements.stressSourceComposer,
          this.elements.stressSourceUser
        ];
        
        segments.forEach(btn => {
          if (!btn) return;
          const btnSource = btn.dataset.source;
          
          // Remove all state classes
          btn.classList.remove('active', 'staged', 'committed');
          
          if (btnSource === stagedSource) {
            // This option is staged (pending)
            btn.classList.add('staged');
          } else if (btnSource === committedSource) {
            // This option is committed (saved)
            btn.classList.add(committedSource === 'dictionary' ? 'active' : 'committed');
          }
        });
        
        // Show/hide pencil indicator
        if (this.elements.stressStagedIndicator) {
          this.elements.stressStagedIndicator.classList.toggle('visible', stagedSource !== null);
        }
      },
      
      // Update boundary segment visual states
      updateBoundaryUI() {
        const word = DocumentState.lines[this.currentWord?.lineIndex]?.[this.currentWord?.wordIndex];
        const committedBoundary = word?.rightBoundary || 'soft';
        const stagedBoundary = this.staged.boundary;
        
        const segments = [
          this.elements.boundaryLinked,
          this.elements.boundarySeparated
        ];
        
        segments.forEach(btn => {
          if (!btn) return;
          const btnBoundary = btn.dataset.boundary;
          
          // Remove all state classes
          btn.classList.remove('active', 'staged', 'committed');
          
          if (btnBoundary === stagedBoundary) {
            btn.classList.add('staged');
          } else if (btnBoundary === committedBoundary) {
            btn.classList.add('active');
          }
        });
        
        // Show/hide pencil indicator
        if (this.elements.boundaryStagedIndicator) {
          this.elements.boundaryStagedIndicator.classList.toggle('visible', stagedBoundary !== null);
        }
      },
      
      // Update shared commit footer visibility
      updateSharedFooterUI() {
        const hasChanges = this.hasStaged();
        if (this.elements.sharedCommitFooter) {
          this.elements.sharedCommitFooter.classList.toggle('has-changes', hasChanges);
        }
      },
      
      selectAttribution(source) {
        // Legacy method - redirect to new staging approach
        this.stageStressSource(source);
      },
      
      clearAttributionSelection() {
        // Legacy method - clear staged
        this.staged.stressSource = null;
        this.updateAllUI();
      },
      
      generateCitation(wordData) {
        const ipa = wordData.ipa || '';
        const cyrillic = (wordData.cyrillic || '').toLowerCase();
        const syllables = wordData.syllables || [];
        const isProclitic = wordData.isProclitic === 'true';
        const isEnclitic = wordData.isEnclitic === 'true';
        const isO_Interjection = wordData.isO_Interjection === 'true' || wordData.isO_Interjection === true;
        const hasYo = wordData.hasYo === 'true' || wordData.hasYo === true || cyrillic.includes('ё');
        const syllableCount = syllables.length;
        
        // Check for ё first (always stressed)
        if (hasYo && syllableCount > 1) {
            return {
                rule: 'The letter ё always indicates stress. Stress position is fixed.',
                ref: 'Grayson §2.3'
            };
        }
        
        // Check for О interjection (punctuation signals exclamation, not preposition)
        if (isO_Interjection) {
            return {
                rule: '"О" here is an interjection (Oh!), not a preposition. Unlike proclitics, interjections are standalone exclamations that keep their full stress → /o/.',
                ref: 'Context'
            };
        }

        // Check for monosyllables
        if (syllableCount === 1) {
            if (isProclitic) {
                const procliticPosition = wordData.procliticPosition;
                // Check if this is sentence-initial О in a question (interrogative preposition)
                const isFirstWord = wordData.isFirstWord === 'true' || wordData.isFirstWord === true;
                const lineEndsWithQuestion = wordData.lineEndsWithQuestion === 'true' || wordData.lineEndsWithQuestion === true;
                const isInterrogativeO = cyrillic === 'о' && isFirstWord && lineEndsWithQuestion;
                
                // Special explanation for о as preposition
                if (cyrillic === 'о') {
                    if (isInterrogativeO) {
                        // Interrogative preposition: "О чём ты думаешь?"
                        if (procliticPosition === 'pretonic') {
                            return {
                                rule: '"О" here is an interrogative preposition (about what?), not an interjection. As a proclitic, it loses its stress and attaches to the following word. Host stress on first syllable → /ɑ/.',
                                ref: 'Grayson §7.1'
                            };
                        } else {
                            return {
                                rule: '"О" here is an interrogative preposition (about what?), not an interjection. As a proclitic, it loses its stress and attaches to the following word. Remote from host stress → /ʌ/.',
                                ref: 'Grayson §7.1'
                            };
                        }
                    }
                    // Regular preposition: "думаю о маме"
                    if (procliticPosition === 'pretonic') {
                        return {
                            rule: '"О" is a preposition (about). As a proclitic, it loses its stress and attaches phonologically to the following word. Host stress on first syllable → immediate pretonic /ɑ/.',
                            ref: 'Grayson §7.1'
                        };
                    } else {
                        return {
                            rule: '"О" is a preposition (about). As a proclitic, it loses its stress and attaches phonologically to the following word. Remote from host stress → maximum reduction /ʌ/.',
                            ref: 'Grayson §7.1'
                        };
                    }
                }
                // General proclitic explanation
                if (procliticPosition === 'pretonic') {
                    return {
                        rule: 'Proclitic: a function word that loses its stress and attaches phonologically to the following word. Host stress on first syllable → immediate pretonic reduction.',
                        ref: 'Grayson §7.1'
                    };
                }
                return {
                    rule: 'Proclitic: a function word that loses its stress and attaches phonologically to the following word. Remote from host stress → maximum reduction.',
                    ref: 'Grayson §7.1'
                };
            }
            if (isEnclitic) {
                return {
                    rule: 'Enclitic: a function word that loses its stress and attaches phonologically to the preceding word. Unstressed vowel reduces.',
                    ref: 'Grayson §7.1'
                };
            }
            // Check for ё monosyllable
            if (hasYo) {
                return {
                    rule: 'The letter ё always indicates stress.',
                    ref: 'Grayson §2.3'
                };
            }
            // Check if it has stress marked
            const hasStress = syllables.some(s => s.isStressed);
            if (hasStress) {
                return {
                    rule: 'Stressed monosyllable — vowel receives full phonetic value.',
                    ref: 'Grayson §3.1'
                };
            }
            return {
                rule: 'Monosyllable — stress context determines vowel quality.',
                ref: 'Grayson §7.1'
            };
        }
        
        // Multi-syllable words: analyze the IPA for reduction patterns
        // Priority order: most specific/interesting rule first
        
        // Check for ɑ from о-reduction (akanye)
        if (ipa.includes('ɑ') && cyrillic.includes('о')) {
            return {
                rule: 'Unstressed /о/ reduces to [ɑ] in immediate pretonic position',
                ref: 'Grayson §3.2'
            };
        }
        
        // Check for ʌ (remote reduction)
        if (ipa.includes('ʌ')) {
            return {
                rule: 'Unstressed vowel reduces to [ʌ] in remote positions',
                ref: 'Grayson §3.3'
            };
        }
        
        // Check for ɪ from е/я reduction (ikanye)
        if (ipa.includes('ɪ') && (cyrillic.includes('е') || cyrillic.includes('я'))) {
            return {
                rule: 'Unstressed /е/ or /я/ reduces to [ɪ]',
                ref: 'Grayson §3.2'
            };
        }
        
        // Check for palatalization
        if (ipa.includes('ʲ')) {
            return {
                rule: 'Consonant palatalized before soft sign or front vowel',
                ref: 'Grayson §4.2'
            };
        }
        
        // Check for й (j-glide)
        if (ipa.includes('j') && (cyrillic.includes('е') || cyrillic.includes('ё') || cyrillic.includes('ю') || cyrillic.includes('я'))) {
            return {
                rule: 'Iotated vowel produces [j] glide',
                ref: 'Grayson §3.6'
            };
        }
        
        // Default: stressed vowel rule
        return {
            rule: 'Stressed vowel receives full phonetic value',
            ref: 'Grayson §3.1'
        };
    },
    
      // Render Phoneme Ribbon - Vertical Layout (v5.5)
      // Content First redesign: educational ribbon always visible
      renderRibbon(wordData) {
        const container = this.elements.ribbonVertical;
        if (!container) return;
        
        const log = wordData.transcriptionLog || [];
        if (log.length === 0) {
          container.innerHTML = '<div style="color: var(--ink-tertiary); font-size: 0.85rem; padding: 1rem; text-align: center;">No transcription data available</div>';
          return;
        }
        
        // Build displayLog with blurb data (memoized per Kimi's optimization)
        const displayLog = RuleRegistry.buildDisplayLog(log);
        
        // Get boundary-adjusted syllables (v5.10.25)
        const wordId = `${wordData.lineIndex}-${wordData.wordIndex}`;
        const originalSyllables = wordData.syllables;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, originalSyllables);
        const hasCustomBoundaries = BoundaryStack.hasCustomBoundaries(wordId);
        
        // Recalculate syllable assignments if boundaries were adjusted
        let adjustedDisplayLog = displayLog;
        if (hasCustomBoundaries) {
          adjustedDisplayLog = this._recalculateSyllableIndices(displayLog, originalSyllables, displaySyllables);
        }
        
        // Group by (adjusted) syllable
        const syllableGroups = new Map();
        adjustedDisplayLog.forEach(entry => {
          const sylIdx = entry.adjustedSyllableIndex ?? entry.syllableIndex ?? 0;
          if (!syllableGroups.has(sylIdx)) {
            syllableGroups.set(sylIdx, []);
          }
          syllableGroups.get(sylIdx).push(entry);
        });
        
        // Get stressed syllable index
        const syllables = wordData.syllables;
        const stressedIdx = syllables.findIndex(s => s.isStressed);
        
        // Build vertical ribbon HTML
        let html = '';
        let isFirstSyllable = true;
        
        // FEATURED ENTRY: Tie bar (‿) for clitics - pinned to top per Kimi's guidance
        // Scholarly note explains phonological word boundaries
        const isClitic = wordData.isProclitic === 'true' || wordData.isProclitic === true ||
                         wordData.isEnclitic === 'true' || wordData.isEnclitic === true;
        
        if (isClitic) {
          const tieBarBlurb = `<strong>Clitics and Phonological Word Boundaries</strong><br><br>` +
            `Proclitics (e.g., "в," "на") and enclitics (e.g., "ли," "же") attach phonologically to their host words, ` +
            `collapsing the orthographic word boundary for purposes of assimilation. The resulting unit functions as a ` +
            `single phonological word: voicing assimilation and regressive palatalization proceed across the juncture ` +
            `as they would within a word.<br><br>` +
            `<strong>Exception:</strong> /л/ resists regressive palatalization unless the letters are orthographically ` +
            `doubled (e.g., -лль-). Since clitic attachment preserves orthographic separation ("л л" not "лль"), ` +
            `the sequence /ɫ‿lʲ/ remains unassimilated even when phonologically bound.<br><br>` +
            `The tie bar (‿) signals this phonological unity while respecting orthographic independence.`;
          const tieBarCitation = `Grayson (2012), pp. 209, 248–255; Avanesov (1972); Jones & Ward (1969); A. Kochetov, personal communication.`;
          
          html += `
            <div class="phoneme-row featured-entry" 
                 tabindex="0"
                 role="button"
                 aria-expanded="false"
                 aria-label="Tie bar indicates phonological binding">
              <div class="phoneme-mapping">
                <span class="phoneme-cyr">—</span>
                <span class="phoneme-arrow">›</span>
                <span class="phoneme-ipa">‿</span>
              </div>
              <div class="phoneme-blurb-overlay">
                <div class="blurb-text">${tieBarBlurb}</div>
                <div class="blurb-citation">${tieBarCitation}</div>
              </div>
            </div>
          `;
        }
        
        syllableGroups.forEach((entries, sylIdx) => {
          const isStressed = sylIdx === stressedIdx;
          
          // Wrap stressed syllable in tinted region
          if (isStressed) {
            html += `<div class="stressed-syllable-region">`;
          }
          
          // Process entries, grouping merged clusters with two-layer architecture (v5.11.30)
          let i = 0;
          while (i < entries.length) {
            const entry = entries[i];
            const blurb = entry.blurbData;
            const isFirstInSyllable = i === 0;
            const syllableStart = isFirstInSyllable && !isFirstSyllable && !isStressed;
            const isSilent = entry.features?.silent || entry.ipa === '';
            
            // Check if this starts a merged cluster
            if (entry.clusterMerged && entry.clusterStart) {
              // Collect all cluster members
              const clusterMembers = [entry];
              let j = i + 1;
              while (j < entries.length && entries[j].clusterSource === entry.clusterSource) {
                clusterMembers.push(entries[j]);
                j++;
              }
              
              // Generate unique ID for this cluster group
              const clusterId = `cluster-${entry.clusterSource}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              
              // Build cluster orthography string for aria-label
              const clusterOrthography = clusterMembers.map(m => m.char).join('');
              
              // Render cluster group with two-layer architecture
              // Perimeter is on floating layer (tight around orthography)
              // Overlay contains connector + bubble
              const syllableAttr = syllableStart ? ' data-syllable-start="true"' : '';
              html += `
                <div class="cluster-group" id="${clusterId}"${syllableAttr}
                     role="group"
                     aria-label="Consonant cluster: ${clusterOrthography}"
                     data-cluster-ipa="${entry.ipa}"
                     data-cluster-source="${entry.clusterSource}">
                  <div class="cluster-perimeter"></div>
                  ${clusterMembers.map(m => `
                    <div class="phoneme-row cluster-member"
                         tabindex="0"
                         role="button"
                         aria-expanded="false"
                         data-cluster-id="${clusterId}">
                      <div class="phoneme-mapping">
                        <span class="phoneme-cyr">${m.char}</span>
                        <span class="phoneme-arrow">›</span>
                        <span class="phoneme-ipa">${entry.ipa}</span>
                      </div>
                    </div>
                  `).join('')}
                  <div class="cluster-overlay-container">
                    <div class="cluster-connector"></div>
                    <div class="cluster-bubble">
                      <div class="cluster-merged-ipa">/${entry.ipa}/</div>
                      <div class="cluster-blurb-text">${blurb.blurb}</div>
                      ${blurb.citation ? `<div class="cluster-blurb-citation">${blurb.citation}</div>` : ''}
                    </div>
                  </div>
                </div>
              `;
              
              // Skip past all cluster members
              i = j;
              continue;
            }
            
            // Regular entry (non-cluster)
            let rowClasses = 'phoneme-row';
            if (isSilent) rowClasses += ' silent-letter';
            
            const syllableAttr = syllableStart ? ' data-syllable-start="true"' : '';
            const ipaDisplay = isSilent ? '[silent]' : (entry.ipa || '∅');
            
            html += `
              <div class="${rowClasses}"${syllableAttr}
                   tabindex="0"
                   role="button"
                   aria-expanded="false"
                   aria-label="${entry.char} becomes ${entry.ipa || 'nothing'}">
                <div class="phoneme-mapping">
                  <span class="phoneme-cyr">${entry.char}</span>
                  <span class="phoneme-arrow">›</span>
                  <span class="phoneme-ipa">${ipaDisplay}</span>
                </div>
                <div class="phoneme-blurb-overlay">
                  <div class="blurb-text">${blurb.blurb}</div>
                  ${blurb.citation ? `<div class="blurb-citation">${blurb.citation}</div>` : ''}
                </div>
              </div>
            `;
            
            i++;
          }
          
          if (isStressed) {
            html += `</div>`;
          }
          
          isFirstSyllable = false;
        });
        
        // Add backdrop at end (positioned via CSS)
        html += `<div class="ribbon-backdrop"></div>`;
        
        container.innerHTML = html;
        
        // Event delegation for floating overlay (v5.5)
        // Updated v5.11.30: Two-layer cluster architecture with cluster-group
        // Only attach once per container to avoid stacking handlers
        if (!container._ribbonListenerAttached) {
          container._ribbonListenerAttached = true;
          
          container.addEventListener('click', (e) => {
            const row = e.target.closest('.phoneme-row');
            const clusterGroup = e.target.closest('.cluster-group');
            const backdrop = container.querySelector('.ribbon-backdrop');
            
            // If clicking backdrop, close all
            if (e.target.classList.contains('ribbon-backdrop')) {
              container.querySelectorAll('.phoneme-row.expanded, .cluster-group.active').forEach(r => {
                r.classList.remove('expanded');
                r.classList.remove('active');
                r.setAttribute('aria-expanded', 'false');
              });
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
              return;
            }
            
            // If clicking inside an open overlay or blurb, don't toggle
            if (e.target.closest('.phoneme-blurb-overlay') || e.target.closest('.cluster-overlay')) {
              return;
            }
            
            // Handle cluster member clicks - activate parent cluster-group
            if (clusterGroup) {
              e.stopPropagation();
              const wasActive = clusterGroup.classList.contains('active');
              
              // Collapse all others
              container.querySelectorAll('.phoneme-row.expanded, .cluster-group.active').forEach(r => {
                if (r !== clusterGroup) {
                  r.classList.remove('expanded');
                  r.classList.remove('active');
                  r.setAttribute('aria-expanded', 'false');
                }
              });
              
              // Toggle clicked cluster group
              if (wasActive) {
                clusterGroup.classList.remove('active');
                clusterGroup.querySelectorAll('.cluster-member').forEach(m => {
                  m.setAttribute('aria-expanded', 'false');
                });
                container.classList.remove('has-active-blurb');
                backdrop?.classList.remove('active');
              } else {
                clusterGroup.classList.add('active');
                clusterGroup.querySelectorAll('.cluster-member').forEach(m => {
                  m.setAttribute('aria-expanded', 'true');
                });
                container.classList.add('has-active-blurb');
                backdrop?.classList.add('active');
              }
              return;
            }
            
            if (!row) return;
            
            e.stopPropagation();
            const wasExpanded = row.classList.contains('expanded');
            
            // Collapse all others (single accordion)
            container.querySelectorAll('.phoneme-row.expanded, .cluster-group.active').forEach(r => {
              if (r !== row) {
                r.classList.remove('expanded');
                r.classList.remove('active');
                r.setAttribute('aria-expanded', 'false');
              }
            });
            
            // Toggle clicked row
            if (wasExpanded) {
              row.classList.remove('expanded');
              row.setAttribute('aria-expanded', 'false');
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            } else {
              row.classList.add('expanded');
              row.setAttribute('aria-expanded', 'true');
              container.classList.add('has-active-blurb');
              backdrop?.classList.add('active');
            }
          });
          
          // Keyboard accessibility (updated for cluster-group)
          container.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              const row = e.target.closest('.phoneme-row');
              const clusterGroup = e.target.closest('.cluster-group');
              if (row || clusterGroup) {
                e.preventDefault();
                (clusterGroup || row).click();
              }
            }
            // Escape to close
            if (e.key === 'Escape') {
              const backdrop = container.querySelector('.ribbon-backdrop');
              container.querySelectorAll('.phoneme-row.expanded').forEach(r => {
                r.classList.remove('expanded');
                r.setAttribute('aria-expanded', 'false');
              });
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            }
          });
        }
      },
      
      /**
       * Recalculate syllable indices for ribbon entries based on boundary adjustments (v5.10.25)
       * Maps each log entry to its new display syllable based on IPA token positions
       */
      _recalculateSyllableIndices(displayLog, originalSyllables, displaySyllables) {
        // Build mapping: cumulative IPA token position → new syllable index
        // First, calculate original token ranges for each syllable
        const originalRanges = [];
        let tokenOffset = 0;
        originalSyllables.forEach((syl, sylIdx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          originalRanges.push({
            start: tokenOffset,
            end: tokenOffset + tokens.length,
            sylIdx
          });
          tokenOffset += tokens.length;
        });
        
        // Calculate display token ranges
        const displayRanges = [];
        let displayOffset = 0;
        displaySyllables.forEach((syl, sylIdx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          displayRanges.push({
            start: displayOffset,
            end: displayOffset + tokens.length,
            sylIdx
          });
          displayOffset += tokens.length;
        });
        
        // For each log entry, find which display syllable its IPA token(s) now fall into
        // Track cumulative token position as we iterate through entries
        let cumulativeTokenPos = 0;
        const adjustedLog = displayLog.map(entry => {
          const entryTokens = IpaTokenizer.tokenize(entry.ipa || '');
          const entryTokenCount = Math.max(1, entryTokens.length); // At least 1 for positioning
          
          // Find which display syllable contains this token position
          let newSylIdx = entry.syllableIndex ?? 0;
          for (const range of displayRanges) {
            if (cumulativeTokenPos >= range.start && cumulativeTokenPos < range.end) {
              newSylIdx = range.sylIdx;
              break;
            }
          }
          
          // Advance cumulative position
          cumulativeTokenPos += entryTokenCount;
          
          return {
            ...entry,
            adjustedSyllableIndex: newSylIdx
          };
        });
        
        return adjustedLog;
      },
      
      // ё toggle module population (v5.8)
      populateYoToggle(wordData) {
        const cyrillic = wordData.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const hasYe = cyrillic.includes('е') || cyrillic.includes('Е');
        
        // Only show if word contains е or ё
        if (!hasYo && !hasYe) {
          this.elements.yoToggleModule.style.display = 'none';
          return;
        }
        
        this.elements.yoToggleModule.style.display = 'block';
        
        // Get stored data
        const originalInput = wordData.originalInput || '';
        const dictionaryForm = wordData.dictionaryForm || '';
        const yoSource = wordData.yoSource || '';
        
        // Display current form
        this.elements.yoCurrentForm.textContent = cyrillic;
        
        // Determine button label based on state
        let buttonLabel;
        let showWarning = false;
        
        if (hasYo) {
          // Currently has ё — offer to remove
          buttonLabel = 'Remove ё';
          // Show warning if removing ё will change stress (polysyllabic words)
          const syllableCount = wordData.syllables?.length || 1;
          showWarning = syllableCount > 1;
        } else if (dictionaryForm && dictionaryForm !== cyrillic) {
          // Has е, dictionary has ё form available — offer to restore
          buttonLabel = 'Restore ё';
        } else {
          // Has е, no dictionary ё — offer to add
          buttonLabel = 'Add ё';
        }
        
        this.elements.yoToggleLabel.textContent = buttonLabel;
        this.elements.yoWarning.style.display = showWarning ? 'block' : 'none';
      },
      
      // ========================================
      // NEW FOOTER CONTROLS (v5.11)
      // Flat structure replacing accordion
      // ========================================
      
      /**
       * Populate variant row (ё toggle) - v5.11
       * Only shown if word contains е or ё
       */
      populateVariantRow(wordData) {
        const cyrillic = wordData.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const hasYe = cyrillic.includes('е') || cyrillic.includes('Е');
        
        // Hide if word has neither е nor ё
        if (!hasYo && !hasYe) {
          this.elements.variantRow.style.display = 'none';
          return;
        }
        
        this.elements.variantRow.style.display = 'flex';
        
        // Set active state based on current form
        this.elements.variantYo.classList.toggle('active', hasYo);
        this.elements.variantYe.classList.toggle('active', !hasYo && hasYe);
        
        // Store state for undo
        this._yoStateBeforeToggle = hasYo ? 'yo' : 'ye';
      },
      
      /**
       * Populate assimilation row - v5.11
       * Only shown if not last word in line
       */
      populateAssimilationRow(wordData) {
        const line = DocumentState.lines[wordData.lineIndex];
        const isLastWordInLine = wordData.wordIndex >= line.length - 1;
        
        if (isLastWordInLine) {
          this.elements.assimilationRow.style.display = 'none';
          return;
        }
        
        this.elements.assimilationRow.style.display = 'flex';
        
        // Get next word for label
        const nextWord = line[wordData.wordIndex + 1];
        const nextWordCyrillic = nextWord?.cyrillic || nextWord?.originalInput || '—';
        this.elements.nextWordLabel.textContent = nextWordCyrillic;
        
        // Set active state based on current boundary
        const currentBoundary = wordData.rightBoundary || 'soft';
        this.elements.assimilationLinked.classList.toggle('active', currentBoundary === 'soft');
        this.elements.assimilationSeparated.classList.toggle('active', currentBoundary === 'hard');
        
        // Disable if punctuation-forced
        const boundarySource = wordData.boundarySource;
        if (boundarySource === 'punctuation') {
          this.elements.assimilationRow.classList.add('disabled');
        } else {
          this.elements.assimilationRow.classList.remove('disabled');
        }
      },
      
      /**
       * Handle variant toggle (ё ↔ е) - v5.11
       */
      handleVariantToggle(variant) {
        if (!this.currentWord) return;
        
        const cyrillic = this.currentWord.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const currentVariant = hasYo ? 'yo' : 'ye';
        
        // If clicking current state, do nothing
        if (variant === currentVariant) return;
        
        // Store for undo
        this._yoStateBeforeToggle = currentVariant;
        
        // Check if warning needed (polysyllabic + removing ё)
        const syllableCount = this.currentWord.syllables?.length || 1;
        const showWarning = variant === 'ye' && syllableCount > 1;
        
        // Execute toggle (reuse existing logic)
        this.handleYoToggle();
        
        // Show toast warning if needed
        if (showWarning) {
          this.showYoToast();
        }
      },
      
      /**
       * Handle assimilation toggle - v5.11
       */
      handleAssimilationToggle(boundary) {
        if (!this.currentWord) return;
        
        const currentBoundary = this.currentWord.rightBoundary || 'soft';
        
        // If clicking current state, do nothing
        if (boundary === currentBoundary) return;
        
        // Update the boundary directly (no staging pattern for this)
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        if (word) {
          word.rightBoundary = boundary;
          this.currentWord.rightBoundary = boundary;
        }
        
        // Update UI
        this.elements.assimilationLinked.classList.toggle('active', boundary === 'soft');
        this.elements.assimilationSeparated.classList.toggle('active', boundary === 'hard');
        
        // Re-render document to apply assimilation changes
        DrawerController.renderToPaper();
      },
      
      /**
       * Show ё warning toast - v5.11
       */
      showYoToast() {
        this.elements.yoToast.classList.add('visible');
        
        // Auto-dismiss after 3 seconds
        this._yoToastTimer = setTimeout(() => {
          this.hideYoToast();
        }, 3000);
        
        // Pause on hover
        this.elements.yoToast.addEventListener('mouseenter', () => {
          if (this._yoToastTimer) {
            clearTimeout(this._yoToastTimer);
            this._yoToastTimer = null;
          }
        });
        
        this.elements.yoToast.addEventListener('mouseleave', () => {
          this._yoToastTimer = setTimeout(() => {
            this.hideYoToast();
          }, 2000);
        });
      },
      
      /**
       * Hide ё warning toast - v5.11
       */
      hideYoToast() {
        this.elements.yoToast.classList.remove('visible');
        if (this._yoToastTimer) {
          clearTimeout(this._yoToastTimer);
          this._yoToastTimer = null;
        }
      },
      
      /**
       * Undo ё toggle - v5.11
       */
      undoYoToggle() {
        if (!this.currentWord) return;
        
        // Toggle back
        this.handleYoToggle();
        
        // Hide toast
        this.hideYoToast();
      },

      open(wordData) {
        this.currentWord = wordData;
        this.isOpen = true;
        this.stressWasChanged = false;
        this.attributionSelected = false;
        
        // Hide any lingering toast immediately (v5.11.3)
        this.hideYoToast();
        
        // Collapse refine panel on every open (v5.5 - must be early to avoid flash)
        this.elements.refineToggle?.classList.remove('expanded');
        this.elements.refinePanel?.classList.remove('expanded');
        
        // Store original stress for undo functionality
        const currentStressIdx = wordData.syllables.findIndex(s => s.isStressed);
        this.currentWord.originalStress = currentStressIdx;
        
        // Staging pattern: handle word change and expiry (v5.4.0)
        const wordId = `${wordData.lineIndex}-${wordData.wordIndex}`;
        const isNewWord = this.lastWordId !== wordId;
        this.lastWordId = wordId;
        
        // Clear staged changes if: opening a different word OR staged changes expired
        if (isNewWord || this.isStagedExpired()) {
          this.clearStaged();
        }
        
        // Initialize all UI with current staged/committed state (v5.4.2)
        this.updateAllUI();
        
        // Additional word-type specific UI setup
        const syllableCount = wordData.syllables.length;
        const isClitic = wordData.isProclitic === 'true' || wordData.isEnclitic === 'true';
        const hasYo = wordData.hasYo === 'true' || wordData.hasYo === true;
        const isUnverified = wordData.stressSource === 'default';
        
        // Determine if stress is locked (monosyllable, clitic, or ё)
        const stressLocked = syllableCount === 1 || hasYo;

        // Hide stress source module when stress is locked (monosyllables or ё)
            if (stressLocked) {
                this.elements.stressSourceModule.style.display = 'none';
            } else {
                this.elements.stressSourceModule.style.display = 'block';
            }

        // Render syllable buttons with BoundaryStack offsets (v5.10.23)
        const displaySyllables = BoundaryStack.applyOffsets(wordId, wordData.syllables);
        const buttonsDisabled = hasYo && syllableCount > 1;
        
        this.elements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" data-syllable-index="${idx}" ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}</button>`
        ).join('');
        
        // Monosyllable context label (v5.11.13)
        if (syllableCount === 1) {
          const hasStress = wordData.syllables.some(s => s.isStressed);
          if (isClitic) {
            this.elements.syllableLabel.textContent = 'Unstressed clitic';
          } else if (hasStress) {
            this.elements.syllableLabel.textContent = 'Stressed monosyllable';
          } else {
            this.elements.syllableLabel.textContent = 'Unstressed monosyllable';
          }
          this.elements.syllableLabel.style.display = 'block';
        } else {
          this.elements.syllableLabel.style.display = 'none';
        }
        
        // Show customized state and register reset handler
        this._updateCustomizedState();
        
        // Populate Cyrillic display and gloss
        const syllabifiedCyrillic = wordData.syllables.map(s => 
          s.isStressed ? addAcuteToSyllable(s.cyrillic) : s.cyrillic
        ).join(' ');
        
        this.elements.cyrillic.textContent = syllabifiedCyrillic;
        this.elements.glossInline.textContent = formatGlossForPopup(wordData.gloss, wordData.pos, wordData.lemma);
        
        // Always hide top clitic badge (info now in Why section)
        this.elements.cliticBadge.style.display = 'none';

        // Show clitic banner in Why section if applicable
            const isProclitic = wordData.isProclitic === 'true' || wordData.isProclitic === true;
            const isEnclitic = wordData.isEnclitic === 'true' || wordData.isEnclitic === true;
            if (isProclitic || isEnclitic) {
                const cliticText = isProclitic 
                    ? 'Proclitic — attaches to the following word like a prefix. A clitic carries no independent stress; its vowel (if any) reduces based on the clitic\'s proximity to the host word\'s stressed syllable. <em>See <span class="tie-bar-ref">‿</span> below for phonological boundaries.</em>'
                    : 'Enclitic — attaches to the preceding word like a suffix. A clitic carries no independent stress; its vowel (if any) reduces based on the clitic\'s proximity to the host word\'s stressed syllable. <em>See <span class="tie-bar-ref">‿</span> below for phonological boundaries.</em>';
                this.elements.whyCliticBanner.innerHTML = cliticText;
                this.elements.whyCliticBanner.style.display = 'block';
            } else {
                this.elements.whyCliticBanner.style.display = 'none';
            }

        // REMOVED IN v5.5 REDESIGN: word-level citation (now using per-phoneme blurbs)
        
        // Render Phoneme Ribbon (v5.5 vertical layout)
        this.renderRibbon(wordData);
        
        // ё toggle module (v5.8) - OLD LOCATION (hidden in v5.11)
        this.populateYoToggle(wordData);
        
        // NEW: Footer controls (v5.11 - flat structure)
        this.populateVariantRow(wordData);
        this.populateAssimilationRow(wordData);
        
        // Phrase boundary control (v5.4.2 - segments instead of radio) - HIDDEN IN v5.11
        const line = DocumentState.lines[wordData.lineIndex];
        const isLastWordInLine = wordData.wordIndex >= line.length - 1;
        const boundarySource = wordData.boundarySource;
        
        if (isLastWordInLine) {
          // Hide for last word — no boundary to control
          this.elements.phraseBoundaryModule.style.display = 'none';
        } else {
          this.elements.phraseBoundaryModule.style.display = 'block';
          
          // Disable if punctuation-forced
          if (boundarySource === 'punctuation') {
            this.elements.phraseBoundaryModule.classList.add('disabled');
          } else {
            this.elements.phraseBoundaryModule.classList.remove('disabled');
          }
          
          // Update boundary UI (handles segment states)
          this.updateBoundaryUI();
        }
        
        this.positionPopup(wordData.element);
        this.elements.overlay.classList.add('active');
      },
      
      close() {
        // If stress was changed but no attribution selected, default to 'user'
        if (this.stressWasChanged && !this.attributionSelected && this.currentWord) {
          DocumentState.updateStressSource(
            this.currentWord.lineIndex,
            this.currentWord.wordIndex,
            'user'
          );
        }
        
        // Boundary customizations now persist until page reload (v5.10.23)
        // Word stack IPA already synced in _updateSyllableDisplay()
        
        // Reset state
        this.isOpen = false;
        this.stressWasChanged = false;
        this.attributionSelected = false;
        this.currentWord = null;
        this.elements.overlay.classList.remove('active');
        // UPDATED IN v5.5: refinePanel instead of whyPanel
        this.elements.refineToggle?.classList.remove('expanded');
        this.elements.refinePanel?.classList.remove('expanded');
        this.elements.stressSourceModule.classList.remove('needs-attention');
        this.clearAttributionSelection();
        
        // Reset header customized state (v5.10.19)
        this.elements.syllableDisplayHeader.classList.remove('customized');
        
        // Hide toast (v5.11)
        this.hideYoToast();
      },
      
      positionPopup(element) {
        const rect = element.getBoundingClientRect();
        const card = this.elements.card;
        const cardWidth = 320;
        const margin = 10;
        const viewportHeight = window.innerHeight;
        
        // Horizontal positioning
        let left = rect.left + (rect.width / 2) - (cardWidth / 2);
        left = Math.max(margin, Math.min(left, window.innerWidth - cardWidth - margin));
        
        // Calculate available space above and below the word
        const spaceAbove = rect.top - margin * 2;
        const spaceBelow = viewportHeight - rect.bottom - margin * 2;
        
        let top;
        let maxHeight;
        
        // Prefer placing above if more room there and sufficient space
        if (spaceAbove >= spaceBelow && spaceAbove >= 250) {
          // Place above: position bottom of card at top of word
          maxHeight = Math.min(spaceAbove, viewportHeight * 0.7);
          top = rect.top - margin - maxHeight;
          top = Math.max(margin, top);
          card.classList.remove('arrow-top');
        } else {
          // Place below: position top of card at bottom of word
          maxHeight = Math.min(spaceBelow, viewportHeight * 0.7);
          top = rect.bottom + margin;
          card.classList.add('arrow-top');
        }
        
        // Ensure minimum usable height
        maxHeight = Math.max(250, maxHeight);
        
        card.style.maxHeight = `${maxHeight}px`;
        card.style.top = `${top}px`;
        card.style.left = `${left}px`;
      },
      
      // Drag handling state (v5.10.15, refactored v5.11.27)
      _dragState: null,
      _ghostElement: null,
      _hasShownDragHint: false,
      
      /**
       * Setup unified pointer handlers for syllable buttons (v5.11.27)
       * Distance-on-release disambiguation:
       * - <10px movement = tap = reassign stress
       * - 10-40px = hesitation/jitter = silent cancellation
       * - >40px horizontal = drag = shed consonant
       * 
       * No separate click handler, no flags, no timeouts.
       * Pure geometric decision at moment of release.
       */
      _setupDragHandlers() {
        const container = this.elements.syllableDisplay;
        const CLICK_THRESHOLD = 10;   // px - absorbs normal jitter
        const DRAG_THRESHOLD = 40;    // px - existing shed threshold
        
        // Unified handler for mouse and touch
        const handlePointerDown = (e) => {
          const btn = e.target.closest('.syllable-btn');
          if (!btn || !this.isOpen || btn.disabled) return;
          
          // Only handle primary button (left click / single touch)
          if (e.button !== undefined && e.button !== 0) return;
          
          // Get pointer position (mouse or touch)
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          
          this._dragState = {
            startX: clientX,
            startY: clientY,
            syllableIdx: parseInt(btn.dataset.syllableIndex, 10),
            button: btn
          };
          
          // Prevent text selection during potential drag
          e.preventDefault();
        };
        
        const handlePointerMove = (e) => {
          if (!this._dragState) return;
          
          // Optional: cursor feedback when exiting click zone
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const dx = Math.abs(clientX - this._dragState.startX);
          
          if (dx > CLICK_THRESHOLD) {
            this._dragState.button.style.cursor = 'grabbing';
          }
        };
        
        const handlePointerUp = (e) => {
          if (!this._dragState) return;
          
          const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
          const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
          
          const dx = clientX - this._dragState.startX;
          const dy = clientY - this._dragState.startY;
          const distance = Math.abs(dx); // Horizontal distance for drag detection
          
          // Reset cursor
          this._dragState.button.style.cursor = '';
          
          if (distance < CLICK_THRESHOLD) {
            // CASE 1: Clean tap/click → reassign stress
            this.updateStress(this._dragState.syllableIdx);
          } 
          else if (distance >= DRAG_THRESHOLD && Math.abs(dy) < 20) {
            // CASE 2: Committed horizontal drag → shed consonant
            const direction = dx > 0 ? 'right' : 'left';
            this._attemptConsonantShed(this._dragState.syllableIdx, direction);
            this._cleanupGhost();
          }
          // CASE 3: Dead zone (10-40px) or vertical movement → silent cancellation
          // Do nothing - this is the "Calm" moment
          
          this._dragState = null;
        };
        
        // Mouse events
        container.addEventListener('mousedown', handlePointerDown);
        document.addEventListener('mousemove', handlePointerMove);
        document.addEventListener('mouseup', handlePointerUp);
        
        // Touch events (not passive because we preventDefault in pointerdown)
        container.addEventListener('touchstart', handlePointerDown, { passive: false });
        document.addEventListener('touchmove', handlePointerMove, { passive: true });
        document.addEventListener('touchend', handlePointerUp);
      },
      
      /**
       * Attempt to shed a consonant from syllable in given direction
       */
      _attemptConsonantShed(syllableIdx, direction) {
        if (!this.currentWord) return;
        
        const syllables = this.currentWord.syllables;
        const syllableCount = syllables.length;
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        
        // Clamp check: can't shed left from first syllable or right from last
        if (direction === 'left' && syllableIdx === 0) {
          this._flashInvalid(syllableIdx);
          return;
        }
        if (direction === 'right' && syllableIdx === syllableCount - 1) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // Get current syllable's tokens
        const displaySyllables = BoundaryStack.applyOffsets(wordId, syllables);
        const currentSyl = displaySyllables[syllableIdx];
        const tokens = IpaTokenizer.tokenize(currentSyl.ipa);
        const segments = IpaTokenizer.parseSegments(tokens);
        
        // Check if we can shed in this direction
        let canShed = false;
        let consonantToShed = null;
        
        if (direction === 'left') {
          // Shed leftmost onset consonant to previous syllable's coda
          if (segments.onset.length > 0) {
            canShed = true;
            consonantToShed = segments.onset[0].symbol;
          }
        } else {
          // Shed rightmost coda consonant to next syllable's onset
          if (segments.coda.length > 0) {
            canShed = true;
            consonantToShed = segments.coda[segments.coda.length - 1].symbol;
          }
        }
        
        if (!canShed) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // Check for reset gesture: if dragging back to origin, reset all boundaries
        if (this._isResetGesture(wordId, syllableIdx, direction, syllableCount)) {
          BoundaryStack.reset(wordId);
          this._updateSyllableDisplay();
          this._pulseAllConsonants();
          return;
        }
        
        // Get button positions for animation
        const sourceBtn = this.elements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        const targetIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx + 1;
        const targetBtn = this.elements.syllableDisplay.querySelector(`[data-syllable-index="${targetIdx}"]`);
        
        if (sourceBtn && targetBtn) {
          // Animate the ghost consonant
          this._animateConsonantGhost(consonantToShed, sourceBtn, targetBtn, direction, () => {
            // Shift the boundary after animation completes
            const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
            const shiftDir = direction === 'left' ? 'left' : 'right';
            BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
            
            // Update display
            this._updateSyllableDisplay();
            this._updateCustomizedState();
          });
        } else {
          // Fallback: no animation, just update
          const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
          const shiftDir = direction === 'left' ? 'left' : 'right';
          BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
          this._updateSyllableDisplay();
          this._updateCustomizedState();
        }
      },
      
      /**
       * Animate a ghost consonant from source to target button
       */
      _animateConsonantGhost(consonant, sourceBtn, targetBtn, direction, onComplete) {
        // Get positions
        const sourceRect = sourceBtn.getBoundingClientRect();
        const targetRect = targetBtn.getBoundingClientRect();
        
        // Calculate start and end positions
        // For left drag: consonant leaves from left edge of source, arrives at right edge of target
        // For right drag: consonant leaves from right edge of source, arrives at left edge of target
        const startX = direction === 'left' 
          ? sourceRect.left 
          : sourceRect.right - 20;
        const startY = sourceRect.top + sourceRect.height / 2 - 15;
        
        const endX = direction === 'left'
          ? targetRect.right - 20
          : targetRect.left;
        const endY = targetRect.top + targetRect.height / 2 - 15;
        
        // Create ghost element
        const ghost = document.createElement('div');
        ghost.className = 'consonant-ghost';
        ghost.textContent = consonant;
        ghost.style.left = `${startX}px`;
        ghost.style.top = `${startY}px`;
        document.body.appendChild(ghost);
        this._ghostElement = ghost;
        
        // Dim the source button
        sourceBtn.classList.add('dragging');
        
        // Highlight target button
        targetBtn.classList.add('drag-target');
        
        // Trigger animation after a frame (to ensure initial position is set)
        requestAnimationFrame(() => {
          ghost.style.transition = 'left 0.25s ease-out, top 0.25s ease-out';
          ghost.style.left = `${endX}px`;
          ghost.style.top = `${endY}px`;
          ghost.classList.add('valid');
        });
        
        // Cleanup and callback after animation
        setTimeout(() => {
          sourceBtn.classList.remove('dragging');
          targetBtn.classList.remove('drag-target');
          this._cleanupGhost();
          onComplete();
        }, 260);
      },
      
      /**
       * Check if this is a reset gesture (dragging consonant back to origin)
       * Only triggers when the drag would return the boundary toward zero
       */
      _isResetGesture(wordId, syllableIdx, direction, syllableCount) {
        const offsets = BoundaryStack.getOffsets(wordId, syllableCount);
        const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
        
        if (boundaryIdx < 0 || boundaryIdx >= offsets.length) return false;
        
        const currentOffset = offsets[boundaryIdx];
        
        // Reset only if this drag would move offset TOWARD zero
        // direction='left' increases offset (++)
        // direction='right' decreases offset (--)
        
        if (direction === 'left' && currentOffset < 0) {
          // Offset is negative (gave to right), dragging left brings it toward 0
          return currentOffset === -1; // Only reset if this is the last step back
        }
        if (direction === 'right' && currentOffset > 0) {
          // Offset is positive (stole from right), dragging right brings it toward 0
          return currentOffset === 1; // Only reset if this is the last step back
        }
        
        return false;
      },
      
      /**
       * Flash invalid feedback on syllable button
       */
      _flashInvalid(syllableIdx) {
        const btn = this.elements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        if (btn) {
          btn.classList.add('drag-invalid');
          setTimeout(() => btn.classList.remove('drag-invalid'), 300);
        }
      },
      
      /**
       * Update syllable button display with boundary offsets applied
       */
      _updateSyllableDisplay() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const originalSyllables = this.currentWord.syllables;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, originalSyllables);
        
        // Re-render buttons with display syllables
        const hasYo = this.currentWord.hasYo === 'true' || this.currentWord.hasYo === true;
        const syllableCount = displaySyllables.length;
        const buttonsDisabled = hasYo && syllableCount > 1;
        
        this.elements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" data-syllable-index="${idx}" ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}</button>`
        ).join('');
        
        // Sync word stack IPA in main document (v5.10.22)
        const wordStack = document.querySelector(
          `.word-stack[data-line-index="${this.currentWord.lineIndex}"][data-word-index="${this.currentWord.wordIndex}"]`
        );
        if (wordStack) {
          const ipaSpan = wordStack.querySelector('.ipa');
          if (ipaSpan) {
            // Build display IPA with stress marks and spaces
            let displayIPA = displaySyllables.map((syl, idx) => {
              return syl.isStressed && displaySyllables.length > 1 ? 'ˈ' + syl.ipa : syl.ipa;
            }).join(' ');
            
            // Preserve clitic tie bars
            const isProclitic = this.currentWord.isProclitic === 'true' || this.currentWord.isProclitic === true;
            const isEnclitic = this.currentWord.isEnclitic === 'true' || this.currentWord.isEnclitic === true;
            if (isProclitic) {
              displayIPA = displayIPA + '‿';
            } else if (isEnclitic) {
              displayIPA = '‿' + displayIPA;
            }
            
            ipaSpan.textContent = displayIPA;
          }
        }
        
        // Re-render ribbon with updated syllable groupings (v5.10.25)
        if (this.currentWord) {
          this.renderRibbon(this.currentWord);
        }
      },
      
      /**
       * Update header to show customized state (boundaries adjusted)
       */
      _updateCustomizedState() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const hasCustom = BoundaryStack.hasCustomBoundaries(wordId);
        
        this.elements.syllableDisplayHeader.classList.toggle('customized', hasCustom);
        
        // Set up click handler for reset (only once, uses currentWord dynamically)
        if (!this._headerResetHandler) {
          this._headerResetHandler = () => {
            if (!this.currentWord) return;
            const currentWordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
            if (BoundaryStack.hasCustomBoundaries(currentWordId)) {
              BoundaryStack.reset(currentWordId);
              this._updateSyllableDisplay();
              this._updateCustomizedState();
              this._pulseAllConsonants();
            }
          };
          this.elements.syllableDisplayHeader.addEventListener('click', this._headerResetHandler);
        }
      },
      
      /**
       * Pulse animation when resetting to default
       */
      _pulseAllConsonants() {
        const buttons = this.elements.syllableDisplay.querySelectorAll('.syllable-btn');
        buttons.forEach(btn => {
          btn.style.transition = 'transform 0.2s ease-out';
          btn.style.transform = 'scale(1.05)';
          setTimeout(() => {
            btn.style.transform = 'scale(1)';
          }, 200);
        });
      },
      
      /**
       * Clean up ghost element
       */
      _cleanupGhost() {
        if (this._ghostElement) {
          this._ghostElement.remove();
          this._ghostElement = null;
        }
      },
      
      updateStress(newStressIdx) {
        if (!this.currentWord) return;
        
        // Block stress changes for ё words (ё always carries stress)
        const hasYo = this.currentWord.hasYo === 'true' || this.currentWord.hasYo === true || 
                      GraysonEngine.hasYo(this.currentWord.cyrillic);
        if (hasYo) {
          return; // Stress is locked to ё syllable
        }
        
        DocumentState.updateStress(this.currentWord.lineIndex, this.currentWord.wordIndex, newStressIdx);
        DrawerController.renderToPaper();
        
        const result = GraysonEngine.transcribe(this.currentWord.cyrillic, newStressIdx, this.currentWord.isProclitic === 'true' || this.currentWord.isProclitic === true);
        this.currentWord.ipa = result.ipa;
        this.currentWord.syllables = result.syllables;
        this.currentWord.transcriptionLog = result.transcriptionLog;
        
        // Re-render syllable buttons with updated stress marks
        this.elements.syllableDisplay.querySelectorAll('.syllable-btn').forEach((btn, idx) => {
          const syl = result.syllables[idx];
          btn.classList.toggle('stressed', idx === newStressIdx);
          btn.textContent = (idx === newStressIdx) ? 'ˈ' + syl.ipa : syl.ipa;
        });
        
        // Re-render Phoneme Ribbon with new stress position
        this.renderRibbon(this.currentWord);
        
        // Track that stress was changed and trigger attribution prompt
        this.stressWasChanged = true;
        this.attributionSelected = false;
        this.clearAttributionSelection();
        
        // Expand Why panel and trigger pulse animation
        this.elements.whyPanel.classList.add('expanded');
        this.elements.stressSourceModule.classList.remove('needs-attention');
        // Force reflow to restart animation
        void this.elements.stressSourceModule.offsetWidth;
        this.elements.stressSourceModule.classList.add('needs-attention');
        
        // Update hint text
        this.elements.stressSourceHint.textContent = 'Optional: mark why you changed this';
      }
    };

    /* ========================================
       EVENT DELEGATION
       ======================================== */
    document.addEventListener('click', (e) => {
      // Handle word-stack clicks
      const wordStack = e.target.closest('.word-stack');
      if (wordStack && !Popup.isOpen) {
        const data = {
          wordId: wordStack.dataset.wordId,
          lineIndex: parseInt(wordStack.dataset.lineIndex, 10),
          wordIndex: parseInt(wordStack.dataset.wordIndex, 10),
          ipa: wordStack.dataset.ipa,
          cyrillic: wordStack.dataset.cyrillic,
          gloss: wordStack.dataset.gloss,
          pos: wordStack.dataset.pos,
          lemma: wordStack.dataset.lemma,
          punctuation: wordStack.dataset.punctuation || '',
          syllables: JSON.parse(wordStack.dataset.syllables || '[]'),
          transcriptionLog: JSON.parse(wordStack.dataset.transcriptionLog || '[]'),
          isProclitic: wordStack.dataset.isProclitic,
          isEnclitic: wordStack.dataset.isEnclitic,
          hasYo: wordStack.dataset.hasYo,
          stressSource: wordStack.dataset.stressSource,
          rightBoundary: wordStack.dataset.rightBoundary,
          boundarySource: wordStack.dataset.boundarySource,
          element: wordStack
        };
        Popup.open(data);
      }
    });
    
    document.addEventListener('keydown', (e) => {
      if (Popup.isOpen) return;
      
      const wordStack = e.target.closest('.word-stack');
      if (!wordStack) return;
      
      const verseLine = wordStack.closest('.verse-line');
      const allWords = [...verseLine.querySelectorAll('.word-stack')];
      const currentIndex = allWords.indexOf(wordStack);
      
      let nextElement = null;
      
      switch (e.key) {
        case 'ArrowRight':
          e.preventDefault();
          if (currentIndex < allWords.length - 1) {
            nextElement = allWords[currentIndex + 1];
          }
          break;
          
        case 'ArrowLeft':
          e.preventDefault();
          if (currentIndex > 0) {
            nextElement = allWords[currentIndex - 1];
          }
          break;
          
        case 'ArrowDown':
          e.preventDefault();
          const nextVerse = verseLine.nextElementSibling;
          if (nextVerse && nextVerse.classList.contains('verse-line')) {
            const nextWords = [...nextVerse.querySelectorAll('.word-stack')];
            nextElement = nextWords[Math.min(currentIndex, nextWords.length - 1)];
          }
          break;
          
        case 'ArrowUp':
          e.preventDefault();
          const prevVerse = verseLine.previousElementSibling;
          if (prevVerse && prevVerse.classList.contains('verse-line')) {
            const prevWords = [...prevVerse.querySelectorAll('.word-stack')];
            nextElement = prevWords[Math.min(currentIndex, prevWords.length - 1)];
          }
          break;
          
        case 'Enter':
        case ' ':
          e.preventDefault();
          wordStack.click();
          return;
      }
      
      if (nextElement) {
        nextElement.focus();
      }
    });

    /* ========================================
       INITIALIZATION
       ======================================== */
    document.addEventListener('DOMContentLoaded', () => {
      DrawerController.init();
      TabController.init();
      DashboardController.init();
      ProfileController.init();
      DocumentController.init();
      Popup.init();
      
      // Render empty title page on load
      DrawerController.renderToPaper();
    });

    /* ========================================
       GOLDEN-MASTER TESTS
       Run with: runGoldenTests() in browser console
       ======================================== */
    
    // Wrapper function for GraysonEngine.transcribe
    function processWord(word, stress, options = {}) {
      const isClitic = options.isClitic || stress === -1;
      return GraysonEngine.transcribe(word, stress, isClitic);
    }

    const GOLDEN_TESTS = {
      'Clitics and Prepositions': [
        { word: 'во', stress: -1, expected: 'vɑ', note: 'Voweled preposition, unstressed' },
        { word: 'ко', stress: -1, expected: 'kɑ', note: 'Voweled preposition, unstressed' },
        { word: 'со', stress: -1, expected: 'sɑ', note: 'Voweled preposition, unstressed' },
        { word: 'не', stress: -1, expected: 'ɲɪ', note: 'Particle, unstressed' },
        { word: 'ни', stress: -1, expected: 'ɲi', note: 'Particle, unstressed' },
      ],
      'Stressed Vowels': [
        { word: 'мама', stress: 0, expected: 'mɑ mɑ', note: 'Stressed а → ɑ' },
        { word: 'папа', stress: 0, expected: 'pɑ pɑ', note: 'Stressed а → ɑ' },
        { word: 'дом', stress: 0, expected: 'dom', note: 'Stressed о → o' },
        { word: 'ночь', stress: 0, expected: 'notʃʲ', note: 'Stressed о → o, ч palatalized' },
        { word: 'сон', stress: 0, expected: 'son', note: 'Stressed о → o' },
        { word: 'лес', stress: 0, expected: 'lʲɛs', note: 'Stressed е → ɛ' },
        { word: 'мир', stress: 0, expected: 'mʲir', note: 'Stressed и → i' },
        { word: 'сын', stress: 0, expected: 'sɨn', note: 'Stressed ы → ɨ' },
        { word: 'дух', stress: 0, expected: 'dux', note: 'Stressed у → u' },
      ],
      'Vowel Reduction - Akanye': [
        { word: 'вода', stress: 1, expected: 'vɑ dɑ', note: 'Immediate pretonic о → ɑ' },
        { word: 'молоко', stress: 2, expected: 'mʌ ɫɑ ko', note: 'Remote о → ʌ, immediate → ɑ' },
        { word: 'хорошо', stress: 2, expected: 'xʌ rɑ ʃo', note: 'Remote о → ʌ, immediate → ɑ' },
        { word: 'голова', stress: 2, expected: 'ɡʌ ɫɑ vɑ', note: 'Remote о → ʌ, immediate → ɑ' },
      ],
      'Vowel Reduction - Ikanye': [
        { word: 'весна', stress: 1, expected: 'vʲɪ snɑ', note: 'Unstressed е → ɪ' },
        { word: 'земля', stress: 1, expected: 'zʲɪ mlʲɑ', note: 'Unstressed е → ɪ' },
      ],
      'И Never Reduces': [
        { word: 'игра', stress: 1, expected: 'i ɡrɑ', note: 'Unstressed и stays i' },
        { word: 'книга', stress: 0, expected: 'kɲi ɡɑ', note: 'Unstressed и stays i' },
      ],
      'Palatal Nasal': [
        { word: 'няня', stress: 0, expected: 'ɲa ɲɑ', note: 'н before я → ɲ' },
        { word: 'конь', stress: 0, expected: 'koɲ', note: 'нь → ɲ' },
        { word: 'день', stress: 0, expected: 'dʲeɲ', note: 'Interpalatal е → e, нь → ɲ' },
        { word: 'очень', stress: 0, expected: 'otʃʲiɲ', note: 'Unstressed interpalatal е → i' },
        { word: 'моей', stress: 1, expected: 'mɑ jej', note: 'Interpalatal stressed е → /e/ (j-glide + е + й)' },
      ],
      'Hard vs Soft Л': [
        { word: 'был', stress: 0, expected: 'bɨɫ', note: 'Hard л → ɫ' },
        { word: 'была', stress: 1, expected: 'bɨ ɫɑ', note: 'Hard л → ɫ' },
        { word: 'люди', stress: 0, expected: 'lʲu dʲi', note: 'Soft л → lʲ' },
        { word: 'любовь', stress: 1, expected: 'lʲu bofʲ', note: 'Soft л → lʲ' },
      ],
      'Voicing Assimilation - Devoicing': [
        { word: 'трубка', stress: 0, expected: 'trup kɑ', note: 'б→п before к' },
        { word: 'обход', stress: 1, expected: 'ɑp xot', note: 'б→п before х' },
        { word: 'ногти', stress: 0, expected: 'nok tʲi', note: 'г→к before т' },
        { word: 'водка', stress: 0, expected: 'vot kɑ', note: 'д→т before к' },
        { word: 'подход', stress: 1, expected: 'pɑt xot', note: 'д→т before х' },
        { word: 'ложка', stress: 0, expected: 'ɫoʃ kɑ', note: 'ж→ш before к' },
        { word: 'лезть', stress: 0, expected: 'lʲesʲtʲ', note: 'Interpalatal е → /e/, з→с before т' },
      ],
      'Voicing Assimilation - Voicing': [
        { word: 'вокзал', stress: 1, expected: 'vɑɡ zɑɫ', note: 'к→г before з' },
        { word: 'сбор', stress: 0, expected: 'zbor', note: 'с→з before б' },
        { word: 'просьба', stress: 0, expected: 'prozʲ bɑ', note: 'с→з before б' },
        { word: 'отбой', stress: 1, expected: 'ɑd boj', note: 'т→д before б' },
      ],
      'Special Clusters': [
        { word: 'что', stress: 0, expected: 'ʃto', note: 'чт→ʃt' },
        { word: 'конечно', stress: 1, expected: 'kɑ ɲɛ ʃnʌ', note: 'чн→ʃn' },
        { word: 'скучно', stress: 0, expected: 'sku ʃnʌ', note: 'чн→ʃn' },
      ],
      'Reflexive Verbs': [
        { word: 'боится', stress: 1, expected: 'bɑ i tːsʌ', note: '-тся→tːsʌ' },
        { word: 'купаться', stress: 1, expected: 'ku pɑ tːsʌ', note: '-ться→tːsʌ' },
      ],
      'Exception Words': [
        { word: 'счастье', stress: 0, expected: 'ʃʲʃʲɑ sʲtʲjɪ', note: 'сч→ʃʲʃʲ' },
        { word: 'сердце', stress: 0, expected: 'sʲɛr tsɨ', note: 'рдц→рц, д silent' },
        { word: 'солнце', stress: 0, expected: 'son tsɨ', note: 'лнц→нц, л silent' },
        { word: 'здравствуй', stress: 0, expected: 'zdrɑ stvuj', note: 'вств→ств, first в silent' },
        { word: 'чувство', stress: 0, expected: 'tʃʲu stvʌ', note: 'вств→ств, first в silent' },
      ],
      'Ё Stress Rule': [
        { word: 'ёлка', stress: 0, expected: 'joɫ kɑ', note: 'ё always stressed' },
        { word: 'моё', stress: 1, expected: 'mɑ jo', note: 'ё always stressed' },
        { word: 'её', stress: 1, expected: 'ji jo', note: 'ё always stressed' },
      ],
      'Pushkin/Tchaikovsky Vocabulary': [
        { word: 'храм', stress: 0, expected: 'xrɑm', note: 'Monosyllable' },
        { word: 'брожу', stress: 1, expected: 'brɑ ʒu', note: 'Common verb' },
        { word: 'улиц', stress: 0, expected: 'u lʲits', note: 'Genitive plural' },
        { word: 'шумных', stress: 0, expected: 'ʃum nɨx', note: 'Adjective genitive plural' },
      ],
    };

    function normalizeForComparison(ipa) {
      return ipa
        .replace(/\s+/g, '')
        .replace(/ˈ/g, '')
        .replace(/ˌ/g, '')
        .replace(/[\/\[\]]/g, '')
        .replace(/\./g, '');
    }

    function runGoldenTests() {
      let totalPassed = 0;
      let totalFailed = 0;
      const failures = [];

      console.log('═══════════════════════════════════════════════════════════');
      console.log('<em>Ilya</em> Golden-Master Tests');
      console.log('═══════════════════════════════════════════════════════════');

      for (const [category, tests] of Object.entries(GOLDEN_TESTS)) {
        console.log(`\n▶ ${category}`);
        for (const test of tests) {
          const result = processWord(test.word, test.stress);
          // Use full-word IPA (includes cross-syllable assimilation) not syllable concatenation
          const actual = result.ipa.replace(/ˈ/g, ' ˈ').replace(/^\s+/, '').trim();
          const syllableIpa = result.syllables.map(s => s.ipa).join(' ');

          const normalizedActual = normalizeForComparison(actual);
          const normalizedExpected = normalizeForComparison(test.expected);
          const passed = normalizedActual === normalizedExpected;

          if (passed) {
            totalPassed++;
            console.log(`  ✅ ${test.word}: /${actual}/`);
          } else {
            totalFailed++;
            failures.push({ word: test.word, expected: test.expected, actual, note: test.note });
            console.log(`  ❌ ${test.word}: got /${actual}/, expected /${test.expected}/`);
            if (actual !== syllableIpa) {
              console.log(`     (syllables: /${syllableIpa}/)`);
            }
            console.log(`     ${test.note}`);
          }
        }
      }

      console.log('\n═══════════════════════════════════════════════════════════');
      const total = totalPassed + totalFailed;
      const passRate = ((totalPassed / total) * 100).toFixed(1);
      if (totalFailed === 0) {
        console.log(`🎉 ALL TESTS PASSED: ${totalPassed}/${total} (${passRate}%)`);
      } else {
        console.log(`⚠️  ${totalPassed}/${total} passed (${passRate}%)`);
        console.log(`\nFailed tests:`);
        failures.forEach(f => {
          console.log(`  - ${f.word}: expected /${f.expected}/, got /${f.actual}/`);
        });
      }
      console.log('═══════════════════════════════════════════════════════════');

      return { passed: totalPassed, failed: totalFailed, total, failures };
    }

    function testWord(word, stress = 0) {
      const result = processWord(word, stress);
      const ipa = result.syllables.map(s => s.ipa).join(' ');
      console.log(`${word} (stress: ${stress}) → /${ipa}/`);
      return result;
    }

    // Expose for browser console
    window.runGoldenTests = runGoldenTests;
    window.testWord = testWord;
    window.GOLDEN_TESTS = GOLDEN_TESTS;
    
    /**
     * DICTIONARY AUDIT DIAGNOSTIC (v5.11.20)
     * Usage: auditDictionary() to audit current document
     *        auditDictionary("Брожу ли я вдоль улиц шумных") to audit custom text
     * 
     * Returns coverage statistics and categorized misses
     */
    window.auditDictionary = function(text) {
      // Use provided text or current document
      const corpus = text || (DocumentState.lines || []).map(l => l.text).join('\n');
      
      if (!corpus) {
        console.log('No text to audit. Paste Russian text into the input area first, or pass text as argument.');
        return;
      }
      
      // Extract words (Cyrillic only, normalized)
      const wordPattern = /[а-яёА-ЯЁ]+/g;
      const rawWords = corpus.match(wordPattern) || [];
      
      // Count word frequencies
      const wordFreq = new Map();
      rawWords.forEach(w => {
        const lower = w.toLowerCase();
        wordFreq.set(lower, (wordFreq.get(lower) || 0) + 1);
      });
      
      // Categorize each unique word
      const results = {
        found: [],
        notInDictionary: [],
        isClitic: [],
        total: wordFreq.size,
        totalTokens: rawWords.length
      };
      
      wordFreq.forEach((freq, word) => {
        // Check if it's a clitic (handled separately)
        if (GraysonEngine.proclitics.has(word) || GraysonEngine.enclitics.has(word)) {
          results.isClitic.push({ word, freq });
          return;
        }
        
        // Check curated glosses
        if (CURATED_GLOSSES.has(word)) {
          results.found.push({ word, freq, source: 'curated' });
          return;
        }
        
        // Check main dictionary
        if (typeof window.russianDictionary !== 'undefined' && window.russianDictionary.has(word)) {
          results.found.push({ word, freq, source: 'dictionary' });
          return;
        }
        
        // Not found
        results.notInDictionary.push({ word, freq });
      });
      
      // Sort misses by frequency (highest first)
      results.notInDictionary.sort((a, b) => b.freq - a.freq);
      
      // Calculate coverage
      const foundCount = results.found.length + results.isClitic.length;
      const coverage = ((foundCount / results.total) * 100).toFixed(1);
      const tokenCoverage = ((results.found.reduce((sum, w) => sum + w.freq, 0) + 
                              results.isClitic.reduce((sum, w) => sum + w.freq, 0)) / 
                             results.totalTokens * 100).toFixed(1);
      
      // Format report
      console.log('%c═══════════════════════════════════════', 'color: #667eea');
      console.log('%c ILYA DICTIONARY AUDIT', 'font-weight: bold; font-size: 14px; color: #667eea');
      console.log('%c═══════════════════════════════════════', 'color: #667eea');
      console.log(`\nUnique words: ${results.total}`);
      console.log(`Total tokens: ${results.totalTokens}`);
      console.log(`\n%cCoverage: ${foundCount}/${results.total} unique words (${coverage}%)`, 'font-weight: bold');
      console.log(`%cToken coverage: ${tokenCoverage}% of running text`, 'font-weight: bold');
      
      console.log(`\n%cMisses by type:`, 'font-weight: bold; color: #e53e3e');
      console.log(`  • Not in dictionary: ${results.notInDictionary.length}`);
      console.log(`  • Clitics (handled separately): ${results.isClitic.length}`);
      
      if (results.notInDictionary.length > 0) {
        console.log(`\n%cTop ${Math.min(15, results.notInDictionary.length)} missing words:`, 'font-weight: bold; color: #e53e3e');
        results.notInDictionary.slice(0, 15).forEach((w, i) => {
          console.log(`  ${i + 1}. "${w.word}" (×${w.freq})`);
        });
      }
      
      console.log('%c═══════════════════════════════════════', 'color: #667eea');
      
      // Return raw data for programmatic use
      return {
        coverage: parseFloat(coverage),
        tokenCoverage: parseFloat(tokenCoverage),
        uniqueWords: results.total,
        totalTokens: results.totalTokens,
        found: results.found.length,
        missing: results.notInDictionary,
        clitics: results.isClitic
      };
    };
  </script>

</body>
</html>
