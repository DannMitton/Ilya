<!DOCTYPE html>
<html lang="ru" translate="no">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google" content="notranslate">
  <title>Ilya — v6.0.53 Drill pill relocated to inspector header</title>
  
  <!-- Favicon: simple И in terracotta circle -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23a85a3a'/><text x='50' y='68' font-size='50' fill='white' text-anchor='middle' font-family='serif'>И</text></svg>">
  
  <!-- Noto Serif for all text -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500&family=Noto+Serif:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
  
  <!-- Pako library for gzip decompression -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  
  <style>
    /* ========================================
       CALM AUTHORITY PALETTE v5.2
       Kimi Design System — Muted Sage Edition
       ======================================== */
    :root {
      /* Core Palette */
      --ilya-paper: #ffffff;
      --ilya-parchment: #fafafa;
      --ilya-binding: #f5f5f0;
      --ilya-binding-dark: #ebebe5;
      
      /* Legacy aliases (for backward compatibility) */
      --paper: #faf6f0;
      --surface: #ffffff;
      
      /* Typography Colors */
      --ilya-text-primary: #2c3e50;
      --ilya-text-secondary: #5a6c7d;
      --ilya-text-muted: #7f8c8d;
      --ilya-text-caption: #95a5a6;
      
      /* Legacy ink aliases */
      --ink-primary: #1a1612;
      --ink-secondary: #4a4540;
      
      /* Ilya Stationery Palette (v5.9.6) */
      --stationery-cream: #F8F5F0;        /* Warm aged manuscript */
      --stationery-ink: #1A1612;          /* Rich black, not pure */
      --stationery-accent: #8B9A7D;       /* Sage green - primary accent */
      --stationery-sage: #8B9A7D;         /* Alias for clarity */
      --stationery-watermark: rgba(139, 154, 125, 0.06); /* Faint sage */
      
      /* Borders & Focus */
      --ilya-border-light: #e8e8e8;
      --ilya-border: #e0e0e0;
      --ilya-border-focus: #7a9e7e;
      
      /* Unverified/Inferred State (v5.11.32) */
      --color-muted-border: #c4c4bc;
      --color-muted-text: #6b6b6b;
      
      /* Functional Colors — Muted Sage Accent */
      --ilya-accent: #7a9e7e;
      --ilya-accent-light: rgba(122, 158, 126, 0.1);
      --ilya-accent-hover: #6b8e6f;
      
      /* Legacy accent aliases (terracotta for existing components) */
      --accent: #a85a3a;
      --accent-muted: rgba(168, 90, 58, 0.75);
      
      /* Status Colors */
      --ilya-warning: #d4a373;
      
      /* Fonts */
      --font-mono: 'Courier New', 'Consolas', monospace;
      --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-ipa: 'Doulos SIL', 'Charis SIL', 'Gentium', 'Noto Serif', 'Times New Roman', serif;
      
      /* Paper dimensions (v5.8.2) */
      /* Letter: 8.5in × 11in at 96dpi = 816px × 1056px */
      /* A4: 210mm × 297mm at 96dpi ≈ 794px × 1123px */
      --paper-width: 816px;
      --paper-height: 1056px;
      --paper-aspect: 8.5 / 11;
      
      /* Shadows */
      --ilya-shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      
      /* Legacy shadow aliases */
      --shadow-ambient: 0 1px 2px rgba(26, 22, 18, 0.08);
      --shadow-card: 0 2px 8px rgba(26, 22, 18, 0.1);
      --shadow-paper: 0 2px 12px rgba(26, 22, 18, 0.08);
      --shadow-popup: 0 8px 24px rgba(26, 22, 18, 0.15);
      
      /* Document Container */
      --ilya-doc-radius: 16px;
      --ilya-doc-border: 2px solid var(--ilya-border);
      --ilya-doc-shadow: 0 4px 20px rgba(0,0,0,0.05);
      
      /* Spacing Scale (8px base) */
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      
      /* Typography Scale */
      --text-xs: 12px;
      --text-sm: 14px;
      --text-base: 16px;
      
      /* Animation Timing */
      --duration-fast: 150ms;
      --duration-base: 300ms;
      --ease-out: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      
      /* Legacy */
      --radius: 6px;
      --ease: cubic-bezier(0.34, 0, 0.2, 1);
      --drawer-handle-height: 36px;
    }

    /* ========================================
       RESET & BASE
       ======================================== */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans', system-ui, sans-serif;
      background-color: #e8e4de;
      color: var(--ink-primary);
      line-height: 1.6;
      min-height: 100vh;
      overflow: hidden;
    }

    /* ========================================
       UNIFIED FOCUS SYSTEM
       All interactive elements use 2px sage outline
       ======================================== */
    :focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    :focus:not(:focus-visible) {
      outline: none;
    }
    
    :focus-visible {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    /* Form elements use border + box-shadow instead of outline */
    input:focus,
    textarea:focus,
    select:focus,
    [contenteditable]:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    input:focus:not(:focus-visible),
    textarea:focus:not(:focus-visible),
    select:focus:not(:focus-visible),
    [contenteditable]:focus:not(:focus-visible) {
      box-shadow: none;
      border-color: var(--ilya-border);
    }

    /* ========================================
       DISPLAY CONTAINER: Main app layout
       ======================================== */
    .ilya-layout {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    /* ========================================
       DRAWER: Left-side workbench (v6.0)
       During transition: position fixed to avoid breaking
       existing column layout. Converts to flex sibling
       when old input-drawer is removed in Phase 2.
       ======================================== */
    .ilya-drawer {
      position: fixed;
      left: 0;
      top: 0;
      width: 360px;
      min-width: 320px;
      max-width: 400px;
      height: 100vh;
      background: var(--surface);
      border-right: 1px solid rgba(26, 22, 18, 0.08);
      box-shadow: 4px 0 24px rgba(0, 0, 0, 0.05);
      overflow: hidden;
      transform: translateX(-100%);
      transition: transform 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
      z-index: 10;
      display: flex;
      flex-direction: column;
    }

    .ilya-drawer[data-state="open"] {
      transform: translateX(0);
    }

    /* Drawer internal layout */
    .drawer-header {
      flex-shrink: 0;
      padding: var(--space-lg) var(--space-lg) var(--space-md);
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .drawer-title {
      display: inline-block;
      width: 80px;
      height: 28px;
    }
    .drawer-title svg {
      display: block;
      width: 100%;
      height: 100%;
    }

    .drawer-section-label {
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--ilya-text-secondary);
      margin-bottom: var(--space-md);
      margin-top: var(--space-lg);
    }

    .drawer-section-label:first-child {
      margin-top: 0;
    }

    .drawer-body {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-lg);
      background: var(--ilya-binding);
    }

    /* Breath animation: language swap (v6.0.54, Kimi spec)
       150ms fade-out + lift, 250ms fade-in + settle. Total 400ms.
       Header stays still. Applied to drawer-body, inspector-body, paper-stack. */
    .breath-out {
      animation: breathOut 150ms cubic-bezier(0.25, 0.1, 0.25, 1.0) forwards;
    }
    .breath-in {
      animation: breathIn 250ms cubic-bezier(0.25, 0.1, 0.25, 1.0) forwards;
    }
    @keyframes breathOut {
      from { opacity: 1; transform: translateY(0); }
      to   { opacity: 0; transform: translateY(-2px); }
    }
    @keyframes breathIn {
      from { opacity: 0; transform: translateY(-2px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    /* ========================================
       WELCOME PREFACE (First-run name collection)
       Shows once on first drawer open, then never returns
       ======================================== */
    .welcome-preface {
      margin-bottom: var(--space-lg);
      padding-bottom: var(--space-lg);
      border-bottom: 1px solid var(--ilya-border-light);
    }
    
    .welcome-preface.hidden {
      display: none;
    }
    
    .preface-text {
      font-size: 0.95em;
      letter-spacing: 0.01em;
      color: var(--ilya-text-secondary);
      line-height: 1.5;
      margin: 0 0 var(--space-md) 0;
    }
    
    .preface-field {
      margin-bottom: var(--space-md);
    }
    
    .preface-field input {
      width: 100%;
      padding: 10px 12px;
      font-size: 0.95rem;
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      background: var(--surface);
      color: var(--ink-primary);
    }
    
    .preface-field input:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .preface-field input::placeholder {
      color: var(--ilya-text-muted);
    }
    
    .preface-actions {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    
    .preface-actions .btn-primary {
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 500;
      color: white;
      background: var(--ilya-accent);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 150ms ease;
    }
    
    .preface-actions .btn-primary:hover {
      background: var(--ilya-accent-hover);
    }
    
    .preface-actions .link-secondary {
      font-size: 0.9rem;
      color: var(--ilya-text-muted);
      text-decoration: none;
      cursor: pointer;
      transition: color 150ms ease;
    }
    
    .preface-actions .link-secondary:hover {
      color: var(--ilya-text-secondary);
    }

    /* Internal state containers */
    .drawer-root,
    .drawer-inspector {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition: transform 200ms ease, opacity 200ms ease, visibility 200ms;
      pointer-events: none;
    }

    /* Root state visible */
    .ilya-drawer[data-mode="root"] .drawer-root {
      transform: translateX(0);
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .ilya-drawer[data-mode="root"] .drawer-inspector {
      transform: translateX(20px);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Drill/inspect state visible */
    .ilya-drawer[data-mode="inspect"] .drawer-root {
      transform: translateX(-20px);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .ilya-drawer[data-mode="inspect"] .drawer-inspector {
      transform: translateX(0);
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    /* Inspector Header (Phase 3A) */
    .inspector-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      border-bottom: 1px solid var(--ilya-border-light);
      background: var(--surface);
    }

    .inspector-header .back-btn {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      background: var(--surface);
      color: var(--ilya-text-secondary);
      font-size: 18px;
      cursor: pointer;
      transition: all 150ms ease;
      flex-shrink: 0;
    }

    .inspector-header .back-btn:hover {
      background: var(--ilya-binding);
      border-color: var(--ilya-border-focus);
      color: var(--ilya-text-primary);
    }

    .inspector-header .inspector-word {
      font-family: 'Noto Serif', serif;
      font-size: 1.25rem;
      font-weight: 500;
      color: var(--ilya-text-primary);
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }


    /* Inspector Body (Phase 3B) */
    .inspector-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }

    /* Syllable Label (monosyllable/clitic context) */
    .inspector-syllable-label {
      font-size: 12px;
      color: var(--ilya-text-muted);
      text-align: center;
      margin-bottom: 8px;
    }

    .inspector-syllable-label:empty {
      display: none;
    }

    /* Syllable Buttons Container */
    .inspector-syllable-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      margin-bottom: 12px;
    }

    .inspector-syllable-display {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    /* Syllable buttons in drawer - reuse existing .syllable-btn styles */
    .inspector-syllable-display .syllable-btn {
      font-family: var(--font-ipa);
      font-size: 1.1rem;
      padding: 8px 12px;
    }

    /* Boundary reset button in drawer */
    .inspector-syllable-header .boundary-reset-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      border: 1px solid var(--ilya-border);
      border-radius: 4px;
      background: var(--surface);
      color: var(--ilya-text-muted);
      cursor: pointer;
      transition: all 150ms ease;
      margin-left: 8px;
    }

    .inspector-syllable-header .boundary-reset-btn:hover {
      background: var(--ilya-binding);
      border-color: var(--ilya-accent);
      color: var(--ilya-text-primary);
    }

    /* Cyrillic Display */
    .inspector-cyrillic {
      font-family: 'Noto Serif', serif;
      font-size: 1.25rem;
      font-weight: 500;
      color: var(--ink-primary);
      text-align: center;
      margin-bottom: 12px;
    }

    /* Gloss Section */
    .inspector-gloss-section {
      text-align: center;
      margin-bottom: 8px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--ilya-border-light);
    }

    .inspector-gloss-inline {
      font-family: 'Noto Serif', serif;
      font-size: 0.95rem;
      font-style: italic;
      color: var(--ilya-accent);
      padding: 8px 16px;
      border-radius: 6px;
      display: inline-block;
      min-width: 120px;
      background-color: var(--ilya-accent-light);
      border: none;
      transition: all 150ms var(--ease);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px);
      background-size:
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position:
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:hover {
      background-color: rgba(122, 158, 126, 0.15);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px);
      background-size:
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position:
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:focus {
      outline: none;
      background-color: rgba(122, 158, 126, 0.15);
      border: 2px solid var(--ilya-accent);
      background-image: none;
      box-shadow: 0 0 0 2px var(--ilya-accent-light);
    }

    .inspector-gloss-inline:not(:empty) {
      background: transparent;
      border-color: transparent;
      color: var(--ilya-accent);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px);
      background-size: 100% 2px;
      background-position: 0 100%;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:not(:empty):hover {
      background-color: var(--ilya-accent-light);
      background-image:
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px);
      background-size: 100% 2px;
      background-position: 0 100%;
      background-repeat: no-repeat;
    }

    .inspector-gloss-inline:empty::before {
      content: attr(data-placeholder);
      color: var(--ilya-accent);
      opacity: 0.7;
      font-style: italic;
    }

    /* Ribbon Section (Phase 3C) */
    /* REFINEMENTS v6.0.18: Fixes from testing */
    .inspector-ribbon-section {
      margin-bottom: 16px;
    }

    /* Drawer ribbon inherits .ribbon-vertical styles but needs drawer-specific adjustments */
    .inspector-ribbon.ribbon-vertical {
      padding: 0;
      border-radius: 8px;
      background: var(--ilya-binding);
    }

    /* Refinement 1: Condensed row spacing - 48px height, hairline separators */
    .inspector-ribbon .phoneme-row {
      min-height: 48px;
      padding: 0 12px;
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
    }

    .inspector-ribbon .phoneme-row:last-child {
      border-bottom: none;
    }

    /* Refinement 3: Remove fading - trust user attention */
    /* Higher specificity to override base .ribbon-vertical rules */
    .inspector-ribbon.ribbon-vertical.has-active-blurb .phoneme-row:not(.expanded),
    .inspector-ribbon.ribbon-vertical .phoneme-row:not(.expanded),
    .inspector-ribbon .phoneme-row:not(.expanded) {
      opacity: 1 !important;
    }
    
    /* Remove sage background from expanded rows in drawer */
    /* NO PERIMETER on expanded rows - perimeters are ONLY for stressed syllables */
    #ilyaDrawer .inspector-ribbon .phoneme-row.expanded,
    .ilya-drawer .inspector-ribbon .phoneme-row.expanded,
    .inspector-ribbon .phoneme-row.expanded,
    .inspector-ribbon.ribbon-vertical .phoneme-row.expanded {
      background: transparent !important;
      border: none !important;
      border-width: 0 !important;
      outline: none !important;
      box-shadow: none !important;
    }
    
    /* Remove focus outline from rows inside drawer - prevents nested perimeters */
    .inspector-ribbon .phoneme-row:focus,
    .inspector-ribbon .phoneme-row.expanded:focus {
      outline: none !important;
    }

    /* Refinement 2: Blurb simplification - HIDDEN by default, NO PERIMETER */
    /* RULE: Perimeters identify STRESSED SYLLABLES only. Blurbs have NO border. */
    /* Override all base overlay styles for drawer context */
    /* Using maximum specificity to ensure override */
    #ilyaDrawer .inspector-ribbon .phoneme-blurb-overlay,
    .ilya-drawer .inspector-ribbon .phoneme-blurb-overlay,
    .inspector-ribbon .phoneme-blurb-overlay {
      position: relative !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      max-height: 0 !important;
      overflow: hidden !important;
      background: transparent !important;
      border: none !important;
      border-width: 0 !important;
      border-style: none !important;
      outline: none !important;
      box-shadow: none !important;
      padding: 12px 0 8px 48px !important; /* Set immediately - no transition */
      margin: 0 !important;
      opacity: 0 !important;
      visibility: hidden !important;
      transform: none !important;
      pointer-events: none !important;
      min-height: 0 !important;
      z-index: auto !important;
      border-radius: 0 !important;
      /* Collapse: fast */
      transition: max-height 200ms ease-in,
                  opacity 150ms ease,
                  visibility 0ms linear 200ms,
                  margin 200ms ease-in !important;
    }

    /* Expanded blurb - soft, welcoming fade-in after row fully expands */
    /* Phase 3C timing: 350ms expand, 400ms fade starting at 300ms */
    #ilyaDrawer .inspector-ribbon .phoneme-row.expanded .phoneme-blurb-overlay,
    .ilya-drawer .inspector-ribbon .phoneme-row.expanded .phoneme-blurb-overlay,
    .inspector-ribbon .phoneme-row.expanded .phoneme-blurb-overlay {
      max-height: 800px !important;
      margin-top: 4px !important;
      background: transparent !important;
      border: none !important;
      border-width: 0 !important;
      border-style: none !important;
      outline: none !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
      overflow-y: auto !important;
      /* Phase 3C approved: 350ms stately expand, 400ms fade starting at 300ms */
      transition: max-height 350ms cubic-bezier(0.25, 0.46, 0.45, 0.94),
                  opacity 400ms ease-in-out 300ms,
                  visibility 0ms linear 0ms,
                  margin 350ms cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
    }

    .inspector-ribbon .phoneme-blurb-overlay .blurb-text {
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--ilya-text-secondary);
      margin-bottom: 6px;
    }

    .inspector-ribbon .phoneme-blurb-overlay .blurb-citation {
      font-size: 0.8rem;
      font-style: italic;
      color: var(--accent-muted, rgba(168, 90, 58, 0.75));
    }

    .inspector-ribbon .phoneme-blurb-overlay .blurb-citation::before {
      content: '— ';
    }

    /* Refinement 4: Stressed syllable - 2px sage perimeter, NO fill */
    .inspector-ribbon .stressed-syllable-region {
      background: transparent !important;
      border: 2px solid var(--ilya-accent);
      border-radius: 6px;
      padding: 4px;
      margin: 8px 0;
    }

    .inspector-ribbon .stressed-syllable-region:first-child {
      margin-top: 0;
    }

    /* Rows inside stressed region don't need extra bottom border at region edge */
    .inspector-ribbon .stressed-syllable-region .phoneme-row:last-child {
      border-bottom: none;
    }

    /* Cluster groups in drawer */
    .inspector-ribbon .cluster-group {
      margin: 4px 0;
    }

    /* Refinement 5: Clitic arrow styling */
    .inspector-ribbon .clitic-arrow-row {
      min-height: 48px;
      padding: 0 12px;
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
      display: flex;
      align-items: center;
      cursor: pointer;
      border-radius: 4px;
      transition: background 150ms ease;
    }

    .inspector-ribbon .clitic-arrow-row:hover {
      background: rgba(122, 158, 126, 0.06);
    }

    .inspector-ribbon .clitic-arrow-row:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 1px;
    }

    .inspector-ribbon .clitic-arrow-row .arrow-symbol {
      font-size: 1.25em;
      color: var(--ilya-accent);
      opacity: 0.7;
      width: 28px;
      text-align: center;
    }

    .inspector-ribbon .clitic-arrow-row .arrow-label {
      font-size: 0.85rem;
      color: var(--ilya-text-muted);
      margin-left: 8px;
    }

    .inspector-ribbon .clitic-arrow-row.expanded {
      background: rgba(122, 158, 126, 0.1);
    }

    /* ========================================
       PHASE 4A: Word-to-Word Content Morph
       250ms cross-fade with sage highlight
       on changed phonemes
       ======================================== */
    
    /* Inspector body morph animation */
    .inspector-body.morphing {
      opacity: 0;
      transform: translateY(4px);
    }
    
    .inspector-body {
      transition: opacity 125ms ease-out, transform 125ms ease-out;
    }
    
    .inspector-body.morph-in {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Sage highlight for changed phonemes */
    .phoneme-row.phoneme-changed,
    .cluster-group.phoneme-changed {
      animation: sage-pulse 400ms ease-out;
    }
    
    @keyframes sage-pulse {
      0% {
        background-color: rgba(122, 158, 126, 0.25);
        box-shadow: inset 0 0 0 2px var(--ilya-accent);
      }
      100% {
        background-color: transparent;
        box-shadow: inset 0 0 0 2px transparent;
      }
    }

    /* Controls Section (Phase 3D) */
    .inspector-controls {
      display: flex;
      flex-direction: column;
      padding: 16px 0;
      margin-top: 8px;
      border-top: 1px solid rgba(26, 22, 18, 0.06);
      min-height: 120px; /* Ensures spacer has room to work */
    }
    
    .inspector-control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 16px;
      margin-bottom: 8px;
      background: var(--ilya-binding);
      border-radius: 8px;
    }
    
    .inspector-control-row:last-of-type {
      margin-bottom: 0;
    }
    
    .inspector-control-label {
      font-size: 0.85rem;
      color: var(--ilya-text-secondary);
      flex-shrink: 0;
      margin-right: 12px;
    }
    
    /* Spacer pushes assimilation row to bottom */
    .inspector-controls-spacer {
      flex-grow: 1;
      min-height: 8px;
    }
    
    /* Stress source row - proximity-grouped below syllable buttons */
    .inspector-stress-source-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      padding: 8px 16px;
      margin-bottom: 8px;
    }

    .inspector-stress-source-row.hidden {
      display: none;
    }
    
    .inspector-stress-source-row .inspector-control-label {
      font-size: 0.75rem;
      color: var(--ilya-text-muted);
      white-space: nowrap;
    }

    .inspector-stress-source-control {
      display: flex;
      gap: 2px;
    }
    
    .inspector-stress-source-control .segment {
      padding: 6px 10px;
      font-size: 0.75rem;
    }

    /* Pulsating attribution arrow */
    .stress-attribution-arrow {
      display: none;
      color: var(--ilya-accent);
      font-size: 1.1rem;
      margin-left: 4px;
    }

    .inspector-stress-source-row.pending-attribution .stress-attribution-arrow {
      display: inline-block;
      animation: pulse-arrow 1.5s ease-in-out infinite;
    }

    @keyframes pulse-arrow {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    /* Variant row (ё toggle) - sage accent when ё active */
    .inspector-variant-row {
      flex-direction: column;
      padding: 0;
      overflow: hidden;
    }
    
    .variant-row-main {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      padding: 10px 16px;
    }
    
    .inspector-variant-control {
      display: flex;
      gap: 4px;
    }
    
    .inspector-variant-control .segment {
      min-width: 40px;
      padding: 6px 14px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .inspector-variant-control .segment[data-variant="yo"].active {
      background: var(--ilya-accent);
      color: white;
    }
    
    .inspector-variant-control .segment[data-variant="ye"].active {
      background: var(--ilya-text-muted);
      color: white;
    }
    
    /* Staged state - dashed outline indicates pending */
    .inspector-variant-control .segment.staged {
      background: white;
      outline: 2px dashed var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* Confirmation row - slides in below */
    .variant-confirm-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      padding: 0 16px;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: max-height 200ms ease-out, opacity 150ms ease, padding 200ms ease-out;
    }
    
    .variant-confirm-row.visible {
      max-height: 80px;
      opacity: 1;
      padding: 0 16px 12px 16px;
    }
    
    .variant-confirm-text {
      font-size: 0.8rem;
      color: var(--ilya-text-secondary);
      line-height: 1.4;
    }
    
    .variant-confirm-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    
    .variant-cancel-btn,
    .variant-apply-btn {
      padding: 5px 12px;
      font-size: 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms ease;
    }
    
    .variant-cancel-btn {
      background: transparent;
      border: 1px solid var(--ilya-border);
      color: var(--ilya-text-secondary);
    }
    
    .variant-cancel-btn:hover {
      border-color: var(--ilya-text-secondary);
    }
    
    .variant-apply-btn {
      background: var(--ilya-accent);
      border: none;
      color: white;
    }
    
    .variant-apply-btn:hover {
      background: var(--ilya-accent-hover);
    }
    
    /* Assimilation row - footer-docked, de-emphasized */
    .inspector-assimilation-row {
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      background: rgba(245, 245, 240, 0.6); /* Lighter than other controls */
      border-top: 1px solid rgba(26, 22, 18, 0.06);
      margin-top: auto; /* Ensures docking to bottom */
      margin-bottom: 0;
      padding: 10px 16px;
    }
    
    .inspector-assimilation-row .inspector-control-label {
      font-size: 0.85rem;
      margin-right: 0;
      margin-bottom: 0;
    }
    
    .inspector-assimilation-row.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    
    .inspector-assimilation-control {
      display: flex;
      gap: 4px;
      align-self: flex-end;
    }
    
    .inspector-assimilation-control .segment {
      padding: 6px 16px;
      font-size: 0.8rem;
      min-width: 48px;
    }
    
    /* Committed state for user selections */
    .inspector-controls .segment.committed {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      outline: 1px solid var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* Toast notification for ё warning */
    .inspector-yo-toast {
      position: sticky;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 0 16px;
      background: var(--ilya-text-primary);
      color: white;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: max-height 200ms var(--ease), opacity 200ms var(--ease), padding 200ms var(--ease);
      border-radius: 8px;
      margin-top: 12px;
    }
    
    .inspector-yo-toast.visible {
      max-height: 60px;
      opacity: 1;
      padding: 10px 16px;
    }
    
    .inspector-yo-toast .undo-btn {
      background: transparent;
      border: 1px solid white;
      color: white;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 150ms;
    }
    
    .inspector-yo-toast .undo-btn:hover {
      background: rgba(255,255,255,0.15);
    }

    /* Scrim: tablet overlay mode only */
    .drawer-scrim {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(26, 22, 18, 0.1);
      z-index: 9;
    }

    /* Tablet: drawer overlays paper (same as desktop during transition) */
    @media (min-width: 601px) and (max-width: 899px) {
      .ilya-drawer {
        z-index: 100;
      }

      .ilya-drawer[data-state="open"] ~ .drawer-scrim {
        display: block;
      }
    }

    /* Mobile: bottom sheet (Phase 5A) */
    @media (max-width: 600px) {
      .ilya-drawer {
        top: auto;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        max-width: 100%;
        min-width: 100%;
        height: auto;
        max-height: 70vh;
        border-right: none;
        border-top: 1px solid rgba(26, 22, 18, 0.08);
        border-radius: 16px 16px 0 0;
        box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.05);
        transform: translateY(100%);
        z-index: 100;
      }

      .ilya-drawer[data-state="open"] {
        transform: translateY(0);
      }

      .ilya-drawer[data-state="open"] ~ .drawer-scrim {
        display: block;
      }
      
      /* Drag handle: visible only on mobile */
      .drawer-drag-handle {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 12px 0 8px;
        cursor: grab;
        touch-action: none;
      }
      
      .drawer-drag-handle:active {
        cursor: grabbing;
      }
      
      .drag-handle-bar {
        width: 36px;
        height: 4px;
        background: rgba(26, 22, 18, 0.2);
        border-radius: 2px;
      }
      
      /* Adjust drawer header for mobile */
      .drawer-header {
        padding-top: 0;
      }
      
      /* Drawer body needs overflow for scrolling */
      .drawer-root .drawer-body,
      .drawer-inspector .inspector-body {
        max-height: calc(70vh - 100px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      /* Textarea sizing for mobile */
      .drawer-textarea {
        min-height: 120px;
        max-height: 150px;
      }
      
      /* Language pill needs no mobile override — 52×24px is touch-accessible */
      
      /* Phase 5B: Mobile Drill state (Inspector) */
      
      /* Compact inspector header */
      .drawer-inspector .drawer-header {
        padding: 8px 16px;
        gap: 8px;
      }
      
      .drawer-inspector .inspector-word-display {
        font-size: 1.1rem;
      }
      
      /* Syllable buttons: horizontal scroll on mobile */
      .inspector-syllable-display {
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        gap: 6px;
        padding-bottom: 4px;
      }
      
      .inspector-syllable-display .syllable-btn {
        flex-shrink: 0;
        min-width: 44px;
        padding: 6px 10px;
        font-size: 0.9rem;
      }
      
      /* Compact ribbon for mobile */
      .inspector-ribbon .phoneme-row {
        padding: 8px 12px;
      }
      
      .inspector-ribbon .phoneme-row .ipa-cell {
        font-size: 1.1rem;
      }
      
      .inspector-ribbon .phoneme-row .cyrillic-cell {
        font-size: 0.85rem;
      }
      
      /* Control modules: stack vertically on mobile */
      .inspector-controls {
        flex-direction: column;
        gap: 12px;
      }
      
      .inspector-controls .control-row {
        flex-wrap: wrap;
      }
      
      /* Blurb text sizing for mobile */
      .inspector-ribbon .phoneme-blurb-overlay .blurb-text {
        font-size: 0.85rem;
        line-height: 1.5;
      }
    }
    
    /* Drag handle: hidden on desktop/tablet */
    @media (min-width: 601px) {
      .drawer-drag-handle {
        display: none;
      }
    }

    /* Print: hide drawer entirely */
    @media print {
      .ilya-drawer,
      .drawer-scrim {
        display: none !important;
      }
    }

    /* ========================================
       PAPER APERTURE: Viewing area with inset depth
       ======================================== */
    .paper-aperture {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
      min-height: 0; /* Flex child needs this to scroll */
      transition: transform 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
    }

    /* Paper shifts right when drawer opens (desktop ≥900px) */
    @media (min-width: 900px) {
      .ilya-layout.drawer-open .paper-aperture {
        transform: translateX(clamp(120px, 20vw, 180px));
      }
    }

    /* ========================================
       PAPER: Document simulation (v5.9.1)
       Supports Letter (8.5×11) and A4 (210×297mm)
       Height-constrained with aspect-ratio calculating width
       ======================================== */
    .paper {
      /* Height is the constraining dimension; aspect-ratio calculates width */
      height: min(var(--paper-height), 80vh);
      aspect-ratio: var(--paper-aspect);
      max-width: calc(100% - 3rem);
      background: var(--surface);
      box-shadow: var(--shadow-paper);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
      margin: 1.5rem auto;
      transition: aspect-ratio 300ms ease-out, 
                  height 300ms ease-out;
      
      /* Ghosted scrollbar (Calm Authority) */
      scrollbar-width: thin;
      scrollbar-color: rgba(74, 69, 64, 0.2) transparent;
    }
    
    /* WebKit ghosted scrollbar */
    .paper::-webkit-scrollbar {
      width: 6px;
    }
    
    .paper::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .paper::-webkit-scrollbar-thumb {
      background: rgba(74, 69, 64, 0.2);
      border-radius: 3px;
    }
    
    .paper::-webkit-scrollbar-thumb:hover {
      background: rgba(74, 69, 64, 0.35);
    }
    
    /* A4 paper size */
    .paper[data-size="a4"] {
      --paper-width: 794px;
      --paper-height: 1123px;
      --paper-aspect: 210 / 297;
    }
    
    /* Post-animation content fade (for reflow) */
    .paper.reflowing .doc-body {
      opacity: 0.8;
      transition: opacity 100ms ease-out;
    }

    @media print {
      .paper {
        width: 8.5in;
        height: 11in;
        margin: 0;
        box-shadow: none;
        overflow: visible;
      }
      
      .paper[data-size="a4"] {
        width: 210mm;
        height: 297mm;
      }
    }

    /* Loading state */
    .paper.rendering {
      opacity: 0.7;
      transition: opacity 100ms ease;
    }

    /* ========================================
       PAGE TEMPLATES (v5.9.4)
       Multi-page stationery design
       ======================================== */
    
    /* Container for multiple pages */
    .paper-stack {
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 24px;
    }
    
    /* Individual page */
    .paper-page {
      width: min(var(--paper-width), 100% - 3rem);
      min-height: var(--paper-height);
      aspect-ratio: var(--paper-aspect);
      background: var(--stationery-cream);
      box-shadow: 0 2px 4px rgba(26, 22, 18, 0.08);
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      position: relative;
      overflow: hidden;  /* Prevent content bleed between pages (v5.11.9) */
      
      /* GPU acceleration for shadow performance */
      transform: translateY(0);
      will-change: transform;
    }
    
    /* A4 variant */
    .paper-page[data-size="a4"] {
      --paper-width: 794px;
      --paper-height: 1123px;
      --paper-aspect: 210 / 297;
    }
    
    /* ----------------------------------------
       PAGE 1: TITLE TEMPLATE
       ---------------------------------------- */
    .paper-page[data-template="title"] {
      /* Structure defined by children */
    }
    
    /* Bracket logo [ Ilya ] */
    .page-logo {
      position: absolute;
      top: 48px;
      left: 72px;
      font-size: 18px;
      color: var(--stationery-sage);
      display: flex;
      align-items: baseline;
      gap: 2px;
    }
    
    .page-logo .bracket {
      font-family: var(--font-mono);
      font-weight: 600;
    }
    
    .page-logo .logo-name {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-style: italic;
      font-weight: normal;
      letter-spacing: 0.5px;
    }
    
    /* Title header block */
    .page-header-title {
      padding: 72px 72px 16px;
      text-align: left;
    }
    
    .page-title {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-size: 28px;
      font-weight: normal;
      color: var(--stationery-ink);
      margin: 0 0 16px 0;
      letter-spacing: 0.5px;
    }
    
    .page-metadata {
      font-family: var(--font-sans);
      font-size: 11px;
      font-weight: 500;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    
    .page-metadata .divider {
      color: var(--stationery-sage);
      font-weight: 300;
    }
    
    .page-metadata-rule {
      width: 200px;
      height: 1px;
      background: var(--stationery-sage);
      margin-top: 16px;
      border: none;
    }
    
    /* ----------------------------------------
       PAGES 2+: SUBSEQUENT TEMPLATE
       ---------------------------------------- */
    .paper-page[data-template="subsequent"] {
      /* Structure defined by children */
    }
    
    /* Faint bracket watermark */
    .paper-page[data-template="subsequent"]::before {
      content: "[ ]";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--font-mono);
      font-size: 48px;
      font-weight: 300;
      color: var(--stationery-watermark);
      letter-spacing: 8px;
      pointer-events: none;
    }
    
    /* Running header */
    .page-header-running {
      padding: 36px 72px 8px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      border-bottom: 1px solid var(--stationery-sage);
      margin: 0 72px;
      padding-left: 0;
      padding-right: 0;
    }
    
    .running-title {
      font-family: var(--font-sans);
      font-size: 10px;
      font-weight: 600;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    /* ----------------------------------------
       PAGE CONTENT AREA
       ---------------------------------------- */
    .page-content {
      flex: 1;
      padding: 16px 72px;
      padding-bottom: 120px; /* Clearance for absolute footer (reduced from 150px in v5.11.17) */
      display: flex;
      flex-direction: column;
    }
    
    .page-content.empty {
      justify-content: center;
      align-items: center;
    }
    
    .page-ghost-text {
      color: var(--ink-secondary);
      opacity: 0.25;
      font-style: italic;
      font-family: var(--font-sans);
      font-size: 14px;
      text-align: center;
    }
    
    /* ----------------------------------------
       PAGE FOOTER (v5.9.6)
       2/3 attribution left, 1/3 pagination right
       Positioned absolutely at bottom of page
       ---------------------------------------- */
    .page-footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px 72px 32px;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 24px;
      align-items: end;
      background: var(--stationery-cream);
    }
    
    .footer-attribution {
      font-family: var(--font-sans);
      font-size: 8px;
      line-height: 1.5;
      color: var(--ink-secondary);
      max-width: 100%;
    }
    
    .footer-attribution p {
      margin: 0 0 4px 0;
    }
    
    .footer-attribution p:last-child {
      margin-bottom: 0;
    }
    
    .footer-pagination {
      font-family: var(--font-sans);
      font-size: 10px;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: right;
      white-space: nowrap;
    }
    
    /* ----------------------------------------
       PRINT STYLES FOR PAGES
       ---------------------------------------- */
    @media print {
      .paper-stack {
        gap: 0;
        padding: 0;
      }
      
      /* Note: Main print styles for .paper-page are in the comprehensive 
         @media print block below (around line 2650+) */
      
      .paper-page::before {
        /* Keep bracket logo but not watermark */
      }
      
      .paper-page[data-template="subsequent"]::before {
        display: none; /* Hide watermark in print */
      }
    }
    
    /* ----------------------------------------
       MOBILE: HORIZONTAL SWIPE
       ---------------------------------------- */
    @media (max-width: 768px) {
      .paper-stack {
        flex-direction: row;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        gap: 0;
        padding: 16px;
      }
      
      .paper-page {
        flex: 0 0 calc(100vw - 32px);
        scroll-snap-align: center;
        margin: 0 8px;
      }
    }

    /* Content area fills available space */
    .paper .doc-body {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .paper .verse-container {
      flex: 1;
    }

    /* ========================================
       DOCUMENT HEADER (Legacy - single page)
       ======================================== */
    .doc-header {
      padding: 72px 72px 24px;
      text-align: center;
      position: relative;
    }

    .doc-header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 72px;
      right: 72px;
      height: 1px;
      background: rgba(26, 22, 18, 0.1);
    }

    .doc-composer-line {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-top: 1rem;
    }

    .doc-composer {
      font-family: 'Noto Serif', serif;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--ink-secondary);
    }

    .doc-composer .dates {
      font-weight: 400;
      color: var(--ink-secondary);
      opacity: 0.8;
    }

    .doc-poet {
      font-family: 'Noto Serif', serif;
      font-size: 0.9rem;
      color: var(--ink-secondary);
    }

    .doc-poet .dates {
      color: var(--ink-secondary);
      opacity: 0.8;
    }

    .doc-title {
      font-family: 'Noto Serif', serif;
      font-size: 1.5rem;
      font-style: italic;
      font-weight: 400;
      color: var(--ink-primary);
      margin: 0 0 0.25rem 0;
    }

    .doc-opus {
      font-family: 'Noto Serif', serif;
      font-size: 0.9rem;
      color: var(--ink-secondary);
    }

    /* Placeholder text: greyed, italic, replaced by real content */
    .placeholder-text {
      font-style: italic;
      opacity: 0.35;
    }

    /* Hide placeholder when real content exists */
    .doc-composer:not(:empty) .placeholder-text,
    .doc-poet:not(:empty) .placeholder-text,
    .doc-title:not(:empty) .placeholder-text,
    .doc-opus:not(:empty) .placeholder-text {
      /* JS will remove placeholder spans when content is added */
    }

    /* ========================================
       DOCUMENT BODY
       ======================================== */
    .doc-body {
      flex: 1;
      padding: 24px 72px;
    }
    
    .verse-container {
      max-width: 100%;
    }

    /* ========================================
       DOCUMENT FOOTER
       ======================================== */
    .doc-footer {
      padding: 24px 72px 48px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-family: 'Noto Serif', serif;
      font-size: 0.8rem;
      color: var(--ink-secondary);
      position: relative;
    }

    .doc-footer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 72px;
      right: 72px;
      height: 1px;
      background: rgba(26, 22, 18, 0.1);
    }

    .doc-footer .attribution {
      font-style: italic;
    }

    /* ========================================
       VERSE LINE
       ======================================== */
    .verse-line {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 0.625rem; /* Column gap reduced from 1.5rem for density (v5.11.18) */
      align-items: flex-start;
      padding: 0.45rem 0;
      border-bottom: 1px solid rgba(26, 22, 18, 0.06);
      width: 100%;
    }

    .verse-line:last-child {
      border-bottom: none;
    }

    /* ========================================
       WORD STACK
       ======================================== */
    .word-stack {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.1rem;
      padding: 0.35rem 0.5rem 0.35rem 0;
      cursor: pointer;
      border-radius: var(--radius);
      transition: background 150ms var(--ease);
      flex-shrink: 0;
    }
    
    .word-stack:hover {
      background: rgba(168, 90, 58, 0.06);
    }

    .word-stack:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    /* Vowelless clitics: reduced gap (4px) to visually connect with host (v5.11.19) */
    .word-stack.vowelless-clitic.proclitic {
      margin-right: -0.375rem; /* Reduces 10px gap to 4px before host */
    }
    .word-stack.vowelless-clitic.enclitic {
      margin-left: -0.375rem; /* Reduces 10px gap to 4px after host */
    }

    .word-stack[aria-selected="true"] {
      background: var(--ilya-accent-light);
    }

    .word-stack .ipa {
      font-family: 'Charis SIL', 'Doulos SIL', 'Noto Serif', 'DejaVu Sans', serif;
      font-size: 1rem;
      color: var(--ink-secondary);
      letter-spacing: 0.01em;
    }

    .word-stack .cyrillic {
      font-family: 'Noto Serif', serif;
      font-size: 1rem;
      font-weight: 500;
      color: var(--ink-primary);
    }

    .word-stack .punct {
      color: var(--ink-secondary);
      opacity: 0.7;
    }

    .word-stack .gloss {
      font-family: 'Noto Serif', serif;
      font-size: 0.8rem;
      font-style: italic;
      color: var(--accent-muted);
      min-height: 1.1em;
      min-width: 1em;
    }

    .word-stack.proclitic .cyrillic,
    .word-stack.enclitic .cyrillic {
      font-weight: 500;
    }
    
    /* Clitics show directional arrows — normal spacing (v5.11.10) */
    
    /* ----------------------------------------
       UNVERIFIED STRESS: "Verify" Treatment (v5.11.32)
       Dashed box with smallcaps label for inferred stress
       ---------------------------------------- */
    .stress-unverified-container {
      position: relative;
      display: inline-flex;
      align-items: center;
      border-radius: 3px;
      padding: 3px 8px 12px 6px; /* Extra bottom padding for label */
      background-color: rgba(245, 244, 240, 0.3);
      cursor: pointer;
      transition: background-color 0.15s ease;
      
      /* Custom dashed border: 16px dash, 6px gap */
      /* Four gradient layers: top, bottom, left, right edges */
      background-image: 
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-border) 0, var(--color-muted-border) 16px, transparent 16px, transparent 22px);
      background-size: 
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position: 
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }
    
    .stress-unverified-container:hover {
      background-color: rgba(245, 244, 240, 0.6);
      /* Darken dashes on hover */
      background-image: 
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to right, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px),
        repeating-linear-gradient(to bottom, var(--color-muted-text) 0, var(--color-muted-text) 16px, transparent 16px, transparent 22px);
      background-size: 
        100% 2px,
        100% 2px,
        2px 100%,
        2px 100%;
      background-position: 
        0 0,
        0 100%,
        0 0,
        100% 0;
      background-repeat: no-repeat;
    }
    
    .stress-unverified-container .word-stack {
      /* Reset word-stack padding when inside container */
      padding: 0;
    }
    
    .stress-unverified-label {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translate(-50%, 50%);
      font-family: var(--font-sans);
      font-variant: small-caps;
      font-size: 0.6rem;
      letter-spacing: 0.08em;
      color: var(--color-muted-text);
      background-color: var(--stationery-cream);
      padding: 0 4px;
      line-height: 1;
      pointer-events: none;
    }
    
    /* Print/PDF: hide Verify boxes, show clean content */
    @media print {
      .stress-unverified-container {
        padding: 0;
        background: transparent;
        background-image: none;
      }
      .stress-unverified-label {
        display: none;
      }
    }

    /* ========================================
       INPUT DRAWER: REMOVED Phase 2C
       All input now in left drawer
       ======================================== */
    /*
    .input-drawer {
      flex-shrink: 0;
      background: var(--surface);
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
    }
    */

    /* ========================================
       DRAWER HANDLE: REMOVED Phase 2C
       ======================================== */
    /*
    .drawer-handle {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      height: var(--drawer-handle-height);
      background: #f0f0f0;
      cursor: pointer;
      user-select: none;
      transition: background 150ms var(--ease);
    }

    .drawer-handle:hover {
      background: #e8e8e8;
    }

    .drawer-handle:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: -2px;
    }

    .handle-preview {
      position: absolute;
      left: var(--space-lg);
      font-family: 'Noto Serif', serif;
      font-size: 0.85rem;
      color: var(--ink-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 40%;
      opacity: 0;
      transition: opacity 200ms var(--ease);
    }

    .input-drawer.collapsed .handle-preview {
      opacity: 1;
    }

    .handle-toggle {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .handle-toggle .chevron {
      width: 14px;
      height: 14px;
      stroke: var(--ink-secondary);
      stroke-width: 2;
      fill: none;
      opacity: 0.6;
      transition: transform 200ms var(--ease);
    }

    .handle-toggle .handle-label {
      font-size: 0.7rem;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--ink-secondary);
      opacity: 0.6;
    }

    .handle-label-more,
    .handle-label-less {
      display: none;
    }

    .input-drawer.expanded .handle-label-less {
      display: inline;
    }

    .input-drawer.expanded .handle-label-more {
      display: none;
    }

    .input-drawer.collapsed .handle-label-more {
      display: inline;
    }

    .input-drawer.collapsed .handle-label-less {
      display: none;
    }

    .input-drawer.collapsed .handle-toggle .chevron {
      transform: rotate(180deg);
    }
    */

    /* ========================================
       OLD DRAWER CONTENT: REMOVED Phase 2C
       ======================================== */
    /*
    .drawer-content {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      transition: opacity 200ms var(--ease);
    }

    .input-drawer.collapsed .drawer-content {
      display: none;
    }
    */

    /* ========================================
       DRAWER: Textarea
       ======================================== */
    .drawer-textarea {
      width: 100%;
      height: 360px;
      min-height: 120px;
      padding: 0.75rem;
      padding-right: 2.75rem; /* space for OCR icon */
      font-family: monospace;
      font-size: 0.95rem;
      line-height: 1.6;
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: var(--radius);
      resize: vertical;
      transition: border-color 150ms var(--ease);
    }

    .drawer-textarea:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }

    .drawer-textarea::placeholder {
      color: var(--ilya-text-muted);
      opacity: 0.7;
    }

    /* Textarea wrapper (positions OCR overlay) */
    .textarea-wrapper {
      position: relative;
    }

    /* OCR icon: top-right corner inside textarea */
    .ocr-overlay-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      opacity: 0.6;
      color: var(--ilya-text-secondary);
      transition: opacity 200ms var(--ease), color 200ms var(--ease), transform 200ms var(--ease);
      z-index: 2;
    }

    .textarea-wrapper:hover .ocr-overlay-btn,
    .drawer-textarea:focus ~ .ocr-overlay-btn {
      opacity: 1;
    }

    .ocr-overlay-btn:hover {
      color: var(--ilya-accent);
      transform: scale(1.05);
    }

    .ocr-overlay-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none;
    }

    .ocr-overlay-btn:disabled:hover {
      color: var(--ilya-text-secondary);
    }

    /* ========================================
       DRAWER: Footer (status + buttons)
       ======================================== */
    .drawer-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: var(--space-md);
    }

    .footer-status {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      font-size: 0.75rem;
      color: var(--ink-secondary);
    }

    .char-counter {
      opacity: 0;
      visibility: hidden;
      min-width: 7ch;
      display: inline-block;
      transition: opacity 200ms var(--ease), visibility 200ms var(--ease);
    }

    .char-counter::after {
      content: '\200b';
    }

    .char-counter.visible {
      opacity: 1;
      visibility: visible;
    }

    .char-counter.warning {
      color: #b45309;
    }

    .char-counter.error {
      color: #dc2626;
    }

    .auto-saved {
      opacity: 0;
      transition: opacity 200ms var(--ease);
    }

    .auto-saved.visible {
      opacity: 0.7;
    }

    /* OCR Status */
    .ocr-status {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      color: var(--ink-secondary);
    }

    .ocr-status.error {
      color: #c75d5d;
    }

    .ocr-status.success {
      color: var(--ilya-accent);
    }

    .ocr-status .spinner {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Scan button icon alignment */
    #ocrScanBtn {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    #ocrScanBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .footer-actions {
      display: flex;
      gap: var(--space-sm);
    }

    /* Drawer-specific input section layout */
    .drawer-input-section {
      margin-top: var(--space-lg);
    }

    .drawer-input-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: var(--space-sm);
      min-height: 1.5rem;
    }

    .drawer-input-footer .footer-status {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      font-size: 0.75rem;
      color: var(--ilya-text-muted);
    }

    .drawer-input-actions {
      margin-top: var(--space-md);
    }

    .drawer-secondary-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--space-sm);
    }

    /* Button styles */
    .btn {
      padding: 0.5rem 1.25rem;
      border-radius: var(--radius);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }

    .btn-primary {
      background: var(--ilya-accent);
      color: white;
      border: none;
    }

    .btn-primary:hover {
      background: var(--ilya-accent-hover);
    }
    
    .btn-primary:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .btn-secondary {
      background: transparent;
      color: var(--ilya-text-secondary);
      border: 1px solid var(--ilya-border);
      min-width: 72px;
      height: 36px;
      padding: 0 1rem;
    }

    .btn-secondary:hover {
      border-color: var(--ilya-text-secondary);
      color: var(--ilya-text-primary);
    }
    
    .btn-secondary:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    /* ========================================
       LANGUAGE PILL (v6.0.51)
       Unified segmented pill — Kimi spec
       Used in Root (left-aligned, pre-flight) and
       Drill (right-flush, display swap)
       ======================================== */
    .lang-toggle-pill {
      display: inline-flex;
      width: 52px;
      height: 24px;
      background: rgba(139, 154, 125, 0.12);
      border-radius: 12px;
      position: relative;
      cursor: pointer;
      user-select: none;
      flex-shrink: 0;
    }

    .lang-option {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-sans);
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6B6B6B;
      transition: color 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
      z-index: 2;
      border: none;
      background: none;
      padding: 0;
      cursor: pointer;
    }

    .lang-option.active {
      color: #fff;
    }

    .lang-option:hover:not(.active) {
      color: #4A4A4A;
    }

    .lang-pill-indicator {
      position: absolute;
      width: 50%;
      height: 100%;
      background: #8B9A7D;
      border-radius: 12px;
      transition: transform 300ms cubic-bezier(0.25, 0.1, 0.25, 1.0);
      z-index: 1;
    }

    /* EN active */
    .lang-toggle-pill[data-lang="en"] .lang-pill-indicator {
      transform: translateX(0);
    }

    /* FR active */
    .lang-toggle-pill[data-lang="fr"] .lang-pill-indicator {
      transform: translateX(100%);
    }

    /* Drill placement: right-flush, above phoneme ribbon */
    .inspector-header .lang-toggle-pill {
      flex-shrink: 0;
      margin-left: auto;
    }

    /* ========================================
       GHOST TEXT: Empty state instruction
       ======================================== */
    .ghost-text {
      margin: 0;
      padding: 0;
      font-family: 'Noto Serif', serif;
      font-style: italic;
      font-size: 1rem;
      line-height: 1.6;
      color: var(--ink-secondary);
      opacity: 0.5;
      max-width: 45em;
    }

    .ghost-text p {
      margin: 0 0 0.5rem 0;
    }

    .ghost-text.hidden {
      display: none;
    }

    /* ========================================
       POPUP OVERLAY - REMOVED Phase 3E
       Functionality moved to drawer inspector
       ======================================== */
    /* 
    .popup-overlay {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: none;
    }

    .popup-overlay.active {
      display: block;
    }

    .popup-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(26, 22, 18, 0.1);
    }
    */

    /* ========================================
       POPUP CARD - REMOVED Phase 3E
       ======================================== */
    /*
    .popup-card {
      position: absolute;
      width: 320px;
      max-height: 70vh;
      overflow-y: auto;
      background: var(--surface);
      border-radius: var(--radius);
      box-shadow: var(--shadow-popup);
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 250ms var(--ease), transform 250ms var(--ease);
      z-index: 101;
    }

    .popup-overlay.active .popup-card {
      opacity: 1;
      transform: translateY(0);
    }

    .popup-arrow {
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid var(--surface);
      filter: drop-shadow(0 2px 2px rgba(26, 22, 18, 0.08));
    }

    .popup-card.arrow-top .popup-arrow {
      top: -8px;
      bottom: auto;
      border-top: none;
      border-bottom: 10px solid var(--surface);
      filter: drop-shadow(0 -2px 2px rgba(26, 22, 18, 0.08));
    }
    */

    /* Mobile popup - REMOVED Phase 3E */
    /*
    @media (max-width: 600px) {
      .popup-card {
        position: fixed;
        left: 0 !important;
        right: 0;
        bottom: 0 !important;
        top: auto !important;
        width: 100%;
        max-height: 70vh;
        border-radius: 16px 16px 0 0;
        transform: translateY(100%);
        overflow-y: auto;
      }

      .popup-overlay.active .popup-card {
        transform: translateY(0);
      }

      .popup-arrow {
        display: none;
      }

      .popup-body::before {
        content: '';
        display: block;
        width: 36px;
        height: 4px;
        background: rgba(26, 22, 18, 0.2);
        border-radius: 2px;
        margin: 0.75rem auto 0.5rem;
      }
    }
    */

    /* ========================================
       POPUP BODY
       ======================================== */
    .popup-body {
      padding: 1.25rem;
    }

    .clitic-badge {
      background: var(--ilya-accent-light);
      color: var(--ilya-accent);
      font-size: 0.75rem;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      margin-bottom: 1rem;
      text-align: center;
    }

    .why-clitic-banner {
        background: var(--ilya-accent-light);
        color: var(--ilya-accent);
        font-size: 0.75rem;
        padding: 0.6rem 0.85rem;
        border-radius: 4px;
        margin-bottom: 0.75rem;
        text-align: left;
        line-height: 1.45;
    }
    
    .why-clitic-banner em {
        display: block;
        margin-top: 0.4rem;
        font-style: italic;
    }
    
    .why-clitic-banner .tie-bar-ref {
        color: var(--ilya-accent-dark, #4a5c4d);
        font-weight: 600;
        font-style: normal;
    }

    .syllable-section {
      margin-bottom: 1rem;
    }

    .syllable-label {
      font-size: 0.7rem;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .syllable-sandwich {
      background: var(--paper);
      border-radius: var(--radius);
      padding: 0.6rem;
    }

    .syllable-display {
      display: flex;
      justify-content: center;
      gap: 0.3rem;
      flex-wrap: wrap;
    }

    .syllable-btn {
      font-family: 'Noto Serif', serif;
      font-size: 1.15rem;
      padding: 0.5rem 0.75rem;
      background: var(--surface);
      border: 1px solid rgba(26, 22, 18, 0.15);
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }

    .syllable-btn:hover {
      border-color: var(--ilya-accent);
      background: var(--ilya-accent-light);
    }
    
    .syllable-btn:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .syllable-btn.stressed {
      background: var(--ilya-accent);
      color: white;
      border-color: var(--ilya-accent);
      font-weight: 500;
    }

    .syllable-btn.stressed:hover {
      background: var(--ilya-accent-hover);
    }
    
    .syllable-btn.disabled,
    .syllable-btn:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      background: var(--ilya-parchment);
      border-color: rgba(26, 22, 18, 0.1);
    }
    
    .syllable-btn.disabled:hover,
    .syllable-btn:disabled:hover {
      border-color: rgba(26, 22, 18, 0.1);
      background: var(--ilya-parchment);
    }
    
    .syllable-btn.disabled:focus,
    .syllable-btn:disabled:focus {
      outline: none;
    }
    
    /* Syllable drag states (v5.10.15) */
    .syllable-btn.dragging {
      opacity: 0.5;
      transform: scale(0.98);
    }
    
    .syllable-btn.drag-target {
      border-color: var(--ilya-accent);
      box-shadow: 0 0 0 3px rgba(122, 158, 126, 0.3);
    }
    
    .syllable-btn.drag-invalid {
      animation: shake 0.3s ease-out;
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    
    /* Ghost consonant during drag */
    .consonant-ghost {
      position: fixed;
      pointer-events: none;
      font-family: var(--font-ipa);
      font-size: 1.15rem;
      padding: 0.3rem 0.5rem;
      background: var(--surface);
      border: 1px solid var(--ilya-accent);
      border-radius: 4px;
      opacity: 0.85;
      z-index: 10000;
      transition: opacity 0.15s, transform 0.15s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .consonant-ghost.valid {
      background: var(--ilya-accent-light);
      border-color: var(--ilya-accent);
    }
    
    .consonant-ghost.invalid {
      background: #fee;
      border-color: #c44;
      opacity: 0.6;
    }

    /* Syllable display header (v5.10.19) - interactive IPA at top of popup */
    .syllable-display-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      margin-bottom: 0.5rem;
    }
    
    .syllable-display-header .syllable-display {
      justify-content: center;
    }
    
    .syllable-display-header .syllable-btn {
      font-family: var(--font-ipa);
      font-size: 1.2rem;
      padding: 0.4rem 0.6rem;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: var(--ilya-text-secondary);
      /* Stable width: reserve space for stress marker even when absent */
      min-width: 3.5em;
      text-align: center;
    }
    
    .syllable-display-header .syllable-btn:hover {
      background: var(--ilya-accent-light);
      border-color: var(--ilya-accent);
      color: var(--ink-primary);
    }
    
    .syllable-display-header .syllable-btn.stressed {
      background: var(--ilya-accent);
      color: white;
      border-color: var(--ilya-accent);
      /* Removed font-weight: 500 to prevent layout shift */
    }
    
    .syllable-display-header .syllable-btn.stressed:hover {
      background: var(--ilya-accent-hover);
    }
    
    /* Customized state indicator (boundaries adjusted) */
    .syllable-display-header.customized .syllable-btn {
      color: var(--ilya-accent);
    }
    
    .syllable-display-header.customized .syllable-btn.stressed {
      color: white;
    }
    
    /* Boundary reset button (v5.11.43) - explicit reset for adjusted boundaries */
    .boundary-reset-btn {
      font-size: 1rem;
      padding: 0.25rem 0.5rem;
      margin-left: 0.5rem;
      background: transparent;
      border: 1px solid var(--ilya-accent-light);
      border-radius: 4px;
      color: var(--ilya-accent);
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease, background 0.15s ease;
      vertical-align: middle;
    }
    
    .boundary-reset-btn.visible {
      opacity: 1;
    }
    
    .boundary-reset-btn:hover {
      background: var(--ilya-accent-light);
      border-color: var(--ilya-accent);
    }
    
    .boundary-reset-btn:active {
      background: var(--ilya-accent);
      color: white;
    }

    .popup-cyrillic {
      font-family: 'Noto Serif', serif;
      font-size: 1.35rem;
      font-weight: 500;
      color: var(--ink-primary);
      text-align: center;
      margin-bottom: 0.75rem;
    }

    .gloss-section {
      text-align: center;
      margin-bottom: 1rem;
    }

    .gloss-inline {
      font-family: 'Noto Serif', serif;
      font-size: 1rem;
      font-style: italic;
      color: var(--ilya-accent);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      display: inline-block;
      min-width: 140px;
      background: var(--ilya-accent-light);
      border: 1px dashed rgba(122, 158, 126, 0.3);
      transition: all 150ms var(--ease);
    }

    .gloss-inline:hover {
      background: rgba(122, 158, 126, 0.15);
      border-color: var(--ilya-accent);
    }

    .gloss-inline:focus {
      outline: none;
      background: rgba(122, 158, 126, 0.15);
      border-style: solid;
      border-color: var(--ilya-accent);
      box-shadow: 0 0 0 2px var(--ilya-accent-light);
    }

    /* When gloss has content, make it look settled but keep sage */
    .gloss-inline:not(:empty) {
      background: transparent;
      border-color: transparent;
      color: var(--ilya-accent);
    }

    .gloss-inline:not(:empty):hover {
      background: var(--ilya-accent-light);
      border-color: transparent;
    }

    .gloss-inline:empty::before {
      content: attr(data-placeholder);
      color: var(--ilya-accent);
      opacity: 0.7;
      font-style: italic;
    }

    /* ========================================
       REFINE ANALYSIS PANEL (v5.5)
       Content First, Control Second redesign
       ======================================== */
    
    /* ========================================
       POPUP FOOTER CONTROLS (v5.11 - Flat Structure)
       Replaces accordion with contextual rows
       ======================================== */
    
    .popup-footer-controls {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .footer-control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--ilya-binding);
      border-radius: 8px;
      font-size: 0.85rem;
    }
    
    .footer-label {
      color: var(--ilya-text-secondary);
      font-weight: 500;
    }
    
    .footer-label .next-word {
      color: var(--ilya-text-primary);
      font-style: italic;
    }
    
    /* Variant row (ё toggle) */
    .variant-row {
      background: linear-gradient(135deg, var(--ilya-binding) 0%, rgba(122, 158, 126, 0.08) 100%);
    }
    
    .variant-control {
      display: flex;
      gap: 4px;
    }
    
    .variant-control .segment {
      min-width: 36px;
      padding: 6px 12px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .variant-control .segment[data-variant="yo"].active {
      background: var(--ilya-accent);
      color: white;
    }
    
    .variant-control .segment[data-variant="ye"].active {
      background: var(--ilya-text-muted);
      color: white;
    }
    
    /* Assimilation row */
    .assimilation-row {
      background: var(--ilya-binding);
    }
    
    .assimilation-row.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    
    .assimilation-control {
      display: flex;
      gap: 4px;
    }
    
    .assimilation-control .segment {
      padding: 6px 10px;
      font-size: 0.8rem;
    }
    
    /* Toast notification for ё warning — v5.11.47 lifecycle-scoped */
    .yo-toast {
      position: sticky;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 0 16px;
      background: var(--ilya-text-primary);
      color: white;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: max-height 200ms var(--ease), opacity 200ms var(--ease), padding 200ms var(--ease);
      border-radius: 0 0 16px 16px;
      z-index: 10;
      margin-top: auto;
    }
    
    .yo-toast.visible {
      max-height: 60px;
      opacity: 1;
      padding: 10px 16px;
    }
    
    .yo-toast .undo-btn {
      background: transparent;
      border: 1px solid white;
      color: white;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 150ms;
    }
    
    .yo-toast .undo-btn:hover {
      background: rgba(255,255,255,0.15);
    }

    /* Legacy accordion styles - keeping for gradual removal */
    .refine-analysis-toggle {
      display: none; /* Hidden in v5.11 */
    }

    .refine-panel {
      display: none; /* Hidden in v5.11 */
    }

    /* ========================================
       PHONEME RIBBON (v5.5 - Vertical Layout)
       Educational "Why This Transcription?" feature
       ======================================== */
    
    .phoneme-ribbon {
      margin-top: 0.75rem;
      padding: 0 8px;
    }
    
    /* ========================================
       VERTICAL RIBBON (v5.5)
       Replaces horizontal ribbon-grid
       ======================================== */
    
    .ribbon-vertical {
      --ribbon-inline-padding: 12px;
      --syllable-gap: 16px;
      --stressed-tint-opacity: 0.08;
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 8px 0;
      /* Allow overlays to extend beyond container */
      overflow: visible;
    }
    
    /* Phoneme row - minimum 44px for tap targets */
    .phoneme-row {
      position: relative;
      display: flex;
      align-items: center;
      min-height: 44px;
      padding: 0 var(--ribbon-inline-padding);
      cursor: pointer;
      border-radius: 4px;
      transition: background 150ms var(--ease);
    }
    
    .phoneme-row:hover {
      background: rgba(122, 158, 126, 0.06);
    }
    
    .phoneme-row:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 1px;
    }
    
    /* Metrical spacing between syllables */
    .phoneme-row[data-syllable-start="true"] {
      margin-top: var(--syllable-gap);
    }
    
    .phoneme-row[data-syllable-start="true"]:first-child,
    .stressed-syllable-region:first-child {
      margin-top: 0;
    }
    
    /* Stressed syllable region - subtle tint with soft radius */
    .stressed-syllable-region {
      background: rgba(122, 158, 126, var(--stressed-tint-opacity));
      border-radius: 6px;
      padding: 6px 0;
      margin: var(--syllable-gap) 0 0 0;
      /* Removed negative horizontal margins - let rows keep consistent padding */
    }
    
    .stressed-syllable-region:first-child {
      margin-top: 0;
    }
    
    .stressed-syllable-region .phoneme-row {
      /* Keep same padding as unstressed rows to prevent layout shift */
      padding: 0 var(--ribbon-inline-padding);
    }
    
    .stressed-syllable-region .phoneme-row[data-syllable-start="true"] {
      margin-top: 0;
    }
    
    /* Featured ribbon entry (tie bar for clitics) */
    .phoneme-row.featured-entry {
      background: rgba(107, 124, 110, 0.08);
      border-left: 3px solid var(--ilya-accent);
      margin-left: -0.75rem;
      padding-left: calc(0.75rem - 3px);
      margin-bottom: 0.75rem;
    }
    
    .phoneme-row.featured-entry .phoneme-blurb-overlay {
      background: rgba(107, 124, 110, 0.06);
    }
    
    .phoneme-row.featured-entry .blurb-text {
      line-height: 1.5;
    }
    
    /* Phoneme row content wrapper for grid animation */
    .phoneme-row-content {
      display: grid;
      grid-template-rows: auto 0fr;
      width: 100%;
      transition: grid-template-rows 200ms var(--ease);
    }
    
    .phoneme-row.expanded .phoneme-row-content {
      grid-template-rows: auto 1fr;
    }
    
    /* Typography hierarchy */
    .phoneme-mapping {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-height: 32px;
    }
    
    /* Ensure clicks pass through to parent row */
    .phoneme-cyr,
    .phoneme-arrow,
    .phoneme-ipa {
      pointer-events: none;
    }
    
    .phoneme-cyr {
      font-family: 'Noto Serif', serif;
      color: var(--ilya-text-muted);
      width: 20px;
      font-size: 0.95rem;
    }
    
    .phoneme-arrow {
      color: var(--ilya-text-caption);
      font-size: 0.75rem;
      opacity: 0.5;
    }
    
    .phoneme-ipa {
      font-family: var(--font-ipa);
      color: var(--ilya-text-primary);
      font-size: 0.95rem;
    }
    
    /* Silent letter styling (deletion clusters) */
    .phoneme-row.silent-letter .phoneme-cyr {
      color: var(--ilya-text-caption);
    }
    
    .phoneme-row.silent-letter .phoneme-ipa {
      color: var(--ilya-text-caption);
      font-style: italic;
      font-family: var(--font-sans);
      font-size: 0.8rem;
    }
    
    /* Cluster box - full perimeter groups merged letters (v5.11.29) */
    /* ==========================================================================
       CLUSTER TWO-LAYER ARCHITECTURE (v5.11.31)
       Per Kimi's spec: always-visible rubric, vertical accordion for details
       - Perimeter: demoted to 1px, subtle grouping indicator
       - Rubric: always visible, content-sized
       - Details: accordion below rubric on click
       ========================================================================== */
    
    /* Cluster group wrapper */
    .cluster-group {
      position: relative;
      cursor: pointer;
    }
    
    /* Perimeter via ::before - demoted to 1px, reduced saturation */
    .cluster-group::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 4px;
      width: 36px;
      border: 1px solid rgba(122, 158, 126, 0.5); /* Demoted: 1px, 50% opacity */
      border-radius: 4px;
      pointer-events: none;
      z-index: 2;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }
    
    /* Hover: subtle glow on perimeter */
    .cluster-group:hover::before {
      border-color: rgba(122, 158, 126, 0.7);
      box-shadow: 0 0 8px rgba(122, 158, 126, 0.15);
    }
    
    /* Cluster member rows - completely neutral */
    .cluster-group .phoneme-row.cluster-member {
      min-height: 44px;
      background: transparent !important;
      pointer-events: none;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
    }
    
    .cluster-group .phoneme-row.cluster-member:hover,
    .cluster-group .phoneme-row.cluster-member:focus {
      background: transparent !important;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
    }
    
    .cluster-group .phoneme-row.cluster-member .phoneme-arrow,
    .cluster-group .phoneme-row.cluster-member .phoneme-ipa {
      visibility: hidden;
    }
    
    /* Prevent cluster rows from fading when blurb is active */
    .ribbon-vertical.has-active-blurb .cluster-group .phoneme-row {
      opacity: 1 !important;
    }
    
    /* Hidden click target (covers perimeter area) */
    .cluster-perimeter {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 4px;
      width: 36px;
      background: transparent;
      pointer-events: auto;
      cursor: pointer;
      z-index: 3;
      border: none;
      outline: none;
    }
    
    .cluster-perimeter:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }
    
    /* Dismiss backdrop - no longer needed with universal click-outside */
    .cluster-dismiss-backdrop {
      display: none;
    }
    
    /* Overlay container - ALWAYS VISIBLE (rubric), accordion for details */
    .cluster-overlay-container {
      position: absolute;
      top: 50%;
      left: 40px; /* Flush with perimeter right edge */
      right: 8px; /* Fill remaining ribbon width */
      transform: translateY(-50%);
      display: flex;
      align-items: flex-start;
      flex-direction: column;
      z-index: 15;
      pointer-events: auto;
    }
    
    /* Rubric row: connector + formula (always visible) */
    .cluster-rubric-row {
      display: flex;
      align-items: center;
      width: 100%;
    }
    
    /* Connector beam - always visible */
    .cluster-connector {
      width: 16px;
      min-width: 16px;
      height: 2px;
      background: rgba(122, 158, 126, 0.5); /* Matches demoted perimeter */
      flex-shrink: 0;
      transition: background 150ms ease;
    }
    
    .cluster-group:hover .cluster-connector {
      background: rgba(122, 158, 126, 0.7);
    }
    
    /* Rubric bubble - always visible, compact, content-sized */
    .cluster-rubric {
      background: rgba(250, 250, 248, 0.95);
      border: 1px solid rgba(122, 158, 126, 0.4);
      border-radius: 4px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: background 150ms ease, border-color 150ms ease;
      flex: 1;
      max-width: 200px;
    }
    
    .cluster-rubric:hover {
      background: rgba(122, 158, 126, 0.08);
      border-color: rgba(122, 158, 126, 0.6);
    }
    
    .cluster-rubric .cluster-formula-ortho {
      font-family: 'Noto Serif', serif;
      font-size: 0.95rem;
      color: var(--ilya-text-muted);
    }
    
    .cluster-rubric .cluster-formula-arrow {
      font-size: 0.85rem;
      color: var(--ilya-text-caption);
    }
    
    .cluster-rubric .cluster-formula-ipa {
      font-family: var(--font-ipa);
      font-size: 1rem;
      color: var(--ilya-text-primary);
    }
    
    /* Details panel - accordion below rubric */
    .cluster-details {
      margin-left: 16px; /* Align with rubric (past connector) */
      margin-top: 0;
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 250ms ease, opacity 150ms ease, margin-top 150ms ease;
      width: calc(100% - 16px);
    }
    
    .cluster-group.active .cluster-details {
      max-height: 300px;
      opacity: 1;
      margin-top: 8px;
    }
    
    .cluster-details-content {
      background: white;
      border: 1px solid rgba(122, 158, 126, 0.3);
      border-radius: 4px;
      padding: 12px 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }
    
    .cluster-details .cluster-blurb-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: var(--ilya-text-secondary);
    }
    
    .cluster-details .cluster-blurb-citation {
      font-size: 0.75rem;
      color: var(--ilya-text-caption);
      margin-top: 8px;
      font-style: italic;
    }
    
    /* Mobile: stack vertically */
    @media (max-width: 768px) {
      .cluster-overlay-container {
        right: 4px;
      }
      
      .cluster-rubric {
        max-width: none;
        flex: 1;
      }
      
      .cluster-details {
        margin-left: 0;
        width: 100%;
      }
    }
    
    /* ==========================================================================
       END CLUSTER TWO-LAYER ARCHITECTURE
       ========================================================================== */

    /* Blurb content (accordion) */
    .phoneme-blurb {
      overflow: hidden;
      min-height: 0;
    }
    
    .phoneme-blurb-inner {
      padding: 8px 0 4px 28px;
      border-top: 1px solid rgba(122, 158, 126, 0.15);
      margin-top: 6px;
    }
    
    .blurb-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: var(--ilya-text-secondary);
      margin-bottom: 4px;
    }
    
    .blurb-citation {
      font-size: 0.75rem;
      font-style: italic;
      color: var(--ilya-text-caption);
    }
    
    /* Mobile: ribbon scroll temporarily disabled for overlay support
    @media (max-width: 768px) {
      .ribbon-vertical {
        max-height: 50vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
    }
    */
    
    /* ========================================
       FLOATING BLURB OVERLAY (v5.5)
       "Inline Overlay" pattern per Kimi's design
       Scholarly annotation without layout shift
       ======================================== */
    
    /* Backdrop: white fade behind active blurb */
    .ribbon-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.7);
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms var(--ease);
      z-index: 5;
      border-radius: 6px;
    }
    
    .ribbon-backdrop.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* Fade other rows when a blurb is active - DISABLED per Phase 3C */
    /* Kimi's recommendation: trust user attention, no fading */
    /* .ribbon-vertical.has-active-blurb .phoneme-row:not(.expanded) {
      opacity: 0.6;
      transition: opacity 200ms var(--ease);
    } */
    
    /* Expanded row stays prominent */
    .ribbon-vertical.has-active-blurb .phoneme-row.expanded {
      z-index: 6;
      opacity: 1;
      filter: none;
    }
    
    /* Expanded row gets subtle highlight */
    .phoneme-row.expanded {
      background: rgba(122, 158, 126, 0.1);
      border-radius: 4px;
    }
    
    /* The floating blurb overlay */
    /* NOTE: Border removed from base - drawer inspector uses no borders */
    /* Original popup would add border via different selector if needed */
    .phoneme-blurb-overlay {
      position: absolute;
      top: calc(100% + 4px);
      left: -6px;
      right: -6px;
      background: #FAFAF8;
      /* border: 2px solid var(--ilya-accent); -- REMOVED: no borders on blurbs */
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06),
                  0 2px 8px rgba(122, 158, 126, 0.1);
      padding: 16px;
      z-index: 10;
      min-height: 60px;
      max-height: 200px;
      overflow-y: auto;
      
      /* Hidden by default */
      opacity: 0;
      pointer-events: none;
      transform: scale(0.98) translateY(4px);
      transition: opacity 200ms var(--ease),
                  transform 200ms var(--ease);
    }
    
    /* When row is expanded, show overlay */
    .phoneme-row.expanded .phoneme-blurb-overlay {
      opacity: 1;
      pointer-events: auto;
      transform: scale(1) translateY(0);
    }
    
    /* Expand upward variant (for rows in bottom half) */
    .phoneme-blurb-overlay.expand-upward {
      top: auto;
      bottom: 100%;
    }
    
    /* Blurb content styling within overlay */
    .phoneme-blurb-overlay .blurb-text {
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--ilya-text-primary);
      margin-bottom: 8px;
    }
    
    .phoneme-blurb-overlay .blurb-citation {
      font-size: 0.8rem;
      font-style: italic;
      color: var(--ilya-accent);
    }
    
    /* ========================================
       COMPACT MODULES (v5.4.2)
       Shared pattern for Stress Source & Phrase Boundary
       ======================================== */
    
    .stress-source-module,
    .phrase-boundary-module {
      margin-bottom: 0.5rem;
      padding: 0 8px;
      box-sizing: border-box;
    }
    
    .module-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.3rem;
    }
    
    .module-label {
      font-size: 0.7rem;
      color: var(--ink-secondary);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    
    .staged-indicator {
      font-size: 0.75rem;
      color: #9CA3AF;
      opacity: 0;
      transition: opacity 150ms var(--ease);
    }
    
    .staged-indicator.visible {
      opacity: 1;
    }
    
    /* Segmented Control */
    .segmented-control {
      display: flex;
      background: #F3F4F6;
      border-radius: 6px;
      padding: 2px;
      gap: 2px;
    }
    
    .segment {
      flex: 1;
      padding: 0.35rem 0.4rem;
      font-size: 0.7rem;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
      box-sizing: border-box;
    }
    
    .segment:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    /* Active/committed segment */
    .segment.active {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
    }
    
    /* Staged segment (pending, not yet committed) */
    .segment.staged {
      background: white;
      color: var(--ink-secondary);
      outline: 1px dashed #9CA3AF;
      outline-offset: -2px;
    }
    
    /* Committed segment (saved) */
    .segment.committed {
      background: white;
      color: var(--ilya-text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      outline: 1px solid var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* ========================================
       SHARED COMMIT FOOTER (v5.4.2)
       Fixed height, always present
       ======================================== */
    
    .shared-commit-footer {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 0.75rem;
      height: 36px;
      padding: 0 8px;
      margin-top: 0.5rem;
      opacity: 0.4;
      transition: opacity 150ms var(--ease);
    }
    
    .shared-commit-footer.has-changes {
      opacity: 1;
    }
    
    .shared-commit-footer .apply-btn,
    .shared-commit-footer .revert-btn {
      font-size: 0.75rem;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms var(--ease);
    }
    
    .shared-commit-footer .apply-btn {
      background: var(--ilya-accent);
      color: white;
      border: none;
    }
    
    .shared-commit-footer .apply-btn:hover {
      background: var(--ilya-accent-dark, #5a8a5e);
    }
    
    .shared-commit-footer .revert-btn {
      background: transparent;
      color: var(--ink-secondary);
      border: 1px solid rgba(26, 22, 18, 0.15);
    }
    
    .shared-commit-footer .revert-btn:hover {
      border-color: var(--ink-secondary);
    }
    
    /* Hairline separator between modules - HIDDEN IN v5.11 */
    .phrase-boundary-module {
      display: none !important; /* Hidden in v5.11 (moved to assimilation row) */
      padding-top: 0.5rem;
      border-top: 1px solid #E5E7EB;
    }
    
    /* ё toggle module - HIDDEN IN v5.11 (moved to variant row) */
    .yo-toggle-module {
      display: none !important; /* Hidden in v5.11 */
      margin-bottom: 0.5rem;
      padding: 0.5rem 8px 0;
      border-top: 1px solid #E5E7EB;
      box-sizing: border-box;
    }
    
    .yo-toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    
    .yo-current-form {
      font-family: 'Noto Serif', Georgia, serif;
      font-size: 1rem;
      color: var(--ink-primary);
    }
    
    .yo-toggle-btn {
      padding: 0.35rem 0.6rem;
      font-size: 0.75rem;
      background: transparent;
      border: 1px solid var(--ilya-border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
    }
    
    .yo-toggle-btn:hover {
      border-color: var(--ilya-accent);
      color: var(--ilya-accent);
    }
    
    .yo-toggle-btn:active {
      transform: scale(0.97);
      transition: transform 50ms ease-out;
    }
    
    .yo-toggle-btn:focus {
      outline: 2px solid var(--ilya-accent-light);
      outline-offset: 1px;
    }
    
    .yo-warning {
      margin-top: 0.35rem;
      font-size: 0.7rem;
      color: var(--ilya-warning);
      font-style: italic;
    }
    
    /* Popup content crossfade for ё toggle (v5.8.1) */
    .popup-body {
      transition: opacity 120ms ease-out;
    }
    
    .popup-body.fading {
      opacity: 0.3;
      transition: opacity 80ms ease-out;
    }

    /* Old restore-link kept for compatibility */
    .restore-link {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem;
      background: none;
      border: none;
      font-family: 'Noto Sans', sans-serif;
      font-size: 0.7rem;
      color: var(--ilya-accent);
      cursor: pointer;
      transition: opacity 150ms var(--ease);
    }

    .restore-link:hover {
      opacity: 0.7;
    }
    
    .restore-link:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: 2px;
    }

    .restore-link svg {
      width: 12px;
      height: 12px;
    }

    .restore-link-wrapper {
      display: flex;
      justify-content: flex-end;
      width: 100%;
    }

    .citation {
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .citation-rule {
      color: var(--ink-primary);
    }

    .citation-ref {
      color: var(--ink-secondary);
      font-style: italic;
    }

    /* ========================================
       DASHBOARD: Split Layout (Desktop ≥768px)
       ======================================== */
    
    /* Mobile tabs navigation */
    .drawer-tabs {
      display: none;
      border-bottom: 1px solid var(--ilya-border);
      background: var(--ilya-binding);
    }
    
    .drawer-tab {
      flex: 1;
      padding: var(--space-md);
      font-size: var(--text-sm);
      font-weight: 500;
      color: var(--ilya-text-secondary);
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      transition: all var(--duration-fast) var(--ease-out);
    }
    
    .drawer-tab.active {
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border-bottom-color: var(--ilya-accent);
    }
    
    .drawer-tab:hover:not(.active) {
      background: rgba(122, 158, 126, 0.05);
    }
    
    .drawer-tab:focus {
      outline: 2px solid var(--ilya-accent);
      outline-offset: -2px;
    }
    
    /* OLD DRAWER ZONES: REMOVED Phase 2C */
    /*
    .drawer-zones {
      display: flex;
      flex-direction: row;
      flex: 1;
      min-height: 0;
    }
    
    .input-zone {
      flex: 2;
      display: flex;
      flex-direction: column;
      padding: var(--space-lg);
      background: var(--ilya-paper);
      border-right: 1px solid var(--ilya-border-light);
      overflow-y: auto;
    }
    
    .dashboard-zone {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: var(--space-lg);
      background: var(--ilya-binding);
      overflow-y: auto;
      gap: var(--space-md);
    }
    */
    
    /* Mobile zones: REMOVED Phase 2C */
    /*
    @media (max-width: 767px) {
      .drawer-tabs {
        display: flex;
      }
      
      .drawer-zones {
        flex-direction: column;
      }
      
      .input-zone {
        border-right: none;
        flex: 1;
      }
      
      .dashboard-zone {
        flex: 1;
      }
      
      .input-zone.hidden,
      .dashboard-zone.hidden {
        display: none;
      }
    }
    */
    
    /* ========================================
       DASHBOARD: Form Components
       ======================================== */
    .form-group {
      margin-bottom: var(--space-md);
    }
    
    .form-label {
      display: block;
      font-size: var(--text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--ilya-text-secondary);
      margin-bottom: var(--space-sm);
    }
    
    .form-input {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      transition: all var(--duration-fast) var(--ease-out);
    }
    
    .form-input:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .form-input::placeholder {
      color: var(--ilya-text-muted);
    }
    
    .form-hint {
      font-size: 10px;
      color: var(--ilya-text-muted);
      margin-top: 4px;
      font-style: italic;
    }
    
    /* ========================================
       DASHBOARD: Searchable Select
       ======================================== */
    .searchable-select {
      position: relative;
      width: 100%;
    }
    
    .select-trigger {
      width: 100%;
      padding: var(--space-md);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all var(--duration-fast) var(--ease-out);
      text-align: left;
    }
    
    .select-trigger:hover {
      border-color: var(--ilya-border-focus);
    }
    
    .select-trigger.active {
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .select-trigger .chevron-down {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .select-trigger.active .chevron-down {
      transform: rotate(180deg);
    }
    
    .select-trigger .placeholder {
      color: var(--ilya-text-muted);
    }
    
    .select-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      max-height: 200px;
      overflow-y: auto;
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      box-shadow: var(--ilya-shadow-md);
      z-index: 100;
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
      transition: all var(--duration-base) var(--ease-out);
    }
    
    .select-dropdown.open {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }
    
    .select-search {
      width: 100%;
      padding: var(--space-md);
      border: none;
      border-bottom: 1px solid var(--ilya-border-light);
      font-size: var(--text-sm);
      font-family: var(--font-sans);
    }
    
    .select-search:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .select-option {
      padding: var(--space-md);
      cursor: pointer;
      border-bottom: 1px solid var(--ilya-border-light);
      transition: background var(--duration-fast) var(--ease-out);
    }
    
    .select-option:last-child {
      border-bottom: none;
    }
    
    .select-option:hover,
    .select-option.highlighted {
      background: var(--ilya-accent-light);
    }
    
    .select-option .primary {
      display: block;
      font-weight: 500;
      color: var(--ilya-text-primary);
    }
    
    .select-option .secondary {
      display: block;
      font-size: var(--text-xs);
      color: var(--ilya-text-caption);
      margin-top: 2px;
    }
    
    .select-option.custom {
      font-style: italic;
      color: var(--ilya-text-secondary);
      border-top: 2px solid var(--ilya-border);
    }
    
    .custom-warning {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      font-size: var(--text-xs);
      color: var(--ilya-warning);
      margin-top: var(--space-sm);
      padding: var(--space-sm);
      background: rgba(212, 163, 115, 0.1);
      border-radius: 4px;
    }
    
    /* ========================================
       DASHBOARD: Profile Section
       ======================================== */
    .profile-section {
      margin-top: auto;
      border-top: 1px solid var(--ilya-border);
      padding-top: var(--space-lg);
    }
    
    .profile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: var(--space-sm) 0;
    }
    
    .profile-header:hover {
      opacity: 0.8;
    }
    
    .profile-title {
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--ilya-text-secondary);
    }
    
    .profile-active {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
    }
    
    .profile-chevron {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .profile-section.expanded .profile-chevron {
      transform: rotate(180deg);
    }
    
    .profile-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-base) var(--ease-out),
                  opacity var(--duration-base) var(--ease-out);
      opacity: 0;
    }
    
    .profile-section.expanded .profile-content {
      max-height: 300px;
      opacity: 1;
    }
    
    .profile-select {
      width: 100%;
      padding: var(--space-md);
      margin: var(--space-md) 0;
      font-size: var(--text-base);
      font-family: var(--font-sans);
      color: var(--ilya-text-primary);
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      cursor: pointer;
    }
    
    .profile-select:focus {
      outline: none;
      border-color: var(--ilya-border-focus);
      box-shadow: 0 0 0 3px var(--ilya-accent-light);
    }
    
    .profile-description {
      display: flex;
      gap: var(--space-sm);
      font-size: var(--text-sm);
      font-family: var(--font-ipa);
      color: var(--ilya-text-secondary);
      line-height: 1.5;
      padding: var(--space-md);
      background: var(--ilya-paper);
      border-radius: 6px;
    }
    
    .info-icon-circle {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      font-style: italic;
      font-family: var(--font-sans);
      color: var(--ilya-accent);
      border: 1.5px solid var(--ilya-accent);
      border-radius: 50%;
      opacity: 0.7;
    }
    
    .profile-future {
      display: none; /* Hidden until multiple profiles implemented */
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
      margin-top: var(--space-md);
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    /* ========================================
       DOCUMENT SECTION (v5.8.2)
       Paper size selection in dashboard
       ======================================== */
    .document-section {
      margin-top: var(--space-lg);
      border-top: 1px solid var(--ilya-border);
      padding-top: var(--space-lg);
    }
    
    .document-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: var(--space-sm) 0;
    }
    
    .document-header:hover {
      opacity: 0.8;
    }
    
    .document-title {
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--ilya-text-secondary);
    }
    
    .document-active {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
    }
    
    .document-pages {
      font-size: var(--text-xs);
      color: var(--ilya-text-muted);
      margin-left: 8px;
    }
    
    .document-pages::before {
      content: "•";
      margin-right: 8px;
    }
    
    .document-chevron {
      width: 16px;
      height: 16px;
      stroke: var(--ilya-text-muted);
      transition: transform var(--duration-base) var(--ease-out);
    }
    
    .document-section.expanded .document-chevron {
      transform: rotate(180deg);
    }
    
    .document-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--duration-base) var(--ease-out),
                  opacity var(--duration-base) var(--ease-out);
      opacity: 0;
    }
    
    .document-section.expanded .document-content {
      max-height: 150px;
      opacity: 1;
    }
    
    /* Paper size segmented control */
    .paper-size-control {
      display: flex;
      background: var(--ilya-paper);
      border: 1px solid var(--ilya-border);
      border-radius: 6px;
      padding: 3px;
      gap: 3px;
      margin: var(--space-md) 0;
    }
    
    .paper-size-btn {
      flex: 1;
      padding: 0.5rem 0.75rem;
      font-size: var(--text-sm);
      font-weight: 500;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: var(--ink-secondary);
      transition: all 150ms var(--ease);
      min-height: 44px;
    }
    
    .paper-size-btn:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    .paper-size-btn.active {
      background: var(--ink-primary);
      color: white;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    }
    
    .paper-size-label {
      display: block;
      font-weight: 500;
    }
    
    .paper-size-dims {
      display: block;
      font-size: var(--text-xs);
      opacity: 0.7;
      margin-top: 2px;
    }
    
    /* Export section (v5.9.8) */
    .export-section {
      margin-top: var(--space-lg);
      padding-top: var(--space-lg);
      border-top: 1px solid var(--ilya-border-light);
    }
    
    .export-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 16px;
      background: var(--stationery-sage);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: var(--text-sm);
      font-weight: 600;
      cursor: pointer;
      transition: all 150ms var(--ease);
      min-height: 44px;
    }
    
    .export-btn:hover {
      background: #7a8a6d;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(139, 154, 125, 0.3);
    }
    
    .export-btn:active {
      transform: translateY(0);
    }
    
    .export-btn:disabled {
      background: var(--ilya-border);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .export-icon {
      width: 18px;
      height: 18px;
    }
    
    /* IPA text styling */
    .ipa-text {
      font-family: var(--font-ipa);
      font-size: 1.05em;
    }

    /* ========================================
       PRINT STYLES
       ======================================== */
    @media print {
      /* Hide all UI elements */
      .ilya-drawer,
      .drawer-scrim,
      .popup-overlay,
      .tab-bar {
        display: none !important;
      }

      /* Reset body and aperture */
      body {
        background: white !important;
        padding: 0;
        margin: 0;
      }
      
      .ilya-layout {
        display: block;
        padding: 0;
        margin: 0;
      }
      
      .paper-aperture {
        padding: 0;
        overflow: visible;
        box-shadow: none;
        display: block;
        background: white;
        width: 100%;
      }

      /* Paper stack: no gaps, visible overflow */
      .paper-stack {
        gap: 0;
        padding: 0;
        display: block;
      }

      /* Individual pages - WYSIWYG fix (v5.11.6)
         Force each paper-page to be one physical page */
      .paper-page {
        page-break-after: always;
        page-break-inside: avoid;
        break-after: page;
        break-inside: avoid;
        box-shadow: none !important;
        margin: 0;
        padding: 0.5in 0.75in;
        width: 8.5in;
        min-height: 11in;
        height: 11in;  /* Force full page height */
        overflow: visible;  /* But don't clip if slightly over */
        background: white;
        box-sizing: border-box;
        position: relative;
      }
      
      /* Last page shouldn't force a trailing blank */
      .paper-page:last-child {
        page-break-after: auto;
        break-after: auto;
      }
      
      /* A4: 210mm × 297mm */
      .paper-page[data-size="a4"] {
        width: 210mm;
        min-height: 297mm;
        height: 297mm;
        padding: 12.7mm 15mm;
      }
      
      /* Hide watermark in print */
      .paper-page[data-template="subsequent"]::before {
        display: none;
      }

      /* Word stacks: no hover effects */
      .word-stack {
        cursor: default;
        background: transparent !important;
      }

      .word-stack:hover {
        background: none !important;
        box-shadow: none !important;
      }

      /* Verse lines: avoid breaking mid-line */
      .verse-line {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      
      /* Footer: align with page content area (v5.11.6) */
      .page-footer {
        position: absolute;
        bottom: 0;
        left: 0.75in;
        right: 0.75in;
        padding: 12px 0 24px 0;  /* Keep vertical padding only */
      }
      
      /* Page content: remove horizontal padding (paper-page provides it) */
      .page-content {
        padding-left: 0;
        padding-right: 0;
      }
      
      /* Page header title: align with content (v5.11.31) */
      .page-header-title {
        padding-left: 0;
        padding-right: 0;
      }
      
      /* Running header: align with content (v5.11.31) */
      .page-header-running {
        margin-left: 0;
        margin-right: 0;
      }
      
      /* Logo: align with content edge (v5.11.31) */
      .page-logo {
        left: 0.75in;
        top: 0.25in;
      }

      /* Page setup - minimal margins, content has its own padding */
      @page {
        margin: 0;
        size: letter;
      }
      
      @page :first {
        margin: 0;
      }
    }

    /* ========================================
       RESPONSIVE
       ======================================== */
    @media (max-width: 880px) {
      .paper {
        min-height: auto;
      }

      .doc-header {
        padding: 48px 36px 20px;
      }

      .doc-body {
        padding: 20px 36px;
      }

      .doc-footer {
        padding: 20px 36px 36px;
      }
    }

    @media (max-width: 480px) {
      .doc-header {
        padding: 36px 24px 16px;
      }

      .doc-body {
        padding: 16px 24px;
      }

      .doc-footer {
        padding: 16px 24px 24px;
      }

      .doc-title {
        font-size: 1.25rem;
      }

      .word-stack .cyrillic {
        font-size: 1.1rem;
      }

      .word-stack .ipa {
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body class="notranslate">

  <div class="ilya-layout">

    <!-- Drawer: The workbench (v6.0) -->
    <aside class="ilya-drawer" id="ilyaDrawer" data-state="closed" data-mode="root">
      
      <!-- Phase 5A: Mobile drag handle (visible only on ≤600px) -->
      <div class="drawer-drag-handle" aria-hidden="true">
        <div class="drag-handle-bar"></div>
      </div>

      <!-- Root State: Dashboard/Input (content migrated in Phase 2) -->
      <div class="drawer-root" id="drawerRoot">
        <div class="drawer-header">
          <span class="drawer-title"><svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="120" height="42" viewBox="0 0 526 184" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Ilya"><g transform="translate(0,184) scale(0.1,-0.1)" fill="#8B9A7D" stroke="none"><path d="M1925 1783 c-85 -4 -102 -10 -108 -35 -7 -26 7 -38 45 -38 81 0 103 -46 78 -160 -10 -41 -63 -273 -119 -516 -57 -249 -101 -463 -101 -492 0 -121 118 -162 290 -100 58 21 80 40 80 70 0 14 -6 17 -22 13 -55 -11 -91 -13 -123 -4 -27 8 -36 17 -43 43 -6 18 -7 46 -5 62 5 29 191 840 237 1036 15 59 26 112 26 118 0 10 -90 11 -235 3z M1127 1673 c-14 -13 -7 -52 11 -56 9 -3 39 -11 65 -17 87 -23 87 -22 22 -307 -32 -136 -63 -273 -70 -303 -84 -373 -98 -427 -117 -447 -26 -28 -59 -40 -130 -48 -39 -4 -58 -11 -58 -20 0 -7 -3 -20 -6 -29 -6 -14 23 -16 279 -16 l285 0 4 30 c4 28 3 30 -51 41 -31 6 -64 15 -73 20 -43 23 -42 33 48 421 47 205 97 419 109 475 26 111 45 157 74 172 10 6 49 15 87 21 69 11 84 20 84 53 0 16 -20 17 -278 17 -153 0 -282 -3 -285 -7z M50 859 l0 -710 181 3 181 3 24 28 c33 39 31 81 -5 118 -28 28 -34 29 -115 29 l-86 0 0 530 0 530 84 0 c75 0 88 3 113 24 22 19 28 32 28 66 0 35 -6 46 -30 66 -29 23 -36 24 -202 24 l-173 0 0 -711z M4803 1560 c-28 -12 -56 -66 -49 -95 3 -12 14 -33 25 -46 17 -21 30 -24 112 -29 52 -3 93 -8 92 -12 -2 -5 -3 -242 -3 -528 l0 -520 -77 0 c-88 0 -122 -13 -141 -53 -11 -22 -11 -35 -2 -63 19 -56 50 -64 245 -64 l165 0 0 710 0 710 -172 -1 c-95 0 -183 -4 -195 -9z M3690 1297 c-165 -56 -296 -197 -353 -382 -35 -112 -29 -274 14 -362 82 -169 293 -192 455 -50 44 38 64 41 64 9 0 -10 13 -33 29 -52 29 -35 29 -35 112 -35 75 0 136 15 206 49 1 1 5 14 8 29 l7 28 -66 -7 c-94 -10 -116 6 -116 83 0 30 5 72 10 92 37 133 139 596 133 602 -4 4 -43 -2 -85 -13 -73 -20 -79 -20 -112 -4 -86 41 -210 46 -306 13z m241 -70 c23 -15 38 -37 47 -65 13 -39 11 -53 -21 -190 -20 -81 -46 -190 -58 -242 -25 -111 -50 -144 -143 -190 -101 -51 -192 -34 -233 42 -25 48 -30 221 -9 313 35 146 125 282 222 333 56 30 150 30 195 -1z M2370 1291 c-85 -28 -110 -43 -116 -68 -4 -13 -5 -26 -3 -28 2 -2 27 1 55 7 40 8 58 7 80 -4 28 -13 29 -15 28 -88 -1 -53 -15 -131 -48 -262 -67 -270 -61 -348 27 -406 35 -24 50 -27 118 -26 88 2 166 32 252 98 27 21 51 35 54 32 3 -3 -8 -49 -25 -103 -65 -205 -175 -327 -303 -335 -41 -3 -43 -2 -69 45 -53 95 -101 125 -165 101 -21 -8 -45 -56 -45 -89 0 -75 65 -115 198 -123 226 -13 394 85 496 287 25 51 54 122 65 159 39 131 183 804 174 813 -5 5 -42 6 -83 1 l-75 -7 -67 -300 c-88 -397 -77 -366 -148 -414 -106 -70 -209 -78 -254 -18 -33 45 -26 122 33 356 56 219 63 278 42 328 -25 61 -114 79 -221 44z"/></g></svg></span>
          <!-- Language pill — header placement: flush right, level with sigil (v6.0.52) -->
          <div class="lang-toggle-pill" id="rootLangPill" data-lang="en" role="radiogroup" aria-label="Gloss language">
            <div class="lang-pill-indicator"></div>
            <button class="lang-option active" data-lang="en" role="radio" aria-checked="true">EN</button>
            <button class="lang-option" data-lang="fr" role="radio" aria-checked="false">FR</button>
          </div>
        </div>
        <div class="drawer-body">

          <!-- Welcome Preface (First-run name collection) -->
          <div class="welcome-preface hidden" id="welcomePreface">
            <p class="preface-text" data-i18n="welcome.text">Welcome to Ilya. Your name will appear in the footer of every transcription you make.</p>
            <div class="preface-field">
              <input type="text" id="welcomeNameInput" 
                     placeholder="e.g. Dr. Jane Smith or J. Smith"
                     maxlength="50"
                     aria-label="Your name for attribution">
            </div>
            <div class="preface-actions">
              <button class="btn-primary" id="welcomeSaveBtn" data-i18n="welcome.save">Save</button>
              <a class="link-secondary" id="welcomeSkipBtn">Skip for now</a>
            </div>
          </div>

          <!-- Text Input (Phase 2B) -->
          <div class="drawer-input-section">
            <!-- Textarea with OCR overlay -->
            <div class="textarea-wrapper">
              <textarea
                class="drawer-textarea"
                id="drawerTextInput"
                placeholder="Paste Russian lyrics here..."
                data-i18n="input.placeholder" data-i18n-target="placeholder"
                aria-label="Russian text input"
              ></textarea>

              <!-- OCR: icon inside textarea top-right corner -->
              <button class="ocr-overlay-btn" id="drawerOcrBtn"
                      aria-label="Import Russian text from image"
                      disabled
                      title="Loading Russian language pack...">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 7V5a2 2 0 0 1 2-2h2"/>
                  <path d="M17 3h2a2 2 0 0 1 2 2v2"/>
                  <path d="M21 17v2a2 2 0 0 1-2 2h-2"/>
                  <path d="M7 21H5a2 2 0 0 1-2-2v-2"/>
                </svg>
              </button>

              <!-- Hidden file input for OCR -->
              <input type="file"
                     id="drawerOcrFileInput"
                     accept="image/*"
                     capture="environment"
                     aria-hidden="true"
                     style="display: none;">
            </div>

            <!-- Footer: character counter + OCR status -->
            <div class="drawer-input-footer">
              <div class="footer-status">
                <span class="char-counter" id="drawerCharCounter"></span>
                <span class="ocr-status" id="drawerOcrStatus" style="display: none;">
                  <svg class="spinner" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" stroke-opacity="0.25"/>
                    <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
                  </svg>
                  <span class="ocr-status-text"></span>
                </span>
              </div>
            </div>

            <!-- Action buttons -->
            <div class="drawer-input-actions">
              <div class="drawer-secondary-actions">
                <button class="btn btn-secondary" id="drawerClearBtn" data-i18n="btn.clear">Clear</button>
                <button class="btn btn-primary" id="drawerTranscribeBtn" data-i18n="btn.transcribe">Transcribe</button>
              </div>
            </div>
          </div>

          <!-- Song Setup -->
          <div class="drawer-section-label" data-i18n="setup.heading">Song Setup</div>

          <!-- Title -->
          <div class="form-group">
            <input type="text" class="form-input" id="metaTitle" placeholder="Title" data-i18n="setup.title" data-i18n-target="placeholder">
          </div>

          <!-- Opus -->
          <div class="form-group">
            <input type="text" class="form-input" id="metaOpus" placeholder="Opus / Catalogue" data-i18n="setup.opus" data-i18n-target="placeholder">
          </div>

          <!-- Composer (searchable select) -->
          <div class="form-group">
            <div class="searchable-select" id="composerSelect">
              <button type="button" class="select-trigger" id="composerTrigger">
                <span class="placeholder" data-i18n="setup.composer">Composer</span>
                <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
              <div class="select-dropdown" id="composerDropdown">
                <input type="text" class="select-search" placeholder="Type to filter..." data-i18n="setup.filterPlaceholder" data-i18n-target="placeholder" id="composerSearch">
                <div class="select-options" id="composerOptions"></div>
              </div>
            </div>
          </div>

          <!-- Poet (searchable select) -->
          <div class="form-group">
            <div class="searchable-select" id="poetSelect">
              <button type="button" class="select-trigger" id="poetTrigger">
                <span class="placeholder" data-i18n="setup.poet">Poet / Librettist</span>
                <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
              <div class="select-dropdown" id="poetDropdown">
                <input type="text" class="select-search" placeholder="Type to filter..." data-i18n="setup.filterPlaceholder" data-i18n-target="placeholder" id="poetSearch">
                <div class="select-options" id="poetOptions"></div>
              </div>
            </div>
          </div>

          <!-- Transcriber Name -->
          <div class="form-group">
            <input type="text" class="form-input" id="metaTranscriber" placeholder="Your name (for attribution)" data-i18n="setup.name" data-i18n-target="placeholder">
            <div class="form-hint" data-i18n="setup.nameHint">Appears in document footer</div>
          </div>

          <!-- Transcription Profile -->
          <div class="profile-section" id="profileSection">
            <div class="profile-header" id="profileHeader">
              <div>
                <span class="profile-title" data-i18n="profile.label">Transcription Profile</span>
                <span class="profile-active" id="profileActive" data-i18n="profile.oldMuscovite">Old Muscovite</span>
              </div>
              <svg class="profile-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </div>
            <div class="profile-content">
              <select class="profile-select" id="profileSelect">
                <option value="old-muscovite" data-i18n="profile.oldMuscovite" selected>Old Muscovite</option>
                <option value="peterburgian" data-i18n="profile.peterburgian">Peterburgian</option>
                <option value="choral" data-i18n="profile.choral">Choral</option>
              </select>
              <div class="profile-description" id="profileDescription">
                <span class="info-icon-circle">i</span>
                <span data-i18n="profile.descOldMuscovite" data-i18n-target="html">Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]</span>
              </div>
              <div class="profile-future" data-i18n="page.viewProfiles">View all profiles →</div>
            </div>
          </div>

          <!-- Document Settings -->
          <div class="drawer-section-label" data-i18n="page.heading">Page</div>

          <div class="document-section" id="documentSection">
            <div class="document-header" id="documentHeader">
              <div>
                <span class="document-title" data-i18n="page.paperSize">Paper Size</span>
                <span class="document-active" id="documentActive">Letter (8.5×11)</span>
                <span class="document-pages" id="pageNumber">1 page</span>
              </div>
              <svg class="document-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </div>
            <div class="document-content">
              <div class="paper-size-control" id="paperSizeControl">
                <button type="button" class="paper-size-btn active" data-size="letter" id="paperSizeLetter">
                  <span class="paper-size-label" data-i18n="page.letter">Letter</span>
                  <span class="paper-size-dims">8.5 × 11 in</span>
                </button>
                <button type="button" class="paper-size-btn" data-size="a4" id="paperSizeA4">
                  <span class="paper-size-label" data-i18n="page.a4">A4</span>
                  <span class="paper-size-dims">210 × 297 mm</span>
                </button>
              </div>
            </div>
          </div>

          <!-- Export -->
          <div class="export-section">
            <button type="button" class="export-btn" id="exportPdfBtn">
              <svg class="export-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="12" y1="18" x2="12" y2="12"></line>
                <line x1="9" y1="15" x2="12" y2="12"></line>
                <line x1="15" y1="15" x2="12" y2="12"></line>
              </svg>
              <span data-i18n="page.exportPdf">Export PDF</span>
            </button>
            <div class="form-hint" data-i18n="page.exportHint">Opens print dialog. Select "Save as PDF".</div>
          </div>

        </div>
      </div>

      <!-- Drill State: Word Inspector (content migrated in Phase 3) -->
      <div class="drawer-inspector" id="drawerInspector">
        <!-- Inspector Header -->
        <div class="inspector-header">
          <button class="back-btn" id="drawerBackBtn" aria-label="Back to dashboard">←</button>
          <span class="inspector-word" id="inspectorWordDisplay">—</span>
          <!-- Language pill — Drill placement: inspector header, right-aligned (v6.0.53) -->
          <div class="lang-toggle-pill" id="drillLangPill" data-lang="en" role="radiogroup" aria-label="Gloss language">
            <div class="lang-pill-indicator"></div>
            <button class="lang-option active" data-lang="en" role="radio" aria-checked="true">EN</button>
            <button class="lang-option" data-lang="fr" role="radio" aria-checked="false">FR</button>
          </div>
        </div>
        
        <!-- Inspector Body -->
        <div class="inspector-body">
          
          <!-- Syllable Label (monosyllable/clitic context) -->
          <div class="inspector-syllable-label" id="inspectorSyllableLabel"></div>
          
          <!-- Syllable Buttons (interactive IPA) -->
          <div class="inspector-syllable-header" id="inspectorSyllableHeader">
            <div class="inspector-syllable-display" id="inspectorSyllableDisplay"></div>
            <button class="boundary-reset-btn" id="inspectorBoundaryResetBtn" title="Reset syllable boundaries" aria-label="Reset syllable boundaries" style="display: none;">↺</button>
          </div>
          
          <!-- Stress source (proximity-grouped with syllable buttons) -->
          <div class="inspector-stress-source-row" id="inspectorStressSourceRow" aria-live="polite">
            <span class="inspector-control-label" data-i18n="inspector.stressLabel">Stress source:</span>
            <div class="segmented-control inspector-stress-source-control">
              <button class="segment" id="inspectorStressDictionary" data-source="dictionary" data-i18n="inspector.stressDictionary">Dictionary</button>
              <button class="segment" id="inspectorStressComposer" data-source="composer" data-i18n="inspector.stressComposer">Composer</button>
              <button class="segment" id="inspectorStressUser" data-source="user" data-i18n="inspector.stressUser">My choice</button>
            </div>
            <span class="stress-attribution-arrow" id="stressAttributionArrow" title="Please select the source for your stress decision">→</span>
          </div>
          
          <!-- Cyrillic Display -->
          <div class="inspector-cyrillic" id="inspectorCyrillic">—</div>
          
          <!-- Editable Gloss -->
          <div class="inspector-gloss-section">
            <span 
              class="inspector-gloss-inline" 
              id="inspectorGlossInline"
              contenteditable="true"
              role="textbox"
              aria-label="Translation"
              data-placeholder="add translation"
              data-i18n="inspector.glossPlaceholder" data-i18n-target="placeholder"
            ></span>
          </div>
          
          <!-- Phoneme Ribbon (Phase 3C) -->
          <div class="inspector-ribbon-section" id="inspectorRibbonSection">
            <div class="inspector-ribbon ribbon-vertical" id="inspectorRibbon">
              <!-- Populated by JavaScript -->
            </div>
          </div>
          
          <!-- Footer Controls (Phase 3D) -->
          <div class="inspector-controls" id="inspectorControls">
            
            <!-- Variant row (ё/е toggle) - rare but more common than assimilation -->
            <div class="inspector-control-row inspector-variant-row" id="inspectorVariantRow" style="display: none;">
              <div class="variant-row-main">
                <span class="inspector-control-label" id="inspectorVariantLabel" data-i18n="inspector.variantLabel">Restore ё:</span>
                <div class="segmented-control inspector-variant-control">
                  <button class="segment" id="inspectorVariantYo" data-variant="yo">ё</button>
                  <button class="segment" id="inspectorVariantYe" data-variant="ye">е</button>
                </div>
              </div>
              <div class="variant-confirm-row" id="inspectorVariantConfirm">
                <span class="variant-confirm-text">This changes the vowel sound and stress position.</span>
                <div class="variant-confirm-actions">
                  <button class="variant-cancel-btn" id="inspectorVariantCancel">Cancel</button>
                  <button class="variant-apply-btn" id="inspectorVariantApply">Apply</button>
                </div>
              </div>
            </div>
            
            <!-- Spacer pushes assimilation to bottom -->
            <div class="inspector-controls-spacer"></div>
            
            <!-- Assimilation row (word boundary control) - footer-docked, occasional use -->
            <div class="inspector-control-row inspector-assimilation-row" id="inspectorAssimilationRow" style="display: none;">
              <span class="inspector-control-label" id="inspectorBoundaryLabel" data-i18n="inspector.boundaryLabel">Break between [—] and [—]?</span>
              <div class="segmented-control inspector-assimilation-control">
                <button class="segment" id="inspectorAssimilationLinked" data-boundary="soft">No</button>
                <button class="segment" id="inspectorAssimilationSeparated" data-boundary="hard">Yes</button>
              </div>
            </div>
            
            <!-- Toast for ё warning -->
            <div class="inspector-yo-toast" id="inspectorYoToast">
              <span>ё → е changes pronunciation</span>
              <button class="undo-btn" id="inspectorYoUndoBtn">Undo</button>
            </div>
            
          </div>
          
        </div>
      </div>

    </aside>

    <!-- Scrim: tablet/mobile overlay backdrop -->
    <div class="drawer-scrim" id="drawerScrim"></div>
    
    <!-- Paper Aperture: Viewing area with inset depth -->
    <main class="paper-aperture" id="paperAperture">
      
      <!-- Paper Stack: Multi-page container (v5.9.4) -->
      <div class="paper-stack" id="paperStack">
        
        <!-- Pages render here dynamically -->
        
      </div>

    </main>

    <!-- Input Drawer: Bottom-anchored, collapsible -->
    <!-- Old input-drawer removed in Phase 2C - all input now in left drawer -->

  </div>

  <!-- Popup removed in Phase 3E - all functionality now in drawer inspector -->

  <script>
/* ==================================================
   STRESS DICTIONARY (Tiered Loading Architecture)
   Kaikki.org Wiktionary extract — 1.29M words
   
   Tier 1: 405K lemmas (loaded immediately)
   Tier 2: 887K inflections (lazy loaded on interaction)
   ================================================== */
let STRESS_DICTIONARY = {};
let DICTIONARY_LOADED = false;
let TIER2_LOADED = false;
let TIER2_LOADING = false;

// Gloss language state (v6.0.4)
// Supports bilingual glosses: {en: '...', fr: '...'}
let currentGlossLanguage = 'en';

// ========================================
// UI_LABELS + setUILanguage() (v6.0.54)
// i18n skin system for static UI text.
// Keys match data-i18n attributes (Phase A, item 4).
// Must be top-level scope so DocumentState/DrawerState can access.
// ========================================
const UI_LABELS = {
  'welcome.text': {
    en: 'Welcome to Ilya. Your name will appear in the footer of every transcription you make.',
    fr: 'Bienvenue sur Ilya. Votre nom apparaîtra au bas de chaque transcription que vous réaliserez.'
  },
  'welcome.save': {
    en: 'Save',
    fr: 'Enregistrer'
  },
  'input.placeholder': {
    en: 'Paste Russian lyrics here...',
    fr: 'Collez le texte russe ici...'
  },
  'btn.clear': {
    en: 'Clear',
    fr: 'Effacer'
  },
  'btn.transcribe': {
    en: 'Transcribe',
    fr: 'Transcrire'
  },
  'setup.heading': {
    en: 'Song Setup',
    fr: 'Détails du chant'
  },
  'setup.title': {
    en: 'Title',
    fr: 'Titre'
  },
  'setup.opus': {
    en: 'Opus / Catalogue',
    fr: 'Opus / Catalogue'
  },
  'setup.composer': {
    en: 'Composer',
    fr: 'Compositeur'
  },
  'setup.poet': {
    en: 'Poet / Librettist',
    fr: 'Poète / Librettiste'
  },
  'setup.name': {
    en: 'Your name (for attribution)',
    fr: 'Votre nom (pour l\u2019attribution)'
  },
  'setup.nameHint': {
    en: 'Appears in document footer',
    fr: 'Apparaît au bas du document'
  },
  'setup.filterPlaceholder': {
    en: 'Type to filter...',
    fr: 'Filtrer...'
  },
  'profile.label': {
    en: 'Transcription Profile',
    fr: 'Profil de transcription'
  },
  'page.heading': {
    en: 'Page',
    fr: 'Page'
  },
  'page.letter': {
    en: 'Letter',
    fr: 'Lettre'
  },
  'page.a4': {
    en: 'A4',
    fr: 'A4'
  },
  'page.exportPdf': {
    en: 'Export PDF',
    fr: 'Exporter en PDF'
  },
  'page.exportHint': {
    en: 'Opens print dialog. Select "Save as PDF".',
    fr: 'Ouvre la boîte d\u2019impression. Sélectionnez \u00ab\u202FEnregistrer en PDF\u202F\u00bb.'
  },
  'inspector.stressLabel': {
    en: 'Stress source:',
    fr: 'Source de l\u2019accent\u202F:'
  },
  'inspector.stressDictionary': {
    en: 'Dictionary',
    fr: 'Dictionnaire'
  },
  'inspector.stressComposer': {
    en: 'Composer',
    fr: 'Compositeur'
  },
  'inspector.stressUser': {
    en: 'My choice',
    fr: 'Mon choix'
  },
  'inspector.variantLabel': {
    en: 'Restore ё:',
    fr: 'Rétablir ё\u202F:'
  },
  'inspector.boundaryLabel': {
    en: 'Break between [—] and [—]?',
    fr: 'Coupure entre [—] et [—]\u202F?'
  },
  'inspector.glossPlaceholder': {
    en: 'add translation',
    fr: 'ajouter une traduction'
  },
  'inspector.clitic': {
    en: 'Unstressed clitic',
    fr: 'Clitique sans accent'
  },
  'inspector.stressedMono': {
    en: 'Stressed monosyllable',
    fr: 'Monosyllabe tonique'
  },
  'inspector.unstressedMono': {
    en: 'Unstressed monosyllable',
    fr: 'Monosyllabe sans accent'
  },
  'paper.verify': {
    en: 'verify',
    fr: 'vérifier'
  },
  'paper.songTitle': {
    en: 'Song Title',
    fr: 'Titre du chant'
  },
  'counter.chars': {
    en: 'chars',
    fr: 'car.'
  },
  'profile.oldMuscovite': {
    en: 'Old Muscovite',
    fr: 'Vieux muscovite'
  },
  'profile.peterburgian': {
    en: 'Peterburgian',
    fr: 'Petersbourgeois'
  },
  'profile.choral': {
    en: 'Choral',
    fr: 'Choral'
  },
  'profile.descOldMuscovite': {
    en: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]',
    fr: 'Réduction vocalique <em>ikanié</em>, [ʃʲː] pour щ, adjectivaux scéniques [ɨj]'
  },
  'profile.descPeterburgian': {
    en: 'Ekanye vowel reduction, [ʃtʃ] for щ, modern adjectivals [ij]',
    fr: 'Réduction vocalique <em>ékanié</em>, [ʃtʃ] pour щ, adjectivaux modernes [ij]'
  },
  'profile.descChoral': {
    en: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj], reduced intensity for vowel matching',
    fr: 'Réduction vocalique <em>ikanié</em>, [ʃʲː] pour щ, adjectivaux scéniques [ɨj], intensité réduite pour l\u2019harmonisation vocalique'
  },
  'page.paperSize': {
    en: 'Paper Size',
    fr: 'Format du papier'
  },
  'page.viewProfiles': {
    en: 'View all profiles \u2192',
    fr: 'Voir tous les profils \u2192'
  },
  'page.countOne': {
    en: '1 page',
    fr: '1 page'
  },
  'page.countMany': {
    en: '{n} pages',
    fr: '{n} pages'
  }
};

/**
 * setUILanguage(lang)
 * Walks all elements with [data-i18n] and swaps their visible text.
 * Handles four target types:
 *   - placeholder: elements with data-i18n-target="placeholder"
 *   - aria-label: elements with data-i18n-target="aria"
 *   - html: elements with data-i18n-target="html" (allows <em> etc.)
 *   - textContent: default
 * Also refreshes profile section for current selection.
 * Falls back to English for any missing key.
 */
function setUILanguage(lang) {
  const target = (lang === 'fr') ? 'fr' : 'en';
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    const entry = UI_LABELS[key];
    if (!entry) return;
    const text = entry[target] || entry.en;
    const mode = el.getAttribute('data-i18n-target');
    if (mode === 'placeholder') {
      // Native inputs use .placeholder; contenteditable uses data-placeholder
      if (el.hasAttribute('placeholder')) {
        el.placeholder = text;
      } else {
        el.setAttribute('data-placeholder', text);
      }
    } else if (mode === 'aria') {
      el.setAttribute('aria-label', text);
    } else if (mode === 'html') {
      el.innerHTML = text;
    } else {
      el.textContent = text;
    }
  });
  
  // Refresh profile section for current selection (v6.0.54)
  if (typeof ProfileController !== 'undefined' && ProfileController.currentProfile) {
    ProfileController.setProfile(ProfileController.currentProfile);
  }
}

/**
 * Extract gloss in current language from new bilingual format
 * Handles both old format (string) and new format ({en, fr})
 */
function extractGloss(g) {
  if (!g) return currentGlossLanguage === 'fr' ? 'À VÉRIFIER' : '';
  
  // String format = English-only (legacy)
  if (typeof g === 'string') {
    return currentGlossLanguage === 'fr' ? 'À VÉRIFIER' : g;
  }
  
  // Object format = bilingual
  if (typeof g === 'object') {
    if (currentGlossLanguage === 'fr') {
      return g.fr || 'À VÉRIFIER';
    }
    return g.en || g.fr || '';
  }
  
  return '';
}

/**
 * Extract blurb text in current gloss language from bilingual format
 * Handles both old format (string) and new format ({en, fr})
 * @param {Object} blurbData - The blurb object with .blurb property
 * @returns {string} The blurb text in the current language
 */
function extractBlurbText(blurbData) {
  if (!blurbData || !blurbData.blurb) return '';
  
  const blurbContent = blurbData.blurb;
  
  // String format = English-only (legacy)
  let text;
  if (typeof blurbContent === 'string') {
    text = blurbContent;
  } else if (typeof blurbContent === 'object') {
    text = blurbContent[currentGlossLanguage] || blurbContent.en || '';
  } else {
    return '';
  }
  
  // Prevent IPA notation from breaking across lines (v6.0.52)
  // Wraps /…/, […], and ⟨…⟩ in nowrap spans
  text = text.replace(/\/[^/]+\//g, m => `<span style="white-space:nowrap">${m}</span>`);
  text = text.replace(/\[[^\]]+\]/g, m => `<span style="white-space:nowrap">${m}</span>`);
  text = text.replace(/⟨[^⟩]+⟩/g, m => `<span style="white-space:nowrap">${m}</span>`);
  
  return text;
}

// ==========================================
// GAP ANALYSIS: French gloss coverage (v6.0.11)
// Run from console: analyzeGlossGaps()
// ==========================================
function analyzeGlossGaps() {
  const results = {
    supplement: { total: 0, bilingual: 0, englishOnly: 0, noGloss: 0, gaps: [] },
    dictionary: { total: 0, bilingual: 0, englishOnly: 0, noGloss: 0, gaps: [] }
  };
  
  // Analyze SINGER_SUPPLEMENT
  for (const [word, entry] of Object.entries(SINGER_SUPPLEMENT)) {
    results.supplement.total++;
    const g = entry.gloss;
    if (!g) {
      results.supplement.noGloss++;
    } else if (typeof g === 'object' && g.fr) {
      results.supplement.bilingual++;
    } else {
      results.supplement.englishOnly++;
      results.supplement.gaps.push(word);
    }
  }
  
  // Analyze STRESS_DICTIONARY (Tier 1 + Tier 2)
  for (const [word, entry] of Object.entries(STRESS_DICTIONARY)) {
    results.dictionary.total++;
    // Entry can be object or array
    const e = Array.isArray(entry) ? entry[0] : entry;
    const g = e.gloss || e.g;
    if (!g) {
      results.dictionary.noGloss++;
    } else if (typeof g === 'object' && g.fr) {
      results.dictionary.bilingual++;
    } else {
      results.dictionary.englishOnly++;
      // Only collect first 100 gaps as sample
      if (results.dictionary.gaps.length < 100) {
        results.dictionary.gaps.push(word);
      }
    }
  }
  
  // Calculate percentages
  const suppCoverage = results.supplement.total > 0 
    ? ((results.supplement.bilingual / results.supplement.total) * 100).toFixed(1)
    : 0;
  const dictCoverage = results.dictionary.total > 0
    ? ((results.dictionary.bilingual / results.dictionary.total) * 100).toFixed(1)
    : 0;
  
  console.log('\n========== FRENCH GLOSS GAP ANALYSIS ==========\n');
  
  console.log('SINGER_SUPPLEMENT:');
  console.log(`  Total entries:    ${results.supplement.total}`);
  console.log(`  Bilingual:        ${results.supplement.bilingual} (${suppCoverage}%)`);
  console.log(`  English-only:     ${results.supplement.englishOnly}`);
  console.log(`  No gloss:         ${results.supplement.noGloss}`);
  if (results.supplement.gaps.length > 0) {
    console.log(`  Gaps preview:     ${results.supplement.gaps.slice(0, 20).join(', ')}${results.supplement.gaps.length > 20 ? '...' : ''}`);
  }
  
  console.log('\nSTRESS_DICTIONARY:');
  console.log(`  Total entries:    ${results.dictionary.total.toLocaleString()}`);
  console.log(`  Bilingual:        ${results.dictionary.bilingual.toLocaleString()} (${dictCoverage}%)`);
  console.log(`  English-only:     ${results.dictionary.englishOnly.toLocaleString()}`);
  console.log(`  No gloss:         ${results.dictionary.noGloss.toLocaleString()}`);
  if (results.dictionary.gaps.length > 0) {
    console.log(`  Gaps sample:      ${results.dictionary.gaps.slice(0, 20).join(', ')}...`);
  }
  
  console.log('\n================================================\n');
  
  return results;
}

// Tier 1: Load immediately, blocks until ready
async function loadTier1() {
    try {
        const response = await fetch('data/ilya_tier1_final.json.gz');
        if (response.ok) {
            const compressed = await response.arrayBuffer();
            const decompressed = pako.inflate(new Uint8Array(compressed), { to: 'string' });
            STRESS_DICTIONARY = JSON.parse(decompressed);
            DICTIONARY_LOADED = true;
            console.log(`Tier 1: ${Object.keys(STRESS_DICTIONARY).length.toLocaleString()} lemmas`);
            return;
        }
        
        // Fallback to legacy dictionary if tier1 not found
        const legacyResponse = await fetch('data/ilya_dictionary.json.gz');
        if (legacyResponse.ok) {
            const compressed = await legacyResponse.arrayBuffer();
            const decompressed = pako.inflate(new Uint8Array(compressed), { to: 'string' });
            STRESS_DICTIONARY = JSON.parse(decompressed);
            DICTIONARY_LOADED = true;
            console.log(`Legacy dictionary: ${Object.keys(STRESS_DICTIONARY).length.toLocaleString()} words`);
            return;
        }
        
        console.warn('No dictionary file found, stress lookup disabled');
    } catch (error) {
        console.warn('Could not load Tier 1 dictionary:', error);
    }
}

// Tier 2: Lazy load with chunked merge to avoid UI freeze
async function loadTier2() {
    if (TIER2_LOADING || TIER2_LOADED) return;
    TIER2_LOADING = true;
    
    try {
        const response = await fetch('data/ilya_tier2.json.gz');
        if (!response.ok) {
            console.warn('Tier 2 not available');
            return;
        }
        
        const compressed = await response.arrayBuffer();
        const decompressed = pako.inflate(new Uint8Array(compressed), { to: 'string' });
        const inflections = JSON.parse(decompressed);
        
        // Chunked merge: 10K entries per frame to prevent UI jank
        const entries = Object.entries(inflections);
        const chunkSize = 10000;
        
        for (let i = 0; i < entries.length; i += chunkSize) {
            const chunk = entries.slice(i, i + chunkSize);
            chunk.forEach(([k, v]) => STRESS_DICTIONARY[k] = v);
            
            // Yield to main thread between chunks
            if (i + chunkSize < entries.length) {
                await new Promise(resolve => requestAnimationFrame(resolve));
            }
        }
        
        TIER2_LOADED = true;
        console.log(`Tier 2: ${entries.length.toLocaleString()} inflections merged`);
        console.log(`Total: ${Object.keys(STRESS_DICTIONARY).length.toLocaleString()} words`);
        
    } catch (error) {
        console.warn('Tier 2 load failed:', error);
    } finally {
        TIER2_LOADING = false;
    }
}

// Trigger Tier 2 on first user interaction or after 5 seconds
let tier2Triggered = false;
function triggerTier2Load() {
    if (!tier2Triggered) {
        tier2Triggered = true;
        // Small delay to ensure UI is fully responsive first
        setTimeout(loadTier2, 100);
    }
}

// Attach interaction listeners (fire once)
document.addEventListener('click', triggerTier2Load, { once: true });
document.addEventListener('keydown', triggerTier2Load, { once: true });
document.addEventListener('paste', triggerTier2Load, { once: true });

// Safety: Load Tier 2 after 5 seconds regardless
setTimeout(triggerTier2Load, 5000);

// Start Tier 1 immediately
loadTier1();

/* ==================================================
   SINGER'S MONOSYLLABLE SUPPLEMENT
   Common words missing from OpenRussian dictionary
   ================================================== */
const SINGER_SUPPLEMENT = {
    // ========================================
    // BILINGUAL GLOSSES (v6.0.12)
    // French translations: Batches 1–16 complete
    // 100% bilingual coverage — Feb 3, 2026
    // ========================================
    
    // Batch 1: Pronouns
    'я': { stress: 0, gloss: { en: 'I', fr: 'je' }, source: 'supplement' },
    'ты': { stress: 0, gloss: { en: 'you (informal)', fr: 'tu' }, source: 'supplement' },
    'он': { stress: 0, gloss: { en: 'he', fr: 'il' }, source: 'supplement' },
    'мы': { stress: 0, gloss: { en: 'we', fr: 'nous' }, source: 'supplement' },
    'вы': { stress: 0, gloss: { en: 'you (formal/plural)', fr: 'vous' }, source: 'supplement' },
    'мне': { stress: 0, gloss: { en: 'to me', fr: 'à moi' }, source: 'supplement' },
    'мной': { stress: 0, gloss: { en: 'with me', fr: 'avec moi' }, source: 'supplement' },
    'нам': { stress: 0, gloss: { en: 'to us', fr: 'à nous' }, source: 'supplement' },
    'вам': { stress: 0, gloss: { en: 'to you', fr: 'à vous' }, source: 'supplement' },
    'вас': { stress: 0, gloss: { en: 'you (acc.)', fr: 'vous' }, source: 'supplement' },
    'нас': { stress: 0, gloss: { en: 'us', fr: 'nous' }, source: 'supplement' },
    'кто': { stress: 0, gloss: { en: 'who', fr: 'qui' }, source: 'supplement' },
    'что': { stress: 0, gloss: { en: 'what', fr: 'quoi' }, source: 'supplement' },
    'чём': { stress: 0, gloss: { en: 'what (prep.)', fr: 'quoi (prép.)' }, source: 'supplement' },
    'всё': { stress: 0, gloss: { en: 'everything', fr: 'tout' }, source: 'supplement' },
    'все': { stress: 0, gloss: { en: 'everyone', fr: 'tous' }, source: 'supplement' },
    'сам': { stress: 0, gloss: { en: 'oneself', fr: 'soi-même' }, source: 'supplement' },
    
    // Batch 2: Possessives
    'мой': { stress: 0, gloss: { en: 'my', fr: 'mon' }, source: 'supplement' },
    'моя': { stress: 1, gloss: { en: 'my (fem.)', fr: 'ma' }, source: 'supplement' },
    'моё': { stress: 1, gloss: { en: 'my (neut.)', fr: 'mon (n.)' }, source: 'supplement' },
    'моей': { stress: 1, gloss: { en: 'my (gen./dat./prep. fem.)', fr: 'de ma (gén./dat./prép.)' }, source: 'supplement' },
    'твой': { stress: 0, gloss: { en: 'your', fr: 'ton' }, source: 'supplement' },
    'твоя': { stress: 1, gloss: { en: 'your (fem.)', fr: 'ta' }, source: 'supplement' },
    'твоё': { stress: 1, gloss: { en: 'your (neut.)', fr: 'ton (n.)' }, source: 'supplement' },
    'твоей': { stress: 1, gloss: { en: 'your (gen./dat./prep. fem.)', fr: 'de ta (gén./dat./prép.)' }, source: 'supplement' },
    'её': { stress: 1, gloss: { en: 'her/hers', fr: 'son/sa' }, source: 'supplement' },
    'свой': { stress: 0, gloss: { en: "one's own", fr: 'son propre' }, source: 'supplement' },
    'наш': { stress: 0, gloss: { en: 'our', fr: 'notre' }, source: 'supplement' },
    'ваш': { stress: 0, gloss: { en: 'your (formal)', fr: 'votre' }, source: 'supplement' },
    
    // Batch 3: Demonstratives, Locatives & Particles
    'весь': { stress: 0, gloss: { en: 'all/whole', fr: 'tout/entier' }, source: 'supplement' },
    'тот': { stress: 0, gloss: { en: 'that', fr: 'celui-là' }, source: 'supplement' },
    'там': { stress: 0, gloss: { en: 'there', fr: 'là-bas' }, source: 'supplement' },
    'тут': { stress: 0, gloss: { en: 'here', fr: 'ici' }, source: 'supplement' },
    'где': { stress: 0, gloss: { en: 'where', fr: 'où' }, source: 'supplement' },
    'здесь': { stress: 0, gloss: { en: 'here', fr: 'ici' }, source: 'supplement' },
    'не': { stress: 0, gloss: { en: 'not', fr: 'ne' }, source: 'supplement' },
    'ни': { stress: 0, gloss: { en: 'nor/not a', fr: 'ni' }, source: 'supplement' },
    'да': { stress: 0, gloss: { en: 'yes/and', fr: 'oui/et' }, source: 'supplement' },
    'нет': { stress: 0, gloss: { en: 'no', fr: 'non' }, source: 'supplement' },
    'вот': { stress: 0, gloss: { en: 'here is', fr: 'voici' }, source: 'supplement' },
    'уж': { stress: 0, gloss: { en: 'already', fr: 'déjà' }, source: 'supplement' },
    'ещё': { stress: 0, gloss: { en: 'still/yet', fr: 'encore' }, source: 'supplement' },
    'уже': { stress: 0, gloss: { en: 'already', fr: 'déjà' }, source: 'supplement' },
    'так': { stress: 0, gloss: { en: 'so/thus', fr: 'ainsi' }, source: 'supplement' },
    'как': { stress: 0, gloss: { en: 'how/as', fr: 'comme' }, source: 'supplement' },
    'чем': { stress: 0, gloss: { en: 'than', fr: 'que' }, source: 'supplement' },
    'но': { stress: 0, gloss: { en: 'but', fr: 'mais' }, source: 'supplement' },
    'а': { stress: 0, gloss: { en: 'and/but', fr: 'et/mais' }, source: 'supplement' },
    'и': { stress: 0, gloss: { en: 'and', fr: 'et' }, source: 'supplement' },
    'то': { stress: 0, gloss: { en: 'then/that', fr: 'alors/cela' }, source: 'supplement' },
    'же': { stress: 0, gloss: { en: '(emphasis)', fr: '(emphase)' }, source: 'supplement' },
    'ли': { stress: 0, gloss: { en: '(question)', fr: '(interr.)' }, source: 'supplement' },
    'ль': { stress: 0, gloss: { en: '(question)', fr: '(interr.)' }, source: 'supplement' },
    
    // Batch 4: Prepositions
    'о': { stress: 0, gloss: { en: 'about', fr: 'de/sur' }, source: 'supplement' },
    'об': { stress: 0, gloss: { en: 'about', fr: 'de/sur' }, source: 'supplement' },
    'в': { stress: 0, gloss: { en: 'in/into', fr: 'dans' }, source: 'supplement' },
    'во': { stress: 0, gloss: { en: 'in/into', fr: 'dans' }, source: 'supplement' },
    'к': { stress: 0, gloss: { en: 'to/toward', fr: 'vers' }, source: 'supplement' },
    'ко': { stress: 0, gloss: { en: 'to/toward', fr: 'vers' }, source: 'supplement' },
    'с': { stress: 0, gloss: { en: 'with/from', fr: 'avec/de' }, source: 'supplement' },
    'со': { stress: 0, gloss: { en: 'with/from', fr: 'avec/de' }, source: 'supplement' },
    'у': { stress: 0, gloss: { en: 'at/by', fr: 'chez/près de' }, source: 'supplement' },
    'на': { stress: 0, gloss: { en: 'on/onto', fr: 'sur' }, source: 'supplement' },
    'за': { stress: 0, gloss: { en: 'behind/for', fr: 'derrière/pour' }, source: 'supplement' },
    'по': { stress: 0, gloss: { en: 'along/by', fr: 'le long de' }, source: 'supplement' },
    'до': { stress: 0, gloss: { en: 'until/to', fr: "jusqu'à" }, source: 'supplement' },
    'из': { stress: 0, gloss: { en: 'from/out of', fr: 'de/hors de' }, source: 'supplement' },
    'от': { stress: 0, gloss: { en: 'from', fr: 'de' }, source: 'supplement' },
    'при': { stress: 0, gloss: { en: 'at/by/in presence of', fr: 'en présence de' }, source: 'supplement' },
    'для': { stress: 0, gloss: { en: 'for', fr: 'pour' }, source: 'supplement' },
    'без': { stress: 0, gloss: { en: 'without', fr: 'sans' }, source: 'supplement' },
    'под': { stress: 0, gloss: { en: 'under', fr: 'sous' }, source: 'supplement' },
    'над': { stress: 0, gloss: { en: 'above', fr: 'au-dessus de' }, source: 'supplement' },
    'про': { stress: 0, gloss: { en: 'about', fr: 'au sujet de' }, source: 'supplement' },
    'сквозь': { stress: 0, gloss: { en: 'through', fr: 'à travers' }, source: 'supplement' },
    'вдоль': { stress: 0, gloss: { en: 'along', fr: 'le long de' }, source: 'supplement' },
    
    // Batch 5: Imperatives & Infinitives
    'пой': { stress: 0, gloss: { en: 'sing!', fr: 'chante !' }, source: 'supplement' },
    'дай': { stress: 0, gloss: { en: 'give!', fr: 'donne !' }, source: 'supplement' },
    'стой': { stress: 0, gloss: { en: 'stop!/stand!', fr: 'arrête !/reste !' }, source: 'supplement' },
    'спи': { stress: 0, gloss: { en: 'sleep!', fr: 'dors !' }, source: 'supplement' },
    'жди': { stress: 0, gloss: { en: 'wait!', fr: 'attends !' }, source: 'supplement' },
    'иди': { stress: 0, gloss: { en: 'go!', fr: 'va !' }, source: 'supplement' },
    'будь': { stress: 0, gloss: { en: 'be!', fr: 'sois !' }, source: 'supplement' },
    'знай': { stress: 0, gloss: { en: 'know!', fr: 'sache !' }, source: 'supplement' },
    'верь': { stress: 0, gloss: { en: 'believe!', fr: 'crois !' }, source: 'supplement' },
    'жить': { stress: 0, gloss: { en: 'to live', fr: 'vivre' }, source: 'supplement' },
    'быть': { stress: 0, gloss: { en: 'to be', fr: 'être' }, source: 'supplement' },
    'петь': { stress: 0, gloss: { en: 'to sing', fr: 'chanter' }, source: 'supplement' },
    'спать': { stress: 0, gloss: { en: 'to sleep', fr: 'dormir' }, source: 'supplement' },
    'ждать': { stress: 0, gloss: { en: 'to wait', fr: 'attendre' }, source: 'supplement' },
    'знать': { stress: 0, gloss: { en: 'to know', fr: 'savoir' }, source: 'supplement' },
    'дать': { stress: 0, gloss: { en: 'to give', fr: 'donner' }, source: 'supplement' },
    'стать': { stress: 0, gloss: { en: 'to become', fr: 'devenir' }, source: 'supplement' },
    'думать': { stress: 0, gloss: { en: 'to think', fr: 'penser' }, source: 'supplement' },
    'играть': { stress: 1, gloss: { en: 'to play', fr: 'jouer' }, source: 'supplement' },
    
    // Batch 6: Past & Present Tense Forms
    'был': { stress: 0, gloss: { en: 'was (m.)', fr: 'était (m.)' }, source: 'supplement' },
    'была': { stress: 1, gloss: { en: 'was (f.)', fr: 'était (f.)' }, source: 'supplement' },
    'было': { stress: 0, gloss: { en: 'was (n.)', fr: 'était (n.)' }, source: 'supplement' },
    'были': { stress: 0, gloss: { en: 'were', fr: 'étaient' }, source: 'supplement' },
    'сказал': { stress: 1, gloss: { en: 'said/told', fr: 'dit' }, source: 'supplement' },
    'думаю': { stress: 0, gloss: { en: 'I think', fr: 'je pense' }, source: 'supplement' },
    'думаешь': { stress: 0, gloss: { en: 'you think', fr: 'tu penses' }, source: 'supplement' },
    'есть': { stress: 0, gloss: { en: 'is/to eat', fr: 'est/il y a/manger' }, source: 'supplement' },
    
    // Batch 7: Nouns — Time & Nature
    'ночь': { stress: 0, gloss: { en: 'night', fr: 'nuit' }, source: 'supplement' },
    'день': { stress: 0, gloss: { en: 'day', fr: 'jour' }, source: 'supplement' },
    'путь': { stress: 0, gloss: { en: 'path/way', fr: 'chemin' }, source: 'supplement' },
    'свет': { stress: 0, gloss: { en: 'light', fr: 'lumière' }, source: 'supplement' },
    'мир': { stress: 0, gloss: { en: 'world/peace', fr: 'monde/paix' }, source: 'supplement' },
    'сон': { stress: 0, gloss: { en: 'dream/sleep', fr: 'rêve/sommeil' }, source: 'supplement' },
    'дом': { stress: 0, gloss: { en: 'home/house', fr: 'maison' }, source: 'supplement' },
    'сад': { stress: 0, gloss: { en: 'garden', fr: 'jardin' }, source: 'supplement' },
    'лес': { stress: 0, gloss: { en: 'forest', fr: 'forêt' }, source: 'supplement' },
    'дождь': { stress: 0, gloss: { en: 'rain', fr: 'pluie' }, source: 'supplement' },
    'снег': { stress: 0, gloss: { en: 'snow', fr: 'neige' }, source: 'supplement' },
    'лёд': { stress: 0, gloss: { en: 'ice', fr: 'glace' }, source: 'supplement' },
    'огонь': { stress: 0, gloss: { en: 'fire', fr: 'feu' }, source: 'supplement' },
    'вода': { stress: 0, gloss: { en: 'water', fr: 'eau' }, source: 'supplement' },
    'земля': { stress: 0, gloss: { en: 'earth', fr: 'terre' }, source: 'supplement' },
    'край': { stress: 0, gloss: { en: 'edge/land', fr: 'bord/pays' }, source: 'supplement' },
    'гром': { stress: 0, gloss: { en: 'thunder', fr: 'tonnerre' }, source: 'supplement' },
    'шум': { stress: 0, gloss: { en: 'noise', fr: 'bruit' }, source: 'supplement' },
    
    // Batch 8: Nouns — People & Relationships
    'бог': { stress: 0, gloss: { en: 'god', fr: 'dieu' }, source: 'supplement' },
    'царь': { stress: 0, gloss: { en: 'tsar', fr: 'tsar' }, source: 'supplement' },
    'князь': { stress: 0, gloss: { en: 'prince', fr: 'prince' }, source: 'supplement' },
    'дух': { stress: 0, gloss: { en: 'spirit', fr: 'esprit' }, source: 'supplement' },
    'друг': { stress: 0, gloss: { en: 'friend', fr: 'ami' }, source: 'supplement' },
    'враг': { stress: 0, gloss: { en: 'enemy', fr: 'ennemi' }, source: 'supplement' },
    'брат': { stress: 0, gloss: { en: 'brother', fr: 'frère' }, source: 'supplement' },
    'сын': { stress: 0, gloss: { en: 'son', fr: 'fils' }, source: 'supplement' },
    'муж': { stress: 0, gloss: { en: 'husband', fr: 'mari' }, source: 'supplement' },
    'мама': { stress: 0, gloss: { en: 'mama', fr: 'maman' }, source: 'supplement' },
    'маме': { stress: 0, gloss: { en: 'to mama', fr: 'à maman' }, source: 'supplement' },
    'красавица': { stress: 1, gloss: { en: 'beauty', fr: 'beauté' }, source: 'supplement' },
    
    // Batch 9: Nouns — Abstract
    'жизнь': { stress: 0, gloss: { en: 'life', fr: 'vie' }, source: 'supplement' },
    'любовь': { stress: 1, gloss: { en: 'love', fr: 'amour' }, source: 'supplement' },
    'любви': { stress: 1, gloss: { en: 'of love', fr: "d'amour" }, source: 'supplement' },
    'правда': { stress: 0, gloss: { en: 'truth', fr: 'vérité' }, source: 'supplement' },
    'правду': { stress: 0, gloss: { en: 'truth (acc.)', fr: 'vérité (acc.)' }, source: 'supplement' },
    'смерть': { stress: 0, gloss: { en: 'death', fr: 'mort' }, source: 'supplement' },
    'боль': { stress: 0, gloss: { en: 'pain', fr: 'douleur' }, source: 'supplement' },
    'грусть': { stress: 0, gloss: { en: 'sadness', fr: 'tristesse' }, source: 'supplement' },
    'страсть': { stress: 0, gloss: { en: 'passion', fr: 'passion' }, source: 'supplement' },
    'честь': { stress: 0, gloss: { en: 'honor', fr: 'honneur' }, source: 'supplement' },
    'власть': { stress: 0, gloss: { en: 'power', fr: 'pouvoir' }, source: 'supplement' },
    'часть': { stress: 0, gloss: { en: 'part', fr: 'partie' }, source: 'supplement' },
    'речь': { stress: 0, gloss: { en: 'speech', fr: 'parole' }, source: 'supplement' },
    'мысль': { stress: 0, gloss: { en: 'thought', fr: 'pensée' }, source: 'supplement' },
    'кровь': { stress: 0, gloss: { en: 'blood', fr: 'sang' }, source: 'supplement' },
    'грудь': { stress: 0, gloss: { en: 'chest/breast', fr: 'poitrine' }, source: 'supplement' },
    'взор': { stress: 0, gloss: { en: 'gaze', fr: 'regard' }, source: 'supplement' },
    'взгляд': { stress: 0, gloss: { en: 'glance', fr: "coup d'œil" }, source: 'supplement' },
    'слух': { stress: 0, gloss: { en: 'hearing/rumor', fr: 'ouïe/rumeur' }, source: 'supplement' },
    'рай': { stress: 0, gloss: { en: 'paradise', fr: 'paradis' }, source: 'supplement' },
    'ад': { stress: 0, gloss: { en: 'hell', fr: 'enfer' }, source: 'supplement' },
    
    // Batch 10: Adjectives — Short Forms
    'русский': { stress: 0, pos: 'adj.', gloss: { en: 'Russian', fr: 'russe' }, source: 'supplement' },
    'рад': { stress: 0, gloss: { en: 'glad', fr: 'content' }, source: 'supplement' },
    'сыт': { stress: 0, gloss: { en: 'full/sated', fr: 'rassasié' }, source: 'supplement' },
    'злой': { stress: 0, gloss: { en: 'evil/angry', fr: 'méchant/fâché' }, source: 'supplement' },
    'свят': { stress: 0, gloss: { en: 'holy', fr: 'saint' }, source: 'supplement' },
    'прав': { stress: 0, gloss: { en: 'right/correct', fr: 'juste' }, source: 'supplement' },
    'жив': { stress: 0, gloss: { en: 'alive', fr: 'vivant' }, source: 'supplement' },
    'мёртв': { stress: 0, gloss: { en: 'dead', fr: 'mort' }, source: 'supplement' },
    'нов': { stress: 0, gloss: { en: 'new', fr: 'nouveau' }, source: 'supplement' },
    'стар': { stress: 0, gloss: { en: 'old', fr: 'vieux' }, source: 'supplement' },
    'юн': { stress: 0, gloss: { en: 'young', fr: 'jeune' }, source: 'supplement' },
    'мил': { stress: 0, gloss: { en: 'dear/sweet', fr: 'cher/doux' }, source: 'supplement' },
    'люб': { stress: 0, gloss: { en: 'beloved', fr: 'bien-aimé' }, source: 'supplement' },
    'забвенный': { stress: 0, gloss: { en: 'forgotten', fr: 'oublié' }, source: 'supplement' },
    'охладелый': { stress: 2, gloss: { en: 'cold, dead', fr: 'refroidi' }, source: 'supplement' },
    
    // Batch 11: Adverbs & More Particles
    'бы': { stress: 0, gloss: { en: 'would', fr: '(cond.)' }, source: 'supplement' },
    'б': { stress: 0, gloss: { en: 'would', fr: '(cond.)' }, source: 'supplement' },
    'хоть': { stress: 0, gloss: { en: 'although', fr: 'bien que' }, source: 'supplement' },
    'пусть': { stress: 0, gloss: { en: 'let', fr: 'que' }, source: 'supplement' },
    'лишь': { stress: 0, gloss: { en: 'only', fr: 'seulement' }, source: 'supplement' },
    'вновь': { stress: 0, gloss: { en: 'again', fr: 'de nouveau' }, source: 'supplement' },
    'вдруг': { stress: 0, gloss: { en: 'suddenly', fr: 'soudain' }, source: 'supplement' },
    'прочь': { stress: 0, gloss: { en: 'away', fr: 'loin' }, source: 'supplement' },
    'вниз': { stress: 0, gloss: { en: 'down', fr: 'en bas' }, source: 'supplement' },
    'вверх': { stress: 0, gloss: { en: 'up', fr: 'en haut' }, source: 'supplement' },
    'чуть': { stress: 0, gloss: { en: 'barely', fr: 'à peine' }, source: 'supplement' },
    'близко': { stress: 0, gloss: { en: 'near', fr: 'près' }, source: 'supplement' },
    'далеко': { stress: 2, gloss: { en: 'far', fr: 'loin' }, source: 'supplement' },
    'высоко': { stress: 2, gloss: { en: 'high', fr: 'haut' }, source: 'supplement' },
    'глубоко': { stress: 2, gloss: { en: 'deep', fr: 'profond' }, source: 'supplement' },
    
    // Batch 12: Adverbs — Manner & Comparatives
    'тихо': { stress: 0, gloss: { en: 'quietly', fr: 'doucement' }, source: 'supplement' },
    'громко': { stress: 0, gloss: { en: 'loudly', fr: 'fort' }, source: 'supplement' },
    'быстро': { stress: 0, gloss: { en: 'quickly', fr: 'vite' }, source: 'supplement' },
    'медленно': { stress: 0, gloss: { en: 'slowly', fr: 'lentement' }, source: 'supplement' },
    'тепло': { stress: 1, gloss: { en: 'warmly', fr: 'chaudement' }, source: 'supplement' },
    'холодно': { stress: 0, gloss: { en: 'coldly', fr: 'froidement' }, source: 'supplement' },
    'светло': { stress: 1, gloss: { en: 'brightly', fr: 'clairement' }, source: 'supplement' },
    'темно': { stress: 1, gloss: { en: 'darkly', fr: 'sombrement' }, source: 'supplement' },
    'ясно': { stress: 0, gloss: { en: 'clearly', fr: 'clairement' }, source: 'supplement' },
    'страшно': { stress: 0, gloss: { en: 'terribly', fr: 'terriblement' }, source: 'supplement' },
    'больно': { stress: 0, gloss: { en: 'painfully', fr: 'douloureusement' }, source: 'supplement' },
    'грустно': { stress: 0, gloss: { en: 'sadly', fr: 'tristement' }, source: 'supplement' },
    'радостно': { stress: 0, gloss: { en: 'joyfully', fr: 'joyeusement' }, source: 'supplement' },
    'нежно': { stress: 0, gloss: { en: 'tenderly', fr: 'tendrement' }, source: 'supplement' },
    'ближе': { stress: 0, gloss: { en: 'closer', fr: 'plus près' }, source: 'supplement' },
    'дальше': { stress: 0, gloss: { en: 'farther', fr: 'plus loin' }, source: 'supplement' },
    'выше': { stress: 0, gloss: { en: 'higher', fr: 'plus haut' }, source: 'supplement' },
    
    // ========================================
    // BATCHES 13-16: Approved Feb 3, 2026
    // ========================================
    
    // Batch 13: Comparatives
    'ниже': { stress: 0, gloss: { en: 'lower', fr: 'plus bas' }, source: 'supplement' },
    'громче': { stress: 0, gloss: { en: 'louder', fr: 'plus fort' }, source: 'supplement' },
    'тише': { stress: 0, gloss: { en: 'quieter', fr: 'plus doucement' }, source: 'supplement' },
    'быстрее': { stress: 1, gloss: { en: 'faster', fr: 'plus vite' }, source: 'supplement' },
    'сильнее': { stress: 1, gloss: { en: 'stronger', fr: 'plus fort' }, source: 'supplement' },
    'слаще': { stress: 0, gloss: { en: 'sweeter', fr: 'plus doux' }, source: 'supplement' },
    'горче': { stress: 0, gloss: { en: 'more bitter', fr: 'plus amer' }, source: 'supplement' },
    'ярче': { stress: 0, gloss: { en: 'brighter', fr: 'plus brillant' }, source: 'supplement' },
    'темнее': { stress: 1, gloss: { en: 'darker', fr: 'plus sombre' }, source: 'supplement' },
    'теплее': { stress: 1, gloss: { en: 'warmer', fr: 'plus chaud' }, source: 'supplement' },
    'холоднее': { stress: 2, gloss: { en: 'colder', fr: 'plus froid' }, source: 'supplement' },
    'нежнее': { stress: 1, gloss: { en: 'more tender', fr: 'plus tendre' }, source: 'supplement' },
    'краше': { stress: 0, gloss: { en: 'fairer', fr: 'plus beau' }, source: 'supplement' },
    'глубже': { stress: 0, gloss: { en: 'deeper', fr: 'plus profond' }, source: 'supplement' },
    'дороже': { stress: 1, gloss: { en: 'dearer', fr: 'plus cher' }, source: 'supplement' },
    
    // Batch 14: Adjective inflections -ых/-их (first 20)
    'шумных': { stress: 0, gloss: { en: 'noisy (gen./prep. pl.)', fr: 'bruyants (gén./prép. pl.)' }, source: 'supplement' },
    'тихих': { stress: 0, gloss: { en: 'quiet (gen./prep. pl.)', fr: 'calmes (gén./prép. pl.)' }, source: 'supplement' },
    'темных': { stress: 0, gloss: { en: 'dark (gen./prep. pl.)', fr: 'sombres (gén./prép. pl.)' }, source: 'supplement' },
    'светлых': { stress: 0, gloss: { en: 'bright (gen./prep. pl.)', fr: 'clairs (gén./prép. pl.)' }, source: 'supplement' },
    'белых': { stress: 0, gloss: { en: 'white (gen./prep. pl.)', fr: 'blancs (gén./prép. pl.)' }, source: 'supplement' },
    'чёрных': { stress: 0, gloss: { en: 'black (gen./prep. pl.)', fr: 'noirs (gén./prép. pl.)' }, source: 'supplement' },
    'красных': { stress: 0, gloss: { en: 'red (gen./prep. pl.)', fr: 'rouges (gén./prép. pl.)' }, source: 'supplement' },
    'синих': { stress: 0, gloss: { en: 'blue (gen./prep. pl.)', fr: 'bleus (gén./prép. pl.)' }, source: 'supplement' },
    'ясных': { stress: 0, gloss: { en: 'clear (gen./prep. pl.)', fr: 'clairs (gén./prép. pl.)' }, source: 'supplement' },
    'нежных': { stress: 0, gloss: { en: 'tender (gen./prep. pl.)', fr: 'tendres (gén./prép. pl.)' }, source: 'supplement' },
    'добрых': { stress: 0, gloss: { en: 'kind (gen./prep. pl.)', fr: 'bons (gén./prép. pl.)' }, source: 'supplement' },
    'злых': { stress: 0, gloss: { en: 'evil (gen./prep. pl.)', fr: 'méchants (gén./prép. pl.)' }, source: 'supplement' },
    'юных': { stress: 0, gloss: { en: 'young (gen./prep. pl.)', fr: 'jeunes (gén./prép. pl.)' }, source: 'supplement' },
    'старых': { stress: 0, gloss: { en: 'old (gen./prep. pl.)', fr: 'vieux (gén./prép. pl.)' }, source: 'supplement' },
    'новых': { stress: 0, gloss: { en: 'new (gen./prep. pl.)', fr: 'nouveaux (gén./prép. pl.)' }, source: 'supplement' },
    'милых': { stress: 0, gloss: { en: 'dear (gen./prep. pl.)', fr: 'chers (gén./prép. pl.)' }, source: 'supplement' },
    'дальних': { stress: 0, gloss: { en: 'distant (gen./prep. pl.)', fr: 'lointains (gén./prép. pl.)' }, source: 'supplement' },
    'близких': { stress: 0, gloss: { en: 'close (gen./prep. pl.)', fr: 'proches (gén./prép. pl.)' }, source: 'supplement' },
    'вечных': { stress: 0, gloss: { en: 'eternal (gen./prep. pl.)', fr: 'éternels (gén./prép. pl.)' }, source: 'supplement' },
    'грустных': { stress: 0, gloss: { en: 'sad (gen./prep. pl.)', fr: 'tristes (gén./prép. pl.)' }, source: 'supplement' },
    
    // Batch 15: Remaining adjective inflections
    'святых': { stress: 1, gloss: { en: 'holy (gen./prep. pl.)', fr: 'saints (gén./prép. pl.)' }, source: 'supplement' },
    'живых': { stress: 1, gloss: { en: 'living (gen./prep. pl.)', fr: 'vivants (gén./prép. pl.)' }, source: 'supplement' },
    'мёртвых': { stress: 0, gloss: { en: 'dead (gen./prep. pl.)', fr: 'morts (gén./prép. pl.)' }, source: 'supplement' },
    'родных': { stress: 1, gloss: { en: 'native (gen./prep. pl.)', fr: 'natals (gén./prép. pl.)' }, source: 'supplement' },
    'чужих': { stress: 1, gloss: { en: 'foreign (gen./prep. pl.)', fr: 'étrangers (gén./prép. pl.)' }, source: 'supplement' },
    'пустых': { stress: 1, gloss: { en: 'empty (gen./prep. pl.)', fr: 'vides (gén./prép. pl.)' }, source: 'supplement' },
    'густых': { stress: 1, gloss: { en: 'dense (gen./prep. pl.)', fr: 'denses (gén./prép. pl.)' }, source: 'supplement' },
    'безумных': { stress: 0, gloss: { en: 'mad (gen./prep. pl.)', fr: 'fous (gén./prép. pl.)' }, source: 'supplement' },
    'безмолвных': { stress: 1, gloss: { en: 'silent (gen./prep. pl.)', fr: 'silencieux (gén./prép. pl.)' }, source: 'supplement' },
    'бездонных': { stress: 1, gloss: { en: 'bottomless (gen./prep. pl.)', fr: 'sans fond (gén./prép. pl.)' }, source: 'supplement' },
    'бескрайних': { stress: 1, gloss: { en: 'boundless (gen./prep. pl.)', fr: 'sans bornes (gén./prép. pl.)' }, source: 'supplement' },
    'небесных': { stress: 1, gloss: { en: 'heavenly (gen./prep. pl.)', fr: 'célestes (gén./prép. pl.)' }, source: 'supplement' },
    'земных': { stress: 1, gloss: { en: 'earthly (gen./prep. pl.)', fr: 'terrestres (gén./prép. pl.)' }, source: 'supplement' },
    
    // Batch 16: Noun inflections — genitive plurals
    'дней': { stress: 0, gloss: { en: 'days (gen. pl.)', fr: 'de jours' }, source: 'supplement' },
    'ночей': { stress: 1, gloss: { en: 'nights (gen. pl.)', fr: 'de nuits' }, source: 'supplement' },
    'лет': { stress: 0, gloss: { en: 'years (gen. pl.)', fr: "d'années" }, source: 'supplement' },
    'слёз': { stress: 0, gloss: { en: 'tears (gen. pl.)', fr: 'de larmes' }, source: 'supplement' },
    'глаз': { stress: 0, gloss: { en: 'eyes (gen. pl.)', fr: "d'yeux" }, source: 'supplement' },
    'рук': { stress: 0, gloss: { en: 'hands (gen. pl.)', fr: 'de mains' }, source: 'supplement' },
    'ног': { stress: 0, gloss: { en: 'feet (gen. pl.)', fr: 'de pieds' }, source: 'supplement' },
    'губ': { stress: 0, gloss: { en: 'lips (gen. pl.)', fr: 'de lèvres' }, source: 'supplement' },
    'слов': { stress: 0, gloss: { en: 'words (gen. pl.)', fr: 'de mots' }, source: 'supplement' },
    'снов': { stress: 0, gloss: { en: 'dreams (gen. pl.)', fr: 'de rêves' }, source: 'supplement' },
    'цветов': { stress: 1, gloss: { en: 'flowers (gen. pl.)', fr: 'de fleurs' }, source: 'supplement' },
    'садов': { stress: 1, gloss: { en: 'gardens (gen. pl.)', fr: 'de jardins' }, source: 'supplement' },
    'лесов': { stress: 1, gloss: { en: 'forests (gen. pl.)', fr: 'de forêts' }, source: 'supplement' },
    'полей': { stress: 1, gloss: { en: 'fields (gen. pl.)', fr: 'de champs' }, source: 'supplement' },
    'морей': { stress: 1, gloss: { en: 'seas (gen. pl.)', fr: 'de mers' }, source: 'supplement' },
    'небес': { stress: 1, gloss: { en: 'heavens (gen. pl.)', fr: 'de cieux' }, source: 'supplement' },
    'сердец': { stress: 1, gloss: { en: 'hearts (gen. pl.)', fr: 'de cœurs' }, source: 'supplement' },
    'очей': { stress: 1, gloss: { en: 'eyes (gen. pl., archaic)', fr: "d'yeux (arch.)" }, source: 'supplement' },
    'людей': { stress: 1, gloss: { en: 'people (gen. pl.)', fr: 'de gens' }, source: 'supplement' },
    'детей': { stress: 1, gloss: { en: 'children (gen. pl.)', fr: "d'enfants" }, source: 'supplement' },
    
    // Common nouns for vocal literature (v5.11.41)
    'странствие': { stress: 0, gloss: { en: 'wandering', fr: 'errance' }, source: 'supplement' },
    'странствии': { stress: 0, gloss: { en: 'wandering (prep. sg.)', fr: 'errance (prép. sg.)' }, source: 'supplement' },
    'странствия': { stress: 0, gloss: { en: 'wandering (gen. sg.)', fr: "d'errance" }, source: 'supplement' }
};

/* ==================================================
   GLOSS FORMATTING HELPERS
   Handles verbose grammatical descriptions from kaikki.org
   ================================================== */

/**
 * Extract lemma from grammatical gloss text
 * e.g., "short feminine singular past indicative perfective of уга́снуть (ugásnutʹ)" → "угаснуть"
 */
function extractLemmaFromGloss(gloss) {
    if (!gloss) return null;
    
    // Pattern: "... of CYRILLIC_WORD (transliteration)" or just "... of CYRILLIC_WORD"
    const match = gloss.match(/of\s+([а-яёА-ЯЁ́]+)(?:\s*\(|$|\s|,)/i);
    if (match) {
        // Remove any combining accents from the extracted lemma
        return match[1].normalize('NFD').replace(/[\u0300-\u036f]/g, '').normalize('NFC').toLowerCase();
    }
    return null;
}

/**
 * Look up semantic gloss for a lemma
 */
function getLemmaGloss(lemma) {
    if (!lemma) return null;
    
    const lemmaEntry = STRESS_DICTIONARY[lemma];
    if (!lemmaEntry) return null;
    
    const entryGloss = Array.isArray(lemmaEntry) 
        ? (lemmaEntry[0].gloss || lemmaEntry[0].g || '')
        : (lemmaEntry.gloss || lemmaEntry.g || '');
    
    // Don't return if it's also a grammatical description
    if (entryGloss && !/^(short |inflection |nominative |genitive |dative |accusative |instrumental |prepositional )/i.test(entryGloss)) {
        return entryGloss;
    }
    return null;
}

/**
 * Curated short glosses for common words (Issue P)
 * These override verbose dictionary glosses to maintain column alignment.
 * Key = lemma (base form), so inflected forms inherit the gloss.
 */
// Bilingual curated glosses (v6.0.54)
// Fallback display glosses for common words whose dictionary entries
// contain verbose grammatical descriptions instead of clean translations.
// Format: {en, fr} — resolved by extractGloss() via currentGlossLanguage.
const CURATED_GLOSSES = new Map([
    // Personal pronouns
    ['я', { en: 'I', fr: 'je' }],
    ['ты', { en: 'you', fr: 'tu' }],
    ['он', { en: 'he', fr: 'il' }],
    ['она', { en: 'she', fr: 'elle' }],
    ['оно', { en: 'it', fr: 'cela' }],
    ['мы', { en: 'we', fr: 'nous' }],
    ['вы', { en: 'you (pl.)', fr: 'vous' }],
    ['они', { en: 'they', fr: 'ils/elles' }],
    // Pronoun oblique forms (when lemma lookup fails)
    ['меня', { en: 'me', fr: 'me' }],
    ['мне', { en: 'to me', fr: 'à moi' }],
    ['мной', { en: 'by me', fr: 'par moi' }],
    ['мною', { en: 'by me', fr: 'par moi' }],
    ['тебя', { en: 'you', fr: 'te' }],
    ['тебе', { en: 'you', fr: 'à toi' }],
    ['тобой', { en: 'by you', fr: 'par toi' }],
    ['тобою', { en: 'by you', fr: 'par toi' }],
    ['его', { en: 'him/his', fr: 'lui/son' }],
    ['него', { en: 'him', fr: 'lui' }],
    ['ему', { en: 'to him', fr: 'à lui' }],
    ['нему', { en: 'to him', fr: 'à lui' }],
    ['им', { en: 'by him', fr: 'par lui' }],
    ['ним', { en: 'him', fr: 'lui' }],
    ['её', { en: 'her', fr: 'elle/sa' }],
    ['неё', { en: 'her', fr: 'elle' }],
    ['ей', { en: 'to her', fr: 'à elle' }],
    ['ней', { en: 'her', fr: 'elle' }],
    ['ею', { en: 'by her', fr: 'par elle' }],
    ['нею', { en: 'by her', fr: 'par elle' }],
    ['нас', { en: 'us', fr: 'nous' }],
    ['нам', { en: 'to us', fr: 'à nous' }],
    ['нами', { en: 'by us', fr: 'par nous' }],
    ['вас', { en: 'you (pl.)', fr: 'vous' }],
    ['вам', { en: 'to you', fr: 'à vous' }],
    ['вами', { en: 'by you', fr: 'par vous' }],
    ['их', { en: 'them/their', fr: 'eux/leur' }],
    ['них', { en: 'them', fr: 'eux' }],
    ['ими', { en: 'by them', fr: 'par eux' }],
    ['ними', { en: 'them', fr: 'eux' }],
    // Possessives (all genders/cases)
    ['мой', { en: 'my', fr: 'mon' }],
    ['моя', { en: 'my', fr: 'ma' }],
    ['моё', { en: 'my', fr: 'mon' }],
    ['мои', { en: 'my', fr: 'mes' }],
    ['моего', { en: 'my', fr: 'mon' }],
    ['моей', { en: 'my', fr: 'ma' }],
    ['моему', { en: 'my', fr: 'mon' }],
    ['моим', { en: 'my', fr: 'mon' }],
    ['моими', { en: 'my', fr: 'mes' }],
    ['моих', { en: 'my', fr: 'mes' }],
    ['мою', { en: 'my', fr: 'ma' }],
    ['твой', { en: 'your', fr: 'ton' }],
    ['твоя', { en: 'your', fr: 'ta' }],
    ['твоё', { en: 'your', fr: 'ton' }],
    ['твои', { en: 'your', fr: 'tes' }],
    ['твоего', { en: 'your', fr: 'ton' }],
    ['твоей', { en: 'your', fr: 'ta' }],
    ['твоему', { en: 'your', fr: 'ton' }],
    ['твоим', { en: 'your', fr: 'ton' }],
    ['твоими', { en: 'your', fr: 'tes' }],
    ['твоих', { en: 'your', fr: 'tes' }],
    ['твою', { en: 'your', fr: 'ta' }],
    ['свой', { en: "one's own", fr: 'son propre' }],
    ['наш', { en: 'our', fr: 'notre' }],
    ['ваш', { en: 'your (pl.)', fr: 'votre' }],
    // Demonstratives
    ['этот', { en: 'this', fr: 'ce/cet' }],
    ['эта', { en: 'this', fr: 'cette' }],
    ['это', { en: 'this/it is', fr: 'ceci/c\'est' }],
    ['эти', { en: 'these', fr: 'ces' }],
    ['тот', { en: 'that', fr: 'celui-là' }],
    ['та', { en: 'that', fr: 'celle' }],
    ['то', { en: 'that', fr: 'cela' }],
    ['те', { en: 'those', fr: 'ceux/celles' }],
    // Interrogatives
    ['что', { en: 'what/that', fr: 'quoi/que' }],
    ['чего', { en: 'what', fr: 'de quoi' }],
    ['чему', { en: 'to what', fr: 'à quoi' }],
    ['чем', { en: 'what (instr.)', fr: 'par quoi' }],
    ['кто', { en: 'who', fr: 'qui' }],
    ['кого', { en: 'whom', fr: 'qui (acc.)' }],
    ['кому', { en: 'to whom', fr: 'à qui' }],
    ['кем', { en: 'by whom', fr: 'par qui' }],
    ['чей', { en: 'whose', fr: 'à qui' }],
    ['чья', { en: 'whose', fr: 'à qui' }],
    ['чьё', { en: 'whose', fr: 'à qui' }],
    ['чьи', { en: 'whose', fr: 'à qui' }],
    // Common adverbs
    ['где', { en: 'where', fr: 'où' }],
    ['как', { en: 'how', fr: 'comment' }],
    ['когда', { en: 'when', fr: 'quand' }],
    ['здесь', { en: 'here', fr: 'ici' }],
    ['там', { en: 'there', fr: 'là-bas' }],
    ['сюда', { en: 'hither', fr: 'par ici' }],
    ['туда', { en: 'thither', fr: 'par là' }],
    ['тут', { en: 'here', fr: 'ici' }],
    ['уже', { en: 'already', fr: 'déjà' }],
    ['уж', { en: 'already', fr: 'déjà' }],
    ['ещё', { en: 'still, yet', fr: 'encore' }],
    ['еще', { en: 'still, yet', fr: 'encore' }],
    // Quantifiers
    ['весь', { en: 'all', fr: 'tout' }],
    ['вся', { en: 'all', fr: 'toute' }],
    ['всё', { en: 'everything', fr: 'tout' }],
    ['все', { en: 'everyone', fr: 'tous' }],
    ['всех', { en: 'all', fr: 'tous' }],
    ['всем', { en: 'all', fr: 'tous' }],
    ['сам', { en: 'oneself', fr: 'soi-même' }],
    ['сама', { en: 'herself', fr: 'elle-même' }],
    ['само', { en: 'itself', fr: 'lui-même' }],
    ['сами', { en: 'themselves', fr: 'eux-mêmes' }],
    ['один', { en: 'one, alone', fr: 'un, seul' }],
    ['одна', { en: 'one, alone', fr: 'une, seule' }],
    ['одно', { en: 'one, alone', fr: 'un, seul' }],
    // Common verbs
    ['быть', { en: 'to be', fr: 'être' }],
    ['есть', { en: 'is/to eat', fr: 'est/manger' }],
    ['нет', { en: 'no/there is no', fr: 'non/il n\'y a pas' }],
    ['сойти', { en: 'to descend', fr: 'descendre' }],
    ['сойдём', { en: 'we will descend', fr: 'nous descendrons' }],
    ['сойду', { en: 'I will descend', fr: 'je descendrai' }],
    // Preposition-like
    ['между', { en: 'between', fr: 'entre' }],
    ['меж', { en: 'between', fr: 'entre' }],
    ['ради', { en: 'for the sake of', fr: "pour l'amour de" }],
    // Numbers
    ['два', { en: 'two', fr: 'deux' }],
    ['три', { en: 'three', fr: 'trois' }],
    // Common short words in vocal lit
    ['день', { en: 'day', fr: 'jour' }],
    ['ночь', { en: 'night', fr: 'nuit' }],
    ['путь', { en: 'path, way', fr: 'chemin, voie' }],
    ['жизнь', { en: 'life', fr: 'vie' }],
    ['смерть', { en: 'death', fr: 'mort' }],
    ['любовь', { en: 'love', fr: 'amour' }],
    ['душа', { en: 'soul', fr: 'âme' }],
    ['сердце', { en: 'heart', fr: 'cœur' }],
    ['час', { en: 'hour', fr: 'heure' }],
    ['год', { en: 'year', fr: 'an' }],
    ['век', { en: 'century, age', fr: 'siècle' }],
    // Additional common vocab (v5.11.18)
    ['странствие', { en: 'wandering', fr: 'errance' }],
    ['странствии', { en: 'wandering', fr: 'errance' }],
    ['странствия', { en: 'wandering', fr: 'errance' }],
    ['мгновение', { en: 'moment', fr: 'instant' }],
    ['мгновенье', { en: 'moment', fr: 'instant' }],
    ['воспоминание', { en: 'memory', fr: 'souvenir' }],
    ['воспоминанье', { en: 'memory', fr: 'souvenir' }],
    ['судьбина', { en: 'fate, destiny', fr: 'destin' }],
    ['провожать', { en: 'to see off', fr: 'accompagner' }],
    ['провождать', { en: 'to see off', fr: 'accompagner' }],
    ['угадать', { en: 'to guess', fr: 'deviner' }],
    ['годовщина', { en: 'anniversary', fr: 'anniversaire' }],
    ['годовщину', { en: 'anniversary', fr: 'anniversaire' }],
    ['бой', { en: 'battle, fight', fr: 'combat' }],
    ['бою', { en: 'battle', fr: 'combat' }],
    ['волна', { en: 'wave', fr: 'vague' }],
    ['волнах', { en: 'waves', fr: 'vagues' }],
    // v5.11.21: Additional Станцы vocab
    ['уединённый', { en: 'solitary', fr: 'solitaire' }],
    ['уединенный', { en: 'solitary', fr: 'solitaire' }],
    ['патриарх', { en: 'patriarch', fr: 'patriarche' }],
    ['забвенный', { en: 'forgotten', fr: 'oublié' }],
    ['младенец', { en: 'infant', fr: 'nourrisson' }],
    ['младенца', { en: 'infant', fr: 'nourrisson' }],
    ['уступаю', { en: 'I yield', fr: 'je cède' }],
    ['уступать', { en: 'to yield', fr: 'céder' }],
    ['тлеть', { en: 'to decay', fr: 'se décomposer' }],
    ['цвести', { en: 'to bloom', fr: 'fleurir' }],
    ['годину', { en: 'hour, time', fr: 'heure, temps' }],
    ['грядущей', { en: 'coming, future', fr: 'à venir' }],
    ['грядущий', { en: 'coming, future', fr: 'à venir' }],
    ['соседняя', { en: 'neighboring', fr: 'voisin(e)' }],
    ['долина', { en: 'valley', fr: 'vallée' }],
    ['охладелый', { en: 'cold, dead', fr: 'refroidi' }],
    ['прах', { en: 'dust, ashes', fr: 'cendres' }],
    ['бесчувственному', { en: 'insensible', fr: 'insensible' }],
    ['бесчувственный', { en: 'insensible', fr: 'insensible' }],
    ['истлевать', { en: 'to decay', fr: 'se décomposer' }],
    ['предел', { en: 'limit, end', fr: 'limite' }],
    ['пределу', { en: 'limit, end', fr: 'limite' }],
    ['почивать', { en: 'to rest, sleep', fr: 'reposer' }],
    ['гробовой', { en: 'grave, deathly', fr: 'sépulcral' }],
    ['гробового', { en: 'grave', fr: 'sépulcral' }],
    ['младая', { en: 'young', fr: 'jeune' }],
    ['равнодушная', { en: 'indifferent', fr: 'indifférent(e)' }],
    ['равнодушный', { en: 'indifferent', fr: 'indifférent' }],
    ['природа', { en: 'nature', fr: 'nature' }],
    ['краса', { en: 'beauty', fr: 'beauté' }],
    ['красою', { en: 'beauty', fr: 'beauté' }],
    ['вечною', { en: 'eternal', fr: 'éternel(le)' }],
    ['сиять', { en: 'to shine', fr: 'briller' }],
    // Test words
    ['резчик', { en: 'carver, cutter', fr: 'graveur' }],
]);

/**
 * Format gloss for word-stack display (minimal, translation only)
 */
function formatGlossForDisplay(gloss, pos, lemma, word) {
    // Bilingual gloss data takes priority (v6.0.48)
    if (gloss && typeof gloss === 'object' && (gloss.en || gloss.fr)) {
        return extractGloss(gloss);
    }
    
    // Check curated glosses first (word form, then lemma)
    if (word && CURATED_GLOSSES.has(word.toLowerCase())) {
        return extractGloss(CURATED_GLOSSES.get(word.toLowerCase()));
    }
    if (lemma && CURATED_GLOSSES.has(lemma.toLowerCase())) {
        return extractGloss(CURATED_GLOSSES.get(lemma.toLowerCase()));
    }
    
    // Blank for missing glosses: leave space for pencil users (v5.11.20)
    if (!gloss) return '';
    
    // First, try to extract a clean translation from verbose patterns
    const cleanedGloss = extractCleanGloss(gloss);
    
    // Detect verbose grammatical patterns from kaikki.org
    const isGrammatical = /^(short |inflection of|nominative |genitive |dative |accusative |instrumental |prepositional |comparative |superlative )/i.test(cleanedGloss) 
                       || /\b(singular|plural)\s+(of|past|present|future)\b/i.test(cleanedGloss);
    
    if (isGrammatical) {
        // Try lemma field first, then extract from gloss text
        const effectiveLemma = lemma || extractLemmaFromGloss(gloss);
        
        if (effectiveLemma) {
            // Look up lemma's semantic gloss
            const semanticGloss = getLemmaGloss(effectiveLemma);
            if (semanticGloss) {
                return truncateGloss(extractCleanGloss(semanticGloss), 5);
            }
            // Fallback: leave blank for pencil users (no arrow - v5.11.22)
            return '';
        }
        // No lemma found: leave blank
        return '';
    }
    
    // Clean, semantic gloss — truncate to 5 words max for PDF display
    return truncateGloss(cleanedGloss, 5);
}

/**
 * Extract clean translation from verbose dictionary glosses
 * Handles patterns like "Usually translated as 'this'" → "this"
 */
function extractCleanGloss(gloss) {
    if (!gloss) return '';
    
    // Pattern: "translated as X" or "Translated as X" — extract X
    let match = gloss.match(/translated as ["']?([^"'.,;\/]+)/i);
    if (match) return match[1].replace(/["']/g, '').trim();
    
    // Pattern: "diminutive of X: Y" or "augmentative of X: Y" → extract Y
    match = gloss.match(/^(?:diminutive|augmentative|pejorative|endearing form) of [^:]+:\s*(.+)$/i);
    if (match) return match[1].trim();
    
    // Pattern: simple gloss followed by verbose parenthetical explanation
    // e.g., "I (first-person singular subject pronoun)" → "I"
    // e.g., "house, building (a residential building)" → "house, building"
    // But keep useful clarifications like "birch (tree or wood)"
    match = gloss.match(/^([^(]+)\s*\((?:a |the |first|second|third|singular|plural|subject|object|nominative|genitive|dative|accusative|masculine|feminine|neuter)[^)]*\)$/i);
    if (match) return match[1].trim();
    
    // Pattern: starts with linguistic jargon followed by simple gloss in parens
    // e.g., "proximal demonstrative (this)" but NOT "birch (tree or wood)"
    if (/^(mostly |generic |proximal |distal |demonstrative )/i.test(gloss)) {
        match = gloss.match(/\(([a-z][^)]{0,20})\)\s*$/i);
        if (match && !/\d/.test(match[1])) return match[1].trim();
    }
    
    // No extraction pattern matched — return original
    return gloss;
}

/**
 * Truncate gloss to N words max AND M characters max, adding ellipsis if needed
 * v5.11.8: Reduced maxChars to 18 for tighter word stack layout
 */
function truncateGloss(gloss, maxWords, maxChars = 18) {
    if (!gloss) return '';
    
    // First, strip ALL parenthetical content for word stack display
    let cleaned = gloss.replace(/\s*\([^)]*\)/g, ''); // Remove all parentheticals
    cleaned = cleaned.replace(/\s*\([^)]*$/, ''); // Remove unclosed parentheticals
    cleaned = cleaned.trim();
    
    // Word limit (no ellipsis)
    const words = cleaned.split(/\s+/);
    if (words.length > maxWords) {
        cleaned = words.slice(0, maxWords).join(' ');
    }
    
    // Character limit - truncate at word boundary, no ellipsis
    if (cleaned.length > maxChars) {
        const truncatedWords = [];
        let charCount = 0;
        for (const word of cleaned.split(/\s+/)) {
            if (charCount + word.length + (truncatedWords.length > 0 ? 1 : 0) <= maxChars) {
                truncatedWords.push(word);
                charCount += word.length + (truncatedWords.length > 1 ? 1 : 0);
            } else {
                break;
            }
        }
        cleaned = truncatedWords.join(' ') || cleaned.slice(0, maxChars);
    }
    
    // Remove dangling particles after comma/semicolon (v5.11.19)
    // "to wander, to" → "to wander" (the trailing "to" is semantically incomplete)
    cleaned = cleaned.replace(/[,;]\s+(to|a|the|of|in|on|for|and|or)$/i, '');
    
    // Remove trailing punctuation for cleaner appearance
    cleaned = cleaned.replace(/[,;:]+$/, '');
    
    return cleaned;
}

/**
 * Format gloss for popup display (POS + gloss + grammar hints)
 */
function formatGlossForPopup(gloss, pos, lemma) {
    if (!gloss) return pos ? `${pos}` : '';
    
    // Detect verbose grammatical patterns
    const isGrammatical = /^(short |inflection of|nominative |genitive |dative |accusative |instrumental |prepositional |comparative |superlative )/i.test(gloss) 
                       || /\b(singular|plural)\s+(of|past|present|future)\b/i.test(gloss);
    
    if (isGrammatical) {
        // Extract grammar hints
        let grammarHint = '';
        if (/past/i.test(gloss)) grammarHint += 'past ';
        if (/present/i.test(gloss)) grammarHint += 'pres. ';
        if (/future/i.test(gloss)) grammarHint += 'fut. ';
        if (/feminine/i.test(gloss)) grammarHint += 'f.';
        else if (/masculine/i.test(gloss)) grammarHint += 'm.';
        else if (/neuter/i.test(gloss)) grammarHint += 'n.';
        if (/plural/i.test(gloss)) grammarHint += 'pl.';
        grammarHint = grammarHint.trim();
        
        // Try lemma field first, then extract from gloss text
        const effectiveLemma = lemma || extractLemmaFromGloss(gloss);
        
        // Get semantic gloss
        let semanticGloss = '';
        if (effectiveLemma) {
            const rawGloss = getLemmaGloss(effectiveLemma);
            semanticGloss = rawGloss ? extractCleanGloss(rawGloss) : `→ ${effectiveLemma}`;
        }
        
        const displayGloss = semanticGloss || '';
        const grammarPart = grammarHint ? `(${grammarHint})` : '';
        
        // Avoid duplicating POS if gloss already starts with it
        if (pos && displayGloss.toLowerCase().startsWith(pos.toLowerCase())) {
          return `${displayGloss} ${grammarPart}`.trim();
        }
        
        return pos 
            ? `${pos} ${displayGloss} ${grammarPart}`.trim()
            : `${displayGloss} ${grammarPart}`.trim();
    }
    
    // Clean semantic gloss — extract clean translation, add POS
    const cleanedGloss = extractCleanGloss(gloss);
    
    // Avoid duplicating POS if gloss already starts with it (v5.10.23)
    if (pos && cleanedGloss.toLowerCase().startsWith(pos.toLowerCase())) {
      return cleanedGloss;
    }
    
    return pos ? `${pos} ${cleanedGloss}` : cleanedGloss;
}

/**
 * Add combining acute accent (U+0301) to the stressed vowel in Cyrillic text.
 * Exception: ё/Ё already indicates stress via dieresis, so no acute added.
 * 
 * @param {string} word - The Cyrillic word
 * @param {Array} syllables - Array of syllable objects with isStressed property
 * @returns {string} - Word with acute on stressed vowel (or unchanged if ё is stressed)
 */
function addStressMarkToCyrillic(word, syllables) {
    if (!syllables || syllables.length === 0) return word;
    
    // Find the stressed syllable
    const stressedSyl = syllables.find(s => s.isStressed);
    if (!stressedSyl) return word;
    
    // Find position of stressed syllable's Cyrillic in the word
    const vowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                           'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
    
    // Count vowels to find stressed syllable position
    let vowelCount = 0;
    let stressedSylIndex = 0;
    for (let i = 0; i < syllables.length; i++) {
        if (syllables[i].isStressed) {
            stressedSylIndex = i;
            break;
        }
    }
    
    // Now find the (stressedSylIndex + 1)th vowel in the word
    let currentVowelNum = 0;
    const chars = Array.from(word);
    let result = '';
    
    for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        result += char;
        
        if (vowels.has(char)) {
            if (currentVowelNum === stressedSylIndex) {
                // This is the stressed vowel — add acute unless it's ё/Ё
                if (char !== 'ё' && char !== 'Ё') {
                    result += '\u0301'; // Combining acute accent
                }
            }
            currentVowelNum++;
        }
    }
    
    return result;
}

/**
 * Add combining acute accent to the vowel in a syllable string (for popup display).
 * Exception: ё/Ё already indicates stress via dieresis, so no acute added.
 * 
 * @param {string} syllable - A single Cyrillic syllable
 * @returns {string} - Syllable with acute on its vowel (or unchanged if ё)
 */
function addAcuteToSyllable(syllable) {
    const vowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                           'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
    
    const chars = Array.from(syllable);
    let result = '';
    let acuteAdded = false;
    
    for (const char of chars) {
        result += char;
        if (!acuteAdded && vowels.has(char) && char !== 'ё' && char !== 'Ё') {
            result += '\u0301'; // Combining acute accent
            acuteAdded = true;
        }
    }
    
    return result;
}

    /* ========================================
       TRANSCRIPTION PROFILES
       ======================================== */
    const TRANSCRIPTION_PROFILES = {
      'old-muscovite': {
        name: 'Old Muscovite',
        i18nName: 'profile.oldMuscovite',
        i18nDesc: 'profile.descOldMuscovite',
        default: true,
        params: {
          reduction: 'ikanye',
          shcha: 'shshokanye',    // [ʃʲː]
          adjectival: 'stage',     // [ɨj]
          intensity: 'full'
        },
        description: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj]'
      },
      'peterburgian': {
        name: 'Peterburgian',
        i18nName: 'profile.peterburgian',
        i18nDesc: 'profile.descPeterburgian',
        params: {
          reduction: 'ekanye',
          shcha: 'shchokanye',    // [ʃtʃ]
          adjectival: 'modern',    // [ij]
          intensity: 'full'
        },
        description: 'Ekanye vowel reduction, [ʃtʃ] for щ, modern adjectivals [ij]'
      },
      'choral': {
        name: 'Choral',
        i18nName: 'profile.choral',
        i18nDesc: 'profile.descChoral',
        params: {
          reduction: 'ikanye',
          shcha: 'shshokanye',    // [ʃʲː]
          adjectival: 'stage',     // [ɨj]
          intensity: 'reduced'
        },
        description: 'Ikanye vowel reduction, [ʃʲː] for щ, stage adjectivals [ɨj], reduced intensity for vowel matching'
      }
    };
    
    /* ========================================
       TAB CONTROLLER (Mobile)
       ======================================== */
    const TabController = {
      tabs: null,
      inputZone: null,
      dashboardZone: null,
      activeTab: 'text',
      
      init() {
        this.tabs = document.querySelectorAll('.drawer-tab');
        this.inputZone = document.getElementById('inputZone');
        this.dashboardZone = document.getElementById('dashboardZone');
        
        if (!this.tabs.length) return;
        
        this.tabs.forEach(tab => {
          tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
        
        // Check viewport and show appropriate zone
        this.handleResize();
        window.addEventListener('resize', () => this.handleResize());
      },
      
      switchTab(tabName) {
        this.activeTab = tabName;
        
        // Update tab buttons
        this.tabs.forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        
        // Update zones visibility (mobile only)
        if (window.innerWidth < 768) {
          this.inputZone.classList.toggle('hidden', tabName !== 'text');
          this.dashboardZone.classList.toggle('hidden', tabName !== 'details');
        }
      },
      
      handleResize() {
        // Desktop: show both zones
        if (window.innerWidth >= 768) {
          this.inputZone.classList.remove('hidden');
          this.dashboardZone.classList.remove('hidden');
        } else {
          // Mobile: show only active tab
          this.switchTab(this.activeTab);
        }
      }
    };
    
    /* ========================================
       SEARCHABLE SELECT CONTROLLER
       ======================================== */
    const SearchableSelect = {
      instances: {},
      
      create(config) {
        const { id, trigger, dropdown, search, options, data, onSelect } = config;
        
        const instance = {
          isOpen: false,
          selectedValue: null,
          selectedDisplay: null,
          filteredData: [...data],
          highlightIndex: -1,
          
          open() {
            this.isOpen = true;
            trigger.classList.add('active');
            dropdown.classList.add('open');
            search.value = '';
            this.filteredData = [...data]; // Reset filtered data
            this.highlightIndex = -1;
            search.focus();
            this.render(this.filteredData);
          },
          
          close() {
            this.isOpen = false;
            trigger.classList.remove('active');
            dropdown.classList.remove('open');
            this.highlightIndex = -1;
          },
          
          toggle() {
            if (this.isOpen) this.close();
            else this.open();
          },
          
          select(item) {
            this.selectedValue = item;
            this.selectedDisplay = `${item.latin} (${item.dates})`;
            
            // Update trigger display
            trigger.innerHTML = `
              <span>${this.selectedDisplay}</span>
              <svg class="chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            `;
            
            this.close();
            if (onSelect) onSelect(item);
          },
          
          filter(query) {
            const q = query.toLowerCase();
            this.filteredData = data.filter(item => 
              item.latin.toLowerCase().includes(q) ||
              item.cyrillic.toLowerCase().includes(q)
            );
            this.highlightIndex = -1;
            this.render(this.filteredData);
          },
          
          render(items) {
            let html = items.map((item, idx) => `
              <div class="select-option ${idx === this.highlightIndex ? 'highlighted' : ''}" data-index="${idx}">
                <span class="primary">${item.latin}</span>
                <span class="secondary">${item.cyrillic} • ${item.dates}</span>
              </div>
            `).join('');
            
            // Add "Not in list" option
            html += `<div class="select-option custom" data-custom="true">+ Not in list (enter custom)</div>`;
            
            options.innerHTML = html;
            
            // Bind click handlers
            options.querySelectorAll('.select-option').forEach(opt => {
              opt.addEventListener('click', () => {
                if (opt.dataset.custom) {
                  // Custom entry - for now just close
                  this.close();
                  // Future: show custom input
                } else {
                  const idx = parseInt(opt.dataset.index);
                  this.select(this.filteredData[idx]);
                }
              });
            });
          }
        };
        
        // Event listeners
        trigger.addEventListener('click', () => instance.toggle());
        search.addEventListener('input', (e) => instance.filter(e.target.value));
        
        // Make trigger focusable and respond to typing
        trigger.setAttribute('tabindex', '0');
        trigger.addEventListener('keydown', (e) => {
          // If typing a printable character, open and start filtering
          if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            if (!instance.isOpen) {
              instance.open();
            }
            search.value = e.key;
            instance.filter(e.key);
          } else if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            instance.toggle();
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (!instance.isOpen) instance.open();
          } else if (e.key === 'Escape') {
            instance.close();
          }
        });
        
        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!trigger.contains(e.target) && !dropdown.contains(e.target)) {
            instance.close();
          }
        });
        
        // Keyboard navigation
        search.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            instance.highlightIndex = Math.min(instance.highlightIndex + 1, instance.filteredData.length - 1);
            instance.render(instance.filteredData);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            instance.highlightIndex = Math.max(instance.highlightIndex - 1, 0);
            instance.render(instance.filteredData);
          } else if (e.key === 'Enter' && instance.highlightIndex >= 0) {
            e.preventDefault();
            instance.select(instance.filteredData[instance.highlightIndex]);
          } else if (e.key === 'Escape') {
            instance.close();
          }
        });
        
        this.instances[id] = instance;
        return instance;
      }
    };
    
    /* ========================================
       PROFILE CONTROLLER
       ======================================== */
    const ProfileController = {
      section: null,
      header: null,
      select: null,
      description: null,
      activeLabel: null,
      currentProfile: 'old-muscovite',
      
      init() {
        this.section = document.getElementById('profileSection');
        this.header = document.getElementById('profileHeader');
        this.select = document.getElementById('profileSelect');
        this.description = document.getElementById('profileDescription');
        this.activeLabel = document.getElementById('profileActive');
        
        if (!this.section) return;
        
        // Toggle expand/collapse
        this.header.addEventListener('click', () => {
          this.section.classList.toggle('expanded');
        });
        
        // Profile selection
        this.select.addEventListener('change', (e) => {
          this.setProfile(e.target.value);
        });
      },
      
      setProfile(profileKey) {
        const profile = TRANSCRIPTION_PROFILES[profileKey];
        if (!profile) return;
        
        this.currentProfile = profileKey;
        const lang = currentGlossLanguage || 'en';
        const name = UI_LABELS[profile.i18nName]?.[lang] || profile.name;
        const desc = UI_LABELS[profile.i18nDesc]?.[lang] || profile.description;
        this.activeLabel.textContent = name;
        this.description.innerHTML = `
          <span class="info-icon-circle">i</span>
          <span>${desc}</span>
        `;
        
        // Update select option labels
        if (this.select) {
          Array.from(this.select.options).forEach(opt => {
            const p = TRANSCRIPTION_PROFILES[opt.value];
            if (p) opt.textContent = UI_LABELS[p.i18nName]?.[lang] || p.name;
          });
        }
        
        // TODO: Trigger re-transcription if content exists
        console.log('Profile changed to:', profile.name, profile.params);
      },
      
      getParams() {
        return TRANSCRIPTION_PROFILES[this.currentProfile]?.params || TRANSCRIPTION_PROFILES['old-muscovite'].params;
      }
    };
    
    /* ========================================
       DOCUMENT CONTROLLER (v5.9.0)
       Paper size selection + pagination
       ======================================== */
    const DocumentController = {
      section: null,
      header: null,
      activeLabel: null,
      paperSizeBtns: null,
      pageNumberEl: null,
      paper: null,
      currentSize: 'letter',
      
      // Paper dimensions in pixels (96dpi)
      PAPER_HEIGHTS: {
        letter: 1056,  // 11in × 96dpi
        a4: 1123       // 297mm × 96dpi / 25.4
      },
      
      init() {
        this.section = document.getElementById('documentSection');
        this.header = document.getElementById('documentHeader');
        this.activeLabel = document.getElementById('documentActive');
        this.paperSizeBtns = document.querySelectorAll('.paper-size-btn');
        this.pageNumberEl = document.getElementById('pageNumber');
        this.paper = document.querySelector('.paper');
        
        if (!this.section) return;
        
        // Toggle expand/collapse
        this.header.addEventListener('click', () => {
          this.section.classList.toggle('expanded');
        });
        
        // Paper size selection
        this.paperSizeBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            this.setSize(btn.dataset.size);
          });
        });
        
        // Recalculate on window resize
        window.addEventListener('resize', () => {
          this.updatePageCount();
        });
      },
      
      setSize(size) {
        if (size === this.currentSize) return;
        
        this.currentSize = size;
        
        // Update button states
        this.paperSizeBtns.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.size === size);
        });
        
        // Update label with dimensions
        this.activeLabel.textContent = size === 'letter' ? 'Letter (8.5×11)' : 'A4 (210×297)';
        
        // Add reflowing class for content fade
        this.paper?.classList.add('reflowing');
        
        // Update paper data attribute (triggers CSS transition)
        if (size === 'a4') {
          this.paper?.setAttribute('data-size', 'a4');
        } else {
          this.paper?.removeAttribute('data-size');
        }
        
        // Remove reflowing class and update page count after transition
        setTimeout(() => {
          this.paper?.classList.remove('reflowing');
          this.updatePageCount();
        }, 400); // 300ms transition + 100ms buffer
      },
      
      getSize() {
        return this.currentSize;
      },
      
      // Calculate page count based on content vs paper height
      calculatePageCount() {
        if (!this.paper) return 1;
        
        const contentHeight = this.paper.scrollHeight;
        const visibleHeight = this.paper.clientHeight;
        
        // If no overflow, it's 1 page
        if (contentHeight <= visibleHeight) return 1;
        
        // Calculate based on full paper height (not viewport-constrained)
        const fullPaperHeight = this.PAPER_HEIGHTS[this.currentSize];
        const pageCount = Math.ceil(contentHeight / fullPaperHeight);
        
        return Math.max(1, pageCount);
      },
      
      // Update the page count label using Paginator
      updatePageCount() {
        if (!this.pageNumberEl) {
          console.warn('[DocumentController] pageNumberEl not found');
          return;
        }
        
        // Count pages based on DocumentState lines
        let totalPages = 1;
        
        if (DocumentState?.lines?.length > 0) {
          const lineCount = DocumentState.lines.length;
          const pages = Paginator.distributeToPages(
            Array(lineCount).fill({}),  // Mock lines for counting
            null,                        // No heights for simple count
            this.currentSize
          );
          totalPages = pages.length;
        }
        
        // Format: "X pages" for dashboard indicator
        const lang = currentGlossLanguage || 'en';
        if (totalPages === 1) {
          this.pageNumberEl.textContent = UI_LABELS['page.countOne'][lang];
        } else {
          this.pageNumberEl.textContent = UI_LABELS['page.countMany'][lang].replace('{n}', totalPages);
        }
      }
    };
    
    /* ========================================
       PAGINATOR (v5.9.4)
       Multi-page distribution engine
       ======================================== */
    const Paginator = {
      // Measured values (populated after first render)
      lineHeight: null,
      safeLineHeight: null,
      
      // Line height cache for pre-flight measurement (v5.11.17)
      lineHeightCache: null,
      lineHeightCacheHash: null,
      
      // Paper dimensions in pixels (96dpi)
      PAPER_HEIGHTS: {
        letter: 1056,  // 11in × 96dpi
        a4: 1123       // 297mm × 96dpi / 25.4
      },
      
      // Layout constants (in pixels)
      MARGINS: {
        top: 48,       // Reduced from 72 - header provides visual padding
        bottom: 24,    // Reduced from 72 - footer provides visual padding
        left: 72,
        right: 72
      },
      
      // Header heights
      TITLE_HEADER_HEIGHT: 150,    // Page 1: full title block
      RUNNING_HEADER_HEIGHT: 48,   // Pages 2+: "COMPOSER — TITLE"
      FOOTER_HEIGHT: 120,           // Footer with attribution + pagination (measured)
      
      /**
       * Measure actual line height from rendered content
       * Should be called after renderToPaper() completes
       */
      measureLineHeight() {
        const lines = document.querySelectorAll('.verse-line');
        
        if (lines.length === 0) {
          console.log('[Paginator] No lines to measure');
          return null;
        }
        
        // Find maximum height among all lines
        const heights = Array.from(lines).map(el => {
          const rect = el.getBoundingClientRect();
          return rect.height;
        });
        
        const maxHeight = Math.max(...heights);
        const minHeight = Math.min(...heights);
        const avgHeight = heights.reduce((a, b) => a + b, 0) / heights.length;
        
        // Store with 5% safety margin (reduced from 10%)
        this.lineHeight = maxHeight;
        this.safeLineHeight = Math.ceil(maxHeight * 1.05);
        
        console.log('[Paginator] Line height measured:', {
          min: minHeight.toFixed(1),
          max: maxHeight.toFixed(1),
          avg: avgHeight.toFixed(1),
          safe: this.safeLineHeight,
          sampleSize: lines.length
        });
        
        return this.safeLineHeight;
      },
      
      /**
       * Pre-flight measurement: measure all line heights BEFORE pagination (v5.11.17)
       * Uses off-screen container with actual CSS to get true visual heights
       * @param {Array} allLines - Transcribed line data
       * @param {Function} createLineElement - Function to create .verse-line element
       * @returns {Array} Heights in pixels for each line
       */
      measureAllLineHeights(allLines, createLineElement) {
        // Check cache first
        const contentHash = this.hashLineContent(allLines);
        if (this.lineHeightCache && this.lineHeightCacheHash === contentHash) {
          console.log('[Paginator] Using cached line heights');
          return this.lineHeightCache;
        }
        
        // Get content width from existing page, or use fallback
        const contentWidth = this.getContentWidth();
        
        // Create hidden container that inherits page-content CSS
        // Must match real container exactly: box-sizing, overflow, width
        const hiddenContainer = document.createElement('div');
        hiddenContainer.className = 'page-content';
        hiddenContainer.style.cssText = `
          position: absolute;
          visibility: hidden;
          pointer-events: none;
          width: ${contentWidth}px;
          box-sizing: border-box;
          overflow: hidden;
          top: -9999px;
          left: -9999px;
        `;
        document.body.appendChild(hiddenContainer);
        
        // Diagnostic logging (v5.11.18)
        const realPage = document.querySelector('.paper-page .page-content');
        if (realPage) {
          const realWidth = realPage.getBoundingClientRect().width;
          const hiddenWidth = hiddenContainer.getBoundingClientRect().width;
          console.log(`[Paginator] Width check - Hidden: ${hiddenWidth.toFixed(1)}px, Real: ${realWidth.toFixed(1)}px, Diff: ${(hiddenWidth - realWidth).toFixed(1)}px`);
        }
        
        // Measure each line
        const heights = allLines.map(line => {
          const el = createLineElement(line);
          hiddenContainer.appendChild(el);
          const height = el.getBoundingClientRect().height;
          hiddenContainer.removeChild(el);
          return height;
        });
        
        // Clean up
        hiddenContainer.remove();
        
        // Cache results
        this.lineHeightCache = heights;
        this.lineHeightCacheHash = contentHash;
        
        // Calculate standard row height using 10th percentile for robustness (v5.11.18)
        // Math.min() is fragile if some lines are unusually short
        const nonZeroHeights = heights.filter(h => h > 0);
        if (nonZeroHeights.length > 0) {
          const sorted = [...nonZeroHeights].sort((a, b) => a - b);
          const idx = Math.floor(sorted.length * 0.1); // 10th percentile
          this.standardRowHeight = sorted[idx] || sorted[0];
        } else {
          this.standardRowHeight = 105; // Fallback
        }
        
        console.log('[Paginator] Pre-flight measurement:', {
          lines: heights.length,
          standardRowHeight: this.standardRowHeight.toFixed(1),
          minHeight: Math.min(...heights).toFixed(1),
          maxHeight: Math.max(...heights).toFixed(1),
          wrappingLines: heights.filter(h => h > this.standardRowHeight * 1.5).length
        });
        
        return heights;
      },
      
      /**
       * Get content width from rendered page or calculate from constants
       */
      getContentWidth() {
        const referencePage = document.querySelector('.paper-page');
        if (referencePage) {
          const referenceContent = referencePage.querySelector('.page-content');
          if (referenceContent) {
            const computedStyle = window.getComputedStyle(referenceContent);
            return referenceContent.clientWidth 
              - parseFloat(computedStyle.paddingLeft || 0) 
              - parseFloat(computedStyle.paddingRight || 0);
          }
        }
        // Fallback: letter width (8.5in) minus margins (72px each side)
        return 816 - 144; // 672px
      },
      
      /**
       * Hash line content for cache invalidation
       * Uses cleanWord and stress index from transcribed word data
       */
      hashLineContent(allLines) {
        return allLines.map(line => 
          line.map(tw => 
            (tw.cleanWord || '') + ':' + (tw.wordData?.stress ?? '')
          ).join('|')
        ).join('||');
      },
      
      /**
       * Invalidate line height cache (call when content changes)
       */
      invalidateCache() {
        this.lineHeightCache = null;
        this.lineHeightCacheHash = null;
        console.log('[Paginator] Cache invalidated');
      },
      
      /**
       * Calculate how many lines fit on each page type
       * Fixed counts based on testing: 5 for title page, 7 for subsequent
       * (v5.11.7 - reduced from 6/8 to prevent clipping)
       */
      calculateLinesPerPage(paperSize = 'letter') {
        // Fixed line counts based on visual testing
        // Page 1 has less room due to title block
        // Subsequent pages have more room with just running header
        // (v5.11.19 - restored to 6/8, horizontal gap reduction prevents wrapping)
        const linesPage1 = 6;
        const linesSubsequent = 8;
        
        console.log('[Paginator] Lines per page:', {
          paperSize,
          linesPage1,
          linesSubsequent
        });
        
        return {
          page1: linesPage1,
          subsequent: linesSubsequent
        };
      },
      
      /**
       * Format running header: "COMPOSER — TITLE"
       * Smart truncation per Kimi's spec
       */
      formatRunningHeader(surname, title) {
        if (!surname && !title) return '';
        
        // Truncate title if needed (30 chars max)
        let shortTitle = title || '';
        if (shortTitle.length > 30) {
          shortTitle = shortTitle.slice(0, 27) + '...';
        }
        
        // Format as "SURNAME — TITLE"
        if (surname && shortTitle) {
          return `${surname.toUpperCase()} — ${shortTitle.toUpperCase()}`;
        }
        return (surname || shortTitle).toUpperCase();
      },
      
      /**
       * Distribute lines across pages (v5.11.19)
       * @param {Array} allLines - All transcribed lines
       * @param {Object} targets - { page1: N, subsequent: M } line counts
       * @param {string} paperSize - 'letter' or 'a4'
       * @returns {Array} Array of page objects
       */
      distributeToPages(allLines, targets = null, paperSize = 'letter') {
        // Use provided targets or defaults
        const { page1, subsequent } = targets || { page1: 6, subsequent: 8 };
        
        const pages = [];
        let cursor = 0;
        
        // Page 1: title template, fewer lines
        if (allLines.length > 0) {
          pages.push({
            pageNumber: 1,
            template: 'title',
            lines: allLines.slice(0, page1)
          });
          cursor = page1;
        }
        
        // Subsequent pages: running header, more lines
        while (cursor < allLines.length) {
          pages.push({
            pageNumber: pages.length + 1,
            template: 'subsequent',
            lines: allLines.slice(cursor, cursor + subsequent)
          });
          cursor += subsequent;
        }
        
        // Ensure at least one page
        if (pages.length === 0) {
          pages.push({
            pageNumber: 1,
            template: 'title',
            lines: []
          });
        }
        
        console.log('[Paginator] Distribution:', {
          targets: { page1, subsequent },
          totalLines: allLines.length,
          pageCount: pages.length,
          linesPerPage: pages.map(p => p.lines.length)
        });
        
        return pages;
      },
      
      /**
       * Get total page count for display
       */
      getPageCount(allLines, paperSize = 'letter') {
        const pages = this.distributeToPages(allLines, null, paperSize);
        return pages.length;
      },
      
      /**
       * Update measurements (call after render or resize)
       */
      update() {
        this.measureLineHeight();
        const paperSize = DocumentController.getSize();
        this.calculateLinesPerPage(paperSize);
      }
    };
    
    /* ========================================
       DASHBOARD CONTROLLER
       ======================================== */
    const DashboardController = {
      titleInput: null,
      opusInput: null,
      transcriberInput: null,
      composerSelect: null,
      poetSelect: null,
      exportBtn: null,
      // Welcome banner elements
      welcomePreface: null,
      welcomeNameInput: null,
      welcomeSaveBtn: null,
      welcomeSkipBtn: null,
      
      init() {
        this.titleInput = document.getElementById('metaTitle');
        this.opusInput = document.getElementById('metaOpus');
        this.transcriberInput = document.getElementById('metaTranscriber');
        this.exportBtn = document.getElementById('exportPdfBtn');
        
        // Welcome banner elements
        this.welcomePreface = document.getElementById('welcomePreface');
        this.welcomeNameInput = document.getElementById('welcomeNameInput');
        this.welcomeSaveBtn = document.getElementById('welcomeSaveBtn');
        this.welcomeSkipBtn = document.getElementById('welcomeSkipBtn');
        
        // Load saved name from localStorage and populate fields
        this.loadSavedName();
        
        // Wire up welcome banner actions
        this.welcomeSaveBtn?.addEventListener('click', () => this.handleWelcomeSave());
        this.welcomeSkipBtn?.addEventListener('click', () => this.handleWelcomeSkip());
        
        // Initialize searchable selects
        this.composerSelect = SearchableSelect.create({
          id: 'composer',
          trigger: document.getElementById('composerTrigger'),
          dropdown: document.getElementById('composerDropdown'),
          search: document.getElementById('composerSearch'),
          options: document.getElementById('composerOptions'),
          data: COMPOSERS,
          onSelect: (item) => this.updatePaperMetadata()
        });
        
        this.poetSelect = SearchableSelect.create({
          id: 'poet',
          trigger: document.getElementById('poetTrigger'),
          dropdown: document.getElementById('poetDropdown'),
          search: document.getElementById('poetSearch'),
          options: document.getElementById('poetOptions'),
          data: POETS,
          onSelect: (item) => this.updatePaperMetadata()
        });
        
        // Listen for text input changes
        this.titleInput?.addEventListener('input', () => this.updatePaperMetadata());
        this.opusInput?.addEventListener('input', () => this.updatePaperMetadata());
        this.transcriberInput?.addEventListener('input', () => this.updateTranscriber());
        // Also update localStorage on blur (for persistent changes)
        this.transcriberInput?.addEventListener('blur', () => this.syncTranscriberToStorage());
        
        // Export PDF button
        this.exportBtn?.addEventListener('click', () => this.exportPDF());
        
        // Update export button state
        this.updateExportButton();
      },
      
      // Load saved name from localStorage on init
      loadSavedName() {
        const savedName = localStorage.getItem('ilya_transcriber_name');
        const welcomeCompleted = localStorage.getItem('ilya_welcome_completed');
        
        // Pre-populate fields if name exists
        if (savedName) {
          DocumentState.userName = savedName;
          if (this.transcriberInput) {
            this.transcriberInput.value = savedName;
          }
        } else {
          DocumentState.userName = ''; // Empty = [unattributed]
        }
        
        // Show welcome banner only if not yet completed
        if (!welcomeCompleted && this.welcomePreface) {
          this.welcomePreface.classList.remove('hidden');
        }
      },
      
      // Handle Save button in welcome banner
      handleWelcomeSave() {
        const name = this.welcomeNameInput?.value.trim();
        if (name) {
          // Save to localStorage
          localStorage.setItem('ilya_transcriber_name', name);
          localStorage.setItem('ilya_welcome_completed', 'true');
          
          // Update DocumentState and drawer field
          DocumentState.userName = name;
          if (this.transcriberInput) {
            this.transcriberInput.value = name;
          }
          
          // Hide banner
          this.welcomePreface?.classList.add('hidden');
          
          // Re-render if content exists
          if (DocumentState.lines.length > 0) {
            DrawerController.renderToPaper();
          }
        }
      },
      
      // Handle Skip button in welcome banner
      handleWelcomeSkip() {
        // Mark as completed but don't save a name
        localStorage.setItem('ilya_welcome_completed', 'true');
        // Don't set ilya_transcriber_name — leaves it null/undefined
        
        // DocumentState.userName stays empty = [unattributed]
        DocumentState.userName = '';
        
        // Hide banner
        this.welcomePreface?.classList.add('hidden');
      },
      
      // Sync transcriber field changes to localStorage
      syncTranscriberToStorage() {
        const name = this.transcriberInput?.value.trim();
        if (name) {
          localStorage.setItem('ilya_transcriber_name', name);
        } else {
          localStorage.removeItem('ilya_transcriber_name');
        }
      },
      
      updateExportButton() {
        if (!this.exportBtn) return;
        const hasContent = DocumentState.lines.length > 0;
        this.exportBtn.disabled = !hasContent;
        this.exportBtn.title = hasContent ? 'Export transcription as PDF' : 'Transcribe text first';
      },
      
      exportPDF() {
        if (DocumentState.lines.length === 0) {
          alert('Please transcribe some text first.');
          return;
        }
        
        // Set document title for PDF filename suggestion
        const title = this.titleInput?.value || 'Ilya Transcription';
        const originalTitle = document.title;
        document.title = title;
        
        // Trigger print dialog
        window.print();
        
        // Restore document title after print dialog closes
        setTimeout(() => {
          document.title = originalTitle;
        }, 1000);
      },
      
      updateTranscriber() {
        const name = this.transcriberInput?.value.trim();
        DocumentState.userName = name || '';
        // Re-render to update footers
        if (DocumentState.lines.length > 0) {
          DrawerController.renderToPaper();
        }
      },
      
      updatePaperMetadata() {
        // In multi-page mode, metadata is embedded in page templates
        // Re-render to update headers with new metadata
        if (DocumentState.lines.length > 0) {
          DrawerController.renderToPaper();
        }
      },
      
      getMetadata() {
        return {
          title: this.titleInput?.value || '',
          opus: this.opusInput?.value || '',
          composer: this.composerSelect?.selectedValue || null,
          poet: this.poetSelect?.selectedValue || null,
          transcriber: this.transcriberInput?.value || ''
        };
      }
    };

    /* ========================================
       DRAWER CONTROLLER
       ======================================== */
    const DrawerController = {
      // Phase 2C: Now uses left drawer elements directly
      textInput: null,
      clearBtn: null,
      charCounter: null,
      // OCR elements
      ocrScanBtn: null,
      ocrFileInput: null,
      ocrStatus: null,
      ocrStatusText: null,
      
      init() {
        // Phase 2C: Use left drawer elements
        this.textInput = document.getElementById('drawerTextInput');
        this.clearBtn = document.getElementById('drawerClearBtn');
        this.charCounter = document.getElementById('drawerCharCounter');
        
        // OCR elements (in left drawer)
        this.ocrScanBtn = document.getElementById('drawerOcrBtn');
        this.ocrFileInput = document.getElementById('drawerOcrFileInput');
        this.ocrStatus = document.getElementById('drawerOcrStatus');
        this.ocrStatusText = this.ocrStatus?.querySelector('.ocr-status-text');
        
        // Initialize OCR (lazy-loads Tesseract in background)
        this.initOCR();
        
        // Update character counter when text changes
        this.textInput?.addEventListener('input', () => this.updateCharCounter());
        
        // Clear button
        this.clearBtn?.addEventListener('click', () => this.clear());
      },
      
      updateCharCounter() {
        if (!this.charCounter || !this.textInput) return;
        const len = this.textInput.value.length;
        if (len > 0) {
          this.charCounter.textContent = `${len} ${UI_LABELS['counter.chars'][currentGlossLanguage || 'en']}`;
          this.charCounter.classList.add('visible');
          this.charCounter.classList.toggle('warning', len > 5000);
          this.charCounter.classList.toggle('error', len > 10000);
        } else {
          this.charCounter.classList.remove('visible');
        }
      },
      
      clear() {
        // If there's transcribed content, confirm before clearing
        if (DocumentState.lines.length > 0) {
          if (!confirm('Clear transcription? This cannot be undone.')) {
            return;
          }
        }
        
        // Clear input field
        if (this.textInput) this.textInput.value = '';
        this.updateCharCounter();
        
        // Clear document state
        DocumentState.lines = [];
        
        // Re-render to show empty page with ghost text
        this.renderToPaper();
        
        this.textInput?.focus();
      },
      
      transcribe() {
        const text = this.textInput?.value?.trim() || '';
        if (!text) {
          this.textInput?.focus();
          return;
        }
        
        // Parse lines into words
        const lines = text.split('\n').filter(line => line.trim());
        
        // Invalidate pre-measurement cache when new content arrives (v5.11.17)
        Paginator.invalidateCache();
        
        // Convert to DocumentState format with dictionary lookup
        DocumentState.lines = lines.map(line => {
          const words = line.trim().split(/\s+/)
            // Filter out punctuation-only tokens (v5.11.8)
            .filter(word => {
              const cleaned = word.replace(/[.,!?;:"""''–—\-]/g, '');
              return cleaned.length > 0;
            });
          return words.map(word => {
            const lookup = GraysonEngine.lookupStress(word);
            
            // Determine the display form (may be ё-restored)
            let displayWord = word;
            let wasYoRestored = false;
            let dictionaryForm = null;
            
            if (lookup?.source === 'yo-restored' && lookup.canonicalForm) {
              // Restore ё while preserving original case pattern
              displayWord = GraysonEngine.applyCasePattern(word, lookup.canonicalForm);
              dictionaryForm = displayWord;  // Store what Ilya found
              wasYoRestored = true;
            }
            
            // ё always carries stress — check the display form (which may now have ё)
            const yoSyllable = GraysonEngine.findYoSyllable(displayWord);
            let stress, stressSource, yoSource;
            
            if (yoSyllable !== -1) {
              // ё found: stress is locked to that syllable
              stress = yoSyllable;
              stressSource = wasYoRestored ? 'yo-restored' : 'yo-rule';
              yoSource = wasYoRestored ? 'yo-restored' : null;  // null = native ё, no intervention
            } else if (lookup) {
              stress = lookup.stress;
              stressSource = lookup.source;
              yoSource = null;
            } else {
              // Unknown word: default to first syllable, marked for user verification
              stress = 0;
              stressSource = 'inferred';
              yoSource = null;
            }
            
            return {
              cyrillic: displayWord,
              stress: stress,
              gloss: lookup ? lookup.gloss : '',
              pos: lookup ? lookup.pos : '',
              lemma: lookup ? lookup.lemma : '',
              isHomograph: lookup ? lookup.isHomograph : false,
              originalStress: stress,
              stressSource: stressSource,
              hasYo: yoSyllable !== -1,
              originalInput: wasYoRestored ? word : null,  // What user typed (if different)
              dictionaryForm: dictionaryForm,              // What Ilya found (if restored)
              yoSource: yoSource,                          // yo-restored | user-yo-edit | null
              rightBoundary: null,
              boundarySource: null
            };
          });
        }).filter(line => line.length > 0);  // Remove empty lines (v5.11.8)
        
        // Auto-detect boundary types for each line
        DocumentState.lines.forEach(line => {
          GraysonEngine.autoDetectBoundaries(line);
        });
        
        // Render to paper
        this.renderToPaper();
        
        // Close drawer after transcription
        DrawerState.close();
      },
      
      renderToPaper(fallbackMode = false) {
        const paperStack = document.getElementById('paperStack');
        const paperSize = DocumentController.getSize();
        
        if (!paperStack) return;
        
        // Clear existing pages
        paperStack.innerHTML = '';
        
        // If no content, show empty title page with ghost text
        if (!DocumentState.lines || DocumentState.lines.length === 0) {
          const emptyPage = this.createPageElement(1, 'title', [], 1, paperSize);
          paperStack.appendChild(emptyPage);
          DocumentController.updatePageCount();
          DashboardController.updateExportButton();
          return;
        }
        
        // PHASE 1-2.5: Transcribe all lines
        const transcribedLines = this.transcribeAllLines();
        
        // Distribute lines to pages
        // Normal mode: 6/8, Fallback mode: 5/7 (guaranteed safe)
        const targets = fallbackMode 
          ? { page1: 5, subsequent: 7 }
          : { page1: 6, subsequent: 8 };
        
        const pages = Paginator.distributeToPages(transcribedLines, targets, paperSize);
        const totalPages = pages.length;
        
        console.log('[renderToPaper] Creating', totalPages, 'pages', fallbackMode ? '(fallback mode)' : '');
        
        // Render each page
        pages.forEach((pageData, pageIdx) => {
          const pageElement = this.createPageElement(
            pageData.pageNumber,
            pageData.template,
            pageData.lines,
            totalPages,
            paperSize
          );
          paperStack.appendChild(pageElement);
        });
        
        // POST-RENDER OVERFLOW CHECK (v5.11.19)
        // If overflow detected and not already in fallback mode, re-render with reduced counts
        if (!fallbackMode) {
          const hasOverflow = this.detectOverflow();
          if (hasOverflow) {
            console.warn('[renderToPaper] Overflow detected, re-rendering in fallback mode (5/7)');
            this.renderToPaper(true); // Recursive call with fallback
            return;
          }
        }
        
        // Update page count display and export button state
        DocumentController.updatePageCount();
        DashboardController.updateExportButton();
      },
      
      /**
       * Detect if any page has content overflow (v5.11.19)
       * Returns true if any last verse-line extends into footer zone
       */
      detectOverflow() {
        const pages = document.querySelectorAll('.paper-page');
        let hasOverflow = false;
        
        pages.forEach((page, idx) => {
          const pageContent = page.querySelector('.page-content');
          const footer = page.querySelector('.page-footer');
          
          if (!pageContent || !footer) return;
          
          const lastVerseLine = pageContent.querySelector('.verse-line:last-child');
          if (!lastVerseLine) return;
          
          const lineRect = lastVerseLine.getBoundingClientRect();
          const footerRect = footer.getBoundingClientRect();
          const lineBottom = lineRect.bottom;
          const footerTop = footerRect.top;
          
          // 20px safety margin
          if (lineBottom > footerTop - 20) {
            console.warn(`[Overflow] Page ${idx + 1}: line bottom ${lineBottom.toFixed(0)}px, footer top ${footerTop.toFixed(0)}px`);
            hasOverflow = true;
          }
        });
        
        return hasOverflow;
      },
      
      /**
       * Create a single page element with header, content, and footer
       */
      createPageElement(pageNumber, template, lines, totalPages, paperSize) {
        const page = document.createElement('article');
        page.className = 'paper-page';
        page.setAttribute('data-template', template);
        page.setAttribute('data-page', pageNumber);
        if (paperSize === 'a4') {
          page.setAttribute('data-size', 'a4');
        }
        
        // Get metadata from dashboard
        const title = DashboardController.titleInput?.value || UI_LABELS['paper.songTitle'][currentGlossLanguage || 'en'];
        const opus = DashboardController.opusInput?.value || '';
        // Format name from "Lastname, Firstname" to "Firstname Lastname"
        const formatNameForDisplay = (item) => {
          if (!item) return '';
          const name = item.latin || '';
          const dates = item.dates || '';
          // Split "Lastname, Firstname" and reverse
          const parts = name.split(',').map(p => p.trim());
          const displayName = parts.length > 1 ? `${parts[1]} ${parts[0]}` : name;
          return dates ? `${displayName} (${dates})` : displayName;
        };
        
        const composerDisplay = formatNameForDisplay(DashboardController.composerSelect?.selectedValue);
        const poetDisplay = formatNameForDisplay(DashboardController.poetSelect?.selectedValue);
        // For running header, keep surname only
        const composerSurname = DashboardController.composerSelect?.selectedValue?.latin?.split(',')[0]?.trim() || '';
        
        let headerHTML = '';
        
        if (template === 'title') {
          // Page 1: Full title block with logo
          headerHTML = `
            <div class="page-logo">
              <span class="bracket">[</span>
              <span class="logo-name">Ilya</span>
              <span class="bracket">]</span>
            </div>
            <header class="page-header-title">
              <h1 class="page-title">${title}</h1>
              <div class="page-metadata">
                ${composerDisplay ? `<span>${composerDisplay}</span>` : ''}
                ${composerDisplay && opus ? '<span class="divider">│</span>' : ''}
                ${opus ? `<span>${opus}</span>` : ''}
              </div>
              ${poetDisplay ? `<div class="page-metadata"><span>Text by ${poetDisplay}</span></div>` : ''}
              <hr class="page-metadata-rule">
            </header>
          `;
        } else {
          // Pages 2+: Running header
          const runningHeader = Paginator.formatRunningHeader(composerSurname, title);
          headerHTML = `
            <header class="page-header-running">
              <span class="running-title">${runningHeader}</span>
            </header>
          `;
        }
        
        // Content area
        let contentHTML = '';
        if (lines.length === 0 && template === 'title') {
          // Empty state — bilingual instruction to open drawer (v6.0.35)
          contentHTML = `
            <main class="page-content empty">
              <span class="page-ghost-text">
                Click here to open the drawer interface where you can type or paste Cyrillic Russian text.<br>
                Cliquez ici pour ouvrir le tiroir où vous pouvez coller ou saisir votre texte russe en cyrillique.
              </span>
            </main>
          `;
        } else {
          // Render verse lines
          const linesHTML = lines.map(line => this.renderVerseLine(line)).join('');
          contentHTML = `
            <main class="page-content">
              <div class="verse-container">${linesHTML}</div>
            </main>
          `;
        }
        
        // Footer with attribution (2/3) and pagination (1/3)
        const storedName = DocumentState.userName;
        const hasName = storedName && storedName.trim() !== '';
        const canadaFlag = `<svg xmlns="http://www.w3.org/2000/svg" width="1.5em" height="0.75em" viewBox="0 0 9600 4800" style="vertical-align: middle; margin-left: 0.25em;"><path fill="#f00" d="m0 0h2400l99 99h4602l99-99h2400v4800h-2400l-99-99h-4602l-99 99H0z"/><path fill="#fff" d="m2400 0h4800v4800h-4800zm2490 4430-45-863a95 95 0 0 1 111-98l859 151-116-320a65 65 0 0 1 20-73l941-762-212-99a65 65 0 0 1-34-79l186-572-542 115a65 65 0 0 1-73-38l-105-247-423 454a65 65 0 0 1-111-57l204-1052-327 189a65 65 0 0 1-91-27l-332-652-332 652a65 65 0 0 1-91 27l-327-189 204 1052a65 65 0 0 1-111 57l-423-454-105 247a65 65 0 0 1-73 38l-542-115 186 572a65 65 0 0 1-34 79l-212 99 941 762a65 65 0 0 1 20 73l-116 320 859-151a95 95 0 0 1 111 98l-45 863z"/></svg>`;
        
        // Bilingual footer text (v6.0.7, updated v6.0.34 for [unattributed])
        // Named: "Transcribed by [Name] using Ilya..."
        // Unattributed: "Transcription by [unattributed] using Ilya..."
        const footerText = currentGlossLanguage === 'fr' ? {
          para1: hasName 
            ? `Cette transcription a été réalisée par ${storedName} à l'aide d'<em>Ilya</em> v1.0, qui met en œuvre la <em>Russian Lyric Diction</em> du Dr Craig Grayson (Université de Washington, 2012). Données d'accentuation (1,3 million de mots) et gloses de traduction issues des Wiktionnaires anglais et français via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`
            : `Transcription par [non attribué] réalisée à l'aide d'<em>Ilya</em> v1.0, qui met en œuvre la <em>Russian Lyric Diction</em> du Dr Craig Grayson (Université de Washington, 2012). Données d'accentuation (1,3 million de mots) et gloses de traduction issues des Wiktionnaires anglais et français via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`,
          para2: `<em>Ilya</em> est un outil pédagogique libre et gratuit destiné au personnel enseignant et aux artistes interprètes : ni <em>Ilya</em> ni ses transcriptions ne peuvent être redistribués ou vendus. Conçu avec amour au Canada.${canadaFlag}`,
          pagination: `Page ${pageNumber} sur ${totalPages}`
        } : {
          para1: hasName
            ? `This transcription was created by ${storedName} using <em>Ilya</em> v1.0, which operationalizes Dr. Craig Grayson's <em>Russian Lyric Diction</em> (University of Washington, 2012). 1.3M-word stress data and translation glosses from English and French Wiktionary via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`
            : `Transcription by [unattributed] using <em>Ilya</em> v1.0, which operationalizes Dr. Craig Grayson's <em>Russian Lyric Diction</em> (University of Washington, 2012). 1.3M-word stress data and translation glosses from English and French Wiktionary via <a href="https://kaikki.org" target="_blank">kaikki.org</a> (CC BY-SA 4.0).`,
          para2: `<em>Ilya</em> is a free, open-source scholarly tool for teachers and performing artists: neither it nor its transcriptions may be repackaged or sold. Made with love in Canada.${canadaFlag}`,
          pagination: `Page ${pageNumber} of ${totalPages}`
        };
        
        const footerHTML = `
          <footer class="page-footer">
            <div class="footer-attribution">
              <p>${footerText.para1}</p>
              <p>${footerText.para2}</p>
            </div>
            <div class="footer-pagination">
              ${footerText.pagination}
            </div>
          </footer>
        `;
        
        page.innerHTML = headerHTML + contentHTML + footerHTML;
        
        return page;
      },
      
      /**
       * Render a single verse line (array of transcribed words) to HTML
       */
      renderVerseLine(transcribedWords) {
        if (!transcribedWords || !transcribedWords.length) return '';
        
        const wordStacksHTML = transcribedWords.map((tw, wordIdx) => {
          const classes = ['word-stack'];
          if (tw.isProclitic) classes.push('proclitic');
          if (tw.isEnclitic) classes.push('enclitic');
          if (tw.isVowellessClitic) classes.push('vowelless-clitic');
          
          // Check if stress is inferred (unknown word, needs verification)
          const isInferred = tw.wordData?.stressSource === 'inferred';
          
          // Build data attributes
          const dataAttrs = `
            data-word-id="${tw.lineIdx}-${tw.wordIdx}"
            data-line-index="${tw.lineIdx}"
            data-word-index="${tw.wordIdx}"
            data-cyrillic="${tw.cleanWord}"
            data-ipa="${tw.ipaSurface}"
            data-ipa-underlying="${tw.ipaUnderlying}"
            data-gloss="${typeof tw.wordData?.gloss === 'object' ? extractGloss(tw.wordData.gloss) : (tw.wordData?.gloss || '')}"
            data-pos="${tw.wordData?.pos || ''}"
            data-lemma="${tw.wordData?.lemma || ''}"
            data-punctuation="${tw.punct}"
            data-syllables='${JSON.stringify(tw.syllables)}'
            data-is-proclitic="${tw.isProclitic}"
            data-is-enclitic="${tw.isEnclitic}"
            data-is-o_-interjection="${tw.isO_Interjection || false}"
            data-is-first-word="${tw.isFirstWord || false}"
            data-line-ends-with-question="${tw.lineEndsWithQuestion || false}"
            data-proclitic-position="${tw.procliticPosition || ''}"
            data-has-yo="${tw.hasYo}"
            data-stress-source="${tw.wordData?.stressSource || ''}"
            data-right-boundary="${tw.rightBoundary || ''}"
            data-boundary-source="${tw.boundarySource || ''}"
            data-transcription-log='${JSON.stringify(tw.transcriptionLog || [])}'
            data-original-input="${tw.wordData?.originalInput || ''}"
            data-dictionary-form="${tw.wordData?.dictionaryForm || ''}"
            data-yo-source="${tw.wordData?.yoSource || ''}"
          `;
          
          // Build word stack HTML
          const wordStackHTML = `
            <div class="${classes.join(' ')}" tabindex="0" ${dataAttrs}>
              <span class="ipa">${tw.ipaDisplay}</span>
              <span class="cyrillic">${addStressMarkToCyrillic(tw.cleanWord, tw.syllables)}<span class="punct">${tw.punct}</span></span>
              <span class="gloss">${tw.isProclitic || tw.isEnclitic 
                ? extractGloss(GraysonEngine.cliticData.get(tw.cleanWord.toLowerCase())?.gloss)
                : formatGlossForDisplay(tw.wordData?.gloss, tw.wordData?.pos, tw.wordData?.lemma, tw.cleanWord)}</span>
            </div>
          `;
          
          // Wrap in Verify container if stress is inferred (v5.11.32)
          if (isInferred) {
            return `
              <div class="stress-unverified-container" data-word="${tw.cleanWord}">
                <span class="stress-unverified-label">${UI_LABELS['paper.verify'][currentGlossLanguage || 'en']}</span>
                ${wordStackHTML}
              </div>
            `;
          }
          
          return wordStackHTML;
        }).join('');
        
        return `<div class="verse-line" role="row">${wordStacksHTML}</div>`;
      },
      
      /**
       * Transcribe all lines (Phase 1-2.5)
       * Returns array of arrays of transcribed word objects
       */
      transcribeAllLines() {
        return DocumentState.lines.map((line, lineIdx) => {
          // PHASE 1: Transcribe all words, store ipaUnderlying
          const transcribedWords = line.map((wordData, wordIdx) => {
            // Capture trailing punctuation explicitly (v5.11.11 - fixes ghost text bug K)
            const trailingPunctMatch = wordData.cyrillic.match(/[.,!?;:"""'']+$/);
            const punct = trailingPunctMatch ? trailingPunctMatch[0] : '';
            const cleanWord = wordData.cyrillic
              .replace(/[.,!?;:"""'']+$/, '')  // Remove trailing punct
              .replace(/[-–—]/g, '');           // Remove hyphens/dashes (keep word intact)
            
            // Detect if line ends with question mark
            const lineText = line.map(w => w.cyrillic).join(' ');
            const lineEndsWithQuestion = /\?$/.test(lineText.trim());
            const isFirstWord = wordIdx === 0;
            
            // Special case: "о" as interjection vs preposition
            const isO_Word = cleanWord.toLowerCase() === 'о';
            const hasFollowingPunct = /[,!]/.test(punct);
            const isO_Interjection = isO_Word && (
              hasFollowingPunct ||
              (isFirstWord && !lineEndsWithQuestion)
            );
            
            const isProclitic = !isO_Interjection && GraysonEngine.proclitics.has(cleanWord.toLowerCase());
            const isEnclitic = GraysonEngine.enclitics.has(cleanWord.toLowerCase());
            const hasYo = GraysonEngine.hasYo(cleanWord);
            
            // For proclitics, determine reduction based on host word's stress position
            let procliticPosition = null;
            if (isProclitic && wordIdx < line.length - 1) {
              const nextWord = line[wordIdx + 1];
              const nextStress = nextWord.stress;
              procliticPosition = (nextStress === 0) ? 'pretonic' : 'remote';
            }
            
            const cliticStress = (isProclitic || isEnclitic) ? -1 : wordData.stress;
            const result = GraysonEngine.transcribe(cleanWord, cliticStress, isProclitic || isEnclitic, procliticPosition);
            
            return {
              wordData,
              wordIdx,
              lineIdx,
              cleanWord,
              punct,
              isProclitic,
              isEnclitic,
              isO_Interjection,
              isFirstWord,
              lineEndsWithQuestion,
              procliticPosition,
              hasYo,
              syllables: result.syllables,
              ipaUnderlying: result.ipaUnderlying,
              transcriptionLog: result.transcriptionLog,
              ipaSurface: null,
              skipFinalDevoicing: false,
              rightBoundary: wordData.rightBoundary,
              boundarySource: wordData.boundarySource
            };
          });
          
          // PHASE 2: Apply cross-word assimilation
          GraysonEngine.applyCrossWordAssimilation(transcribedWords);
          
          // PHASE 2.5: Sync syllable IPA with surface form after final devoicing
          transcribedWords.forEach(tw => {
            if (tw.ipaSurface !== tw.ipaUnderlying && tw.syllables.length > 0) {
              const lastSyl = tw.syllables[tw.syllables.length - 1];
              const underlyingConcat = tw.syllables.map(s => s.ipa).join('');
              // Remove stress marks AND spaces from surface for comparison
              const surfaceClean = tw.ipaSurface.replace(/[ˈ\s]+/g, '');
              
              const prefixLen = underlyingConcat.length - lastSyl.ipa.length;
              
              if (surfaceClean.length >= prefixLen) {
                const newLastSylIpa = surfaceClean.slice(prefixLen);
                lastSyl.ipa = newLastSylIpa;
                
                if (tw.transcriptionLog && tw.transcriptionLog.length > 0) {
                  for (let i = tw.transcriptionLog.length - 1; i >= 0; i--) {
                    const entry = tw.transcriptionLog[i];
                    if (entry.features && entry.features.type === 'consonant') {
                      const devoicingMap = GraysonEngine.voicedToVoiceless;
                      if (devoicingMap[entry.ipa]) {
                        entry.ipa = devoicingMap[entry.ipa];
                        entry.features.finalDevoicing = true;
                      }
                      break;
                    }
                  }
                }
              }
            }
            
            // Create IPA content (syllables with stress marks, spaces between)
            // v5.11.11: Show stress marks on monosyllables too (Issue L)
            let ipaCore;
            
            // If cross-word assimilation modified ipaSurface, use that directly
            // (e.g., sibilant merger: шумом after с → ˈʃːumʌm)
            if (tw.ipaSurface !== tw.ipaUnderlying) {
              ipaCore = tw.ipaSurface;
            } else {
              // Normal case: build from syllables
              ipaCore = tw.syllables.map(s => {
                return s.isStressed ? 'ˈ' + s.ipa : s.ipa;
              }).join(' ');
            }
            
            // Store the actual IPA for fusion (v5.11.10)
            tw.ipaContent = ipaCore;
            tw.ipaDisplay = ipaCore; // Will be overwritten for clitics
          });
          
          // PHASE 2.6: Clitic IPA fusion (v5.11.20)
          // Vowelless clitics fuse directly (no space, no arrow) - they're not syllables
          // Vowelled clitics keep space (they ARE syllables) and show directional arrows
          // Use canonicalIpa from cliticData ONLY for vowelless clitics (syllabification fails)
          // For vowelled clitics, use the dynamically calculated IPA (position-aware reduction)
          const cyrillicVowels = new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я',
                                          'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я']);
          const hasVowel = (word) => {
            return Array.from(word).some(char => cyrillicVowels.has(char));
          };
          
          transcribedWords.forEach((tw, idx) => {
            if (tw.isProclitic || tw.isEnclitic) {
              const isVowelless = !hasVowel(tw.cleanWord);
              if (isVowelless) {
                // Vowelless clitic: check if cross-word assimilation modified ipaSurface
                // If ipaSurface differs from ipaUnderlying, use the modified version
                // (e.g., sibilant merger: с + шумом → ipaSurface is empty, /s/ merged into host)
                if (tw.ipaSurface !== tw.ipaUnderlying) {
                  tw.ipaContent = tw.ipaSurface; // Use modified (possibly empty) IPA
                } else {
                  // No cross-word modification: use canonical IPA
                  const cliticInfo = GraysonEngine.cliticData.get(tw.cleanWord.toLowerCase());
                  tw.ipaContent = cliticInfo?.canonicalIpa || tw.ipaContent || '';
                }
              }
              // Vowelled clitics: keep dynamically calculated ipaContent (position-aware)
            }
            
            if (tw.isProclitic) {
              const nextWord = transcribedWords[idx + 1];
              const isVowelless = !hasVowel(tw.cleanWord);
              
              if (isVowelless) {
                // Vowelless proclitic: show arrow, fuse IPA to host
                tw.ipaDisplay = '→'; // Arrow shows attachment direction
                tw.isVowellessClitic = true;
                if (nextWord && !nextWord.isProclitic) {
                  // Fuse directly (no space)
                  // If host starts with stress mark, move it before the proclitic consonant
                  // Wrong: vˈstranst (stress mark after onset consonant)
                  // Right: ˈvstranst (stress mark before entire syllable onset)
                  if (nextWord.ipaDisplay.startsWith('ˈ')) {
                    nextWord.ipaDisplay = 'ˈ' + tw.ipaContent + nextWord.ipaDisplay.slice(1);
                  } else {
                    nextWord.ipaDisplay = tw.ipaContent + nextWord.ipaDisplay;
                  }
                }
              } else {
                // Vowelled proclitic: show arrow, keep as separate syllable
                tw.ipaDisplay = '→';
                tw.isVowellessClitic = false;
                if (nextWord && !nextWord.isProclitic) {
                  // Prepend with space (clitic is a syllable)
                  nextWord.ipaDisplay = tw.ipaContent + ' ' + nextWord.ipaDisplay;
                }
              }
            } else if (tw.isEnclitic) {
              const prevWord = transcribedWords[idx - 1];
              const isVowelless = !hasVowel(tw.cleanWord);
              
              if (isVowelless) {
                // Vowelless enclitic: show arrow, fuse IPA to host
                tw.ipaDisplay = '←'; // Arrow shows attachment direction
                tw.isVowellessClitic = true;
                if (prevWord && !prevWord.isEnclitic) {
                  // Fuse directly (no space)
                  prevWord.ipaDisplay = prevWord.ipaDisplay + tw.ipaContent;
                }
              } else {
                // Vowelled enclitic: show arrow, keep as separate syllable
                tw.ipaDisplay = '←';
                tw.isVowellessClitic = false;
                if (prevWord && !prevWord.isEnclitic) {
                  // Append with space (clitic is a syllable)
                  prevWord.ipaDisplay = prevWord.ipaDisplay + ' ' + tw.ipaContent;
                }
              }
            }
          });
          
          return transcribedWords;
        });
      },
      
      // ========================================
      // OCR Methods
      // ========================================
      
      /**
       * Initialize OCR module (lazy-loads Tesseract in background)
       */
      async initOCR() {
        if (!OCRModule.isSupported()) {
          console.log('OCR not supported in this browser');
          if (this.ocrScanBtn) this.ocrScanBtn.style.display = 'none';
          return;
        }
        
        // Set up error callback
        OCRModule.onError((msg) => {
          console.warn('OCR error:', msg);
          this.showOCRStatus('error', msg);
        });
        
        // Scan button triggers hidden file input
        this.ocrScanBtn?.addEventListener('click', () => {
          if (this.ocrScanBtn && !this.ocrScanBtn.disabled) {
            this.ocrFileInput?.click();
          }
        });
        
        // File selected → process
        this.ocrFileInput?.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          await this.processOCRFile(file);
          // Reset input for re-use
          if (this.ocrFileInput) this.ocrFileInput.value = '';
        });
        
        // Start lazy-loading Tesseract
        try {
          const loaded = await OCRModule.init();
          if (loaded && this.ocrScanBtn) {
            this.ocrScanBtn.disabled = false;
            this.ocrScanBtn.title = 'Import Russian text from image';
          }
        } catch (err) {
          console.error('OCR init failed:', err);
          if (this.ocrScanBtn) this.ocrScanBtn.title = 'OCR unavailable';
        }
      },
      
      /**
       * Process uploaded image file through OCR
       */
      async processOCRFile(file) {
        // Hide normal status, show OCR status
        this.charCounter?.classList.remove('visible');
        
        // Status message mapping (Kimi's "narrated steps")
        const statusMessages = {
          'loading tesseract': 'Loading recognition engine...',
          'loading language': 'Loading Russian dictionary...',
          'loading eng+rus traineddata': 'Loading Russian dictionary...',
          'loaded eng+rus traineddata': 'Dictionary loaded.',
          'processing': 'Analyzing image...',
          'recognizing text': 'Reading Cyrillic text...',
          'recognizing': 'Reading Cyrillic text...',
          'cleaning': 'Cleaning up results...'
        };
        
        try {
          const text = await OCRModule.processImage(file, (status, progress) => {
            const message = statusMessages[status] || status;
            this.showOCRStatus('processing', message);
          });
          
          if (text && this.textInput) {
            // Append to existing text with newline separator if not empty
            const existingText = this.textInput.value.trim();
            if (existingText) {
              this.textInput.value = existingText + '\n\n' + text;
            } else {
              this.textInput.value = text;
            }
            
            this.updateCharCounter();
            this.showOCRStatus('success', 'Import complete');
            
            // Clear success message after 3 seconds
            setTimeout(() => this.hideOCRStatus(), 3000);
          }
        } catch (err) {
          console.error('OCR processing failed:', err);
          this.showOCRStatus('error', err.message || 'Failed to read image');
          
          // Clear error after 5 seconds
          setTimeout(() => this.hideOCRStatus(), 5000);
        }
      },
      
      /**
       * Show OCR status message
       */
      showOCRStatus(type, message) {
        if (!this.ocrStatus) return;
        
        this.ocrStatus.style.display = 'flex';
        this.ocrStatus.className = 'ocr-status ' + type;
        
        if (this.ocrStatusText) {
          this.ocrStatusText.textContent = message;
        }
        
        // Show/hide spinner based on type
        const spinner = this.ocrStatus.querySelector('.spinner');
        if (spinner) {
          spinner.style.display = type === 'processing' ? 'block' : 'none';
        }
      },
      
      /**
       * Hide OCR status and restore normal footer status
       */
      hideOCRStatus() {
        if (this.ocrStatus) {
          this.ocrStatus.style.display = 'none';
        }
        // Let updatePreview restore char counter if needed
        this.updatePreview();
      }
    };

    /* ========================================
       LOOKUP TABLES: Composers and Poets
       ======================================== */
    const COMPOSERS = [
      { latin: 'Rachmaninoff, Sergei', cyrillic: 'Рахманинов, Сергей', dates: '1873–1943' },
      { latin: 'Tchaikovsky, Pyotr', cyrillic: 'Чайковский, Пётр', dates: '1840–1893' },
      { latin: 'Mussorgsky, Modest', cyrillic: 'Мусоргский, Модест', dates: '1839–1881' },
      { latin: 'Rimsky-Korsakov, Nikolai', cyrillic: 'Римский-Корсаков, Николай', dates: '1844–1908' },
      { latin: 'Glinka, Mikhail', cyrillic: 'Глинка, Михаил', dates: '1804–1857' },
      { latin: 'Borodin, Alexander', cyrillic: 'Бородин, Александр', dates: '1833–1887' },
      { latin: 'Cui, César', cyrillic: 'Кюи, Цезарь', dates: '1835–1918' },
      { latin: 'Dargomyzhsky, Alexander', cyrillic: 'Даргомыжский, Александр', dates: '1813–1869' },
      { latin: 'Arensky, Anton', cyrillic: 'Аренский, Антон', dates: '1861–1906' },
      { latin: 'Medtner, Nikolai', cyrillic: 'Метнер, Николай', dates: '1880–1951' },
      { latin: 'Taneyev, Sergei', cyrillic: 'Танеев, Сергей', dates: '1856–1915' },
      { latin: 'Gretchaninov, Alexander', cyrillic: 'Гречанинов, Александр', dates: '1864–1956' },
      { latin: 'Glazunov, Alexander', cyrillic: 'Глазунов, Александр', dates: '1865–1936' },
      { latin: 'Rubinstein, Anton', cyrillic: 'Рубинштейн, Антон', dates: '1829–1894' },
      { latin: 'Balakirev, Mily', cyrillic: 'Балакирев, Милий', dates: '1837–1910' },
      { latin: 'Prokofiev, Sergei', cyrillic: 'Прокофьев, Сергей', dates: '1891–1953' },
      { latin: 'Shostakovich, Dmitri', cyrillic: 'Шостакович, Дмитрий', dates: '1906–1975' },
      { latin: 'Stravinsky, Igor', cyrillic: 'Стравинский, Игорь', dates: '1882–1971' },
      { latin: 'Scriabin, Alexander', cyrillic: 'Скрябин, Александр', dates: '1872–1915' },
      { latin: 'Kabalevsky, Dmitri', cyrillic: 'Кабалевский, Дмитрий', dates: '1904–1987' },
      { latin: 'Sviridov, Georgy', cyrillic: 'Свиридов, Георгий', dates: '1915–1998' },
      { latin: 'Varlamov, Alexander', cyrillic: 'Варламов, Александр', dates: '1801–1848' },
      { latin: 'Gurilev, Alexander', cyrillic: 'Гурилёв, Александр', dates: '1803–1858' },
      { latin: 'Bulakhov, Pyotr', cyrillic: 'Булахов, Пётр', dates: '1822–1885' },
      { latin: 'Titov, Nikolai', cyrillic: 'Титов, Николай', dates: '1800–1875' }
    ];

    const POETS = [
      { latin: 'Pushkin, Alexander', cyrillic: 'Пушкин, Александр', dates: '1799–1837' },
      { latin: 'Lermontov, Mikhail', cyrillic: 'Лермонтов, Михаил', dates: '1814–1841' },
      { latin: 'Tyutchev, Fyodor', cyrillic: 'Тютчев, Фёдор', dates: '1803–1873' },
      { latin: 'Fet, Afanasy', cyrillic: 'Фет, Афанасий', dates: '1820–1892' },
      { latin: 'Tolstoy, Alexei K.', cyrillic: 'Толстой, Алексей К.', dates: '1817–1875' },
      { latin: 'Nekrasov, Nikolai', cyrillic: 'Некрасов, Николай', dates: '1821–1878' },
      { latin: 'Koltsov, Alexei', cyrillic: 'Кольцов, Алексей', dates: '1809–1842' },
      { latin: 'Maykov, Apollon', cyrillic: 'Майков, Аполлон', dates: '1821–1897' },
      { latin: 'Pleshcheyev, Alexei', cyrillic: 'Плещеев, Алексей', dates: '1825–1893' },
      { latin: 'Polonsky, Yakov', cyrillic: 'Полонский, Яков', dates: '1819–1898' },
      { latin: 'Mey, Lev', cyrillic: 'Мей, Лев', dates: '1822–1862' },
      { latin: 'Apukhtin, Alexei', cyrillic: 'Апухтин, Алексей', dates: '1840–1893' },
      { latin: 'Rathaus, Daniil', cyrillic: 'Ратгауз, Даниил', dates: '1868–1937' },
      { latin: 'Galina, Glafira', cyrillic: 'Галина, Глафира', dates: '1870–1942' },
      { latin: 'Balmont, Konstantin', cyrillic: 'Бальмонт, Константин', dates: '1867–1942' },
      { latin: 'Bryusov, Valery', cyrillic: 'Брюсов, Валерий', dates: '1873–1924' },
      { latin: 'Blok, Alexander', cyrillic: 'Блок, Александр', dates: '1880–1921' },
      { latin: 'Akhmatova, Anna', cyrillic: 'Ахматова, Анна', dates: '1889–1966' },
      { latin: 'Tsvetaeva, Marina', cyrillic: 'Цветаева, Марина', dates: '1892–1941' },
      { latin: 'Yesenin, Sergei', cyrillic: 'Есенин, Сергей', dates: '1895–1925' },
      { latin: 'Mandelstam, Osip', cyrillic: 'Мандельштам, Осип', dates: '1891–1938' },
      { latin: 'Pasternak, Boris', cyrillic: 'Пастернак, Борис', dates: '1890–1960' },
      { latin: 'Zhukovsky, Vasily', cyrillic: 'Жуковский, Василий', dates: '1783–1852' },
      { latin: 'Baratynsky, Yevgeny', cyrillic: 'Баратынский, Евгений', dates: '1800–1844' },
      { latin: 'Delvig, Anton', cyrillic: 'Дельвиг, Антон', dates: '1798–1831' },
      { latin: 'Khomyakov, Alexei', cyrillic: 'Хомяков, Алексей', dates: '1804–1860' },
      { latin: 'Golenishchev-Kutuzov, Arseny', cyrillic: 'Голенищев-Кутузов, Арсений', dates: '1848–1913' },
      { latin: 'Merezhkovsky, Dmitry', cyrillic: 'Мережковский, Дмитрий', dates: '1865–1941' },
      { latin: 'Gippius, Zinaida', cyrillic: 'Гиппиус, Зинаида', dates: '1869–1945' },
      { latin: 'Sologub, Fyodor', cyrillic: 'Сологуб, Фёдор', dates: '1863–1927' },
      { latin: 'Bely, Andrei', cyrillic: 'Белый, Андрей', dates: '1880–1934' },
      { latin: 'Bunin, Ivan', cyrillic: 'Бунин, Иван', dates: '1870–1953' },
      { latin: 'Shevchenko, Taras', cyrillic: 'Шевченко, Тарас', dates: '1814–1861' },
      { latin: 'Heine, Heinrich', cyrillic: 'Гейне, Генрих', dates: '1797–1856' },
      { latin: 'Goethe, Johann Wolfgang', cyrillic: 'Гёте, Иоганн Вольфганг', dates: '1749–1832' }
    ];


    /* ========================================
       STRESS DICTIONARY (OpenRussian, 51,644 words)
       CC-BY-SA-4.0 License
       ======================================== */
;

    /* ========================================
       GRAYSON ENGINE
       ======================================== */
    const GraysonEngine = {
      
      inventory: Object.freeze({
        vowels_stressed: {
          'а': 'ɑ', 'а_interpalatal': 'a',
          'о': 'o',
          'е': 'ɛ', 'е_interpalatal': 'e',
          'ё': 'o',
          'и': 'i',
          'ы': 'ɨ',
          'у': 'u',
          'ю': 'u',
          'я': 'ɑ', 'я_interpalatal': 'a',
          'э': 'ɛ'
        },
        vowels_unstressed: {
          'а_pretonic': 'ɑ', 'а_remote': 'ʌ',
          'о_pretonic': 'ɑ', 'о_remote': 'ʌ',
          'е_unstressed': 'ɪ',
          'и': 'i',
          'ы_unstressed': 'ɨ',
          'у_unstressed': 'u',
          'ю_unstressed': 'u',
          'я_unstressed': 'ɪ',
          'э_unstressed': 'ɪ'
        },
        consonants: {
          'б': 'b', 'п': 'p',
          'в': 'v', 'ф': 'f',
          'д': 'd', 'т': 't',
          'г': 'ɡ', 'к': 'k',
          'з': 'z', 'с': 's',
          'ж': 'ʒ', 'ш': 'ʃ',
          'х': 'x',
          'ц': 'ts',
          'ч': 'tʃʲ',
          'щ': 'ʃʲʃʲ',
          'л': 'l', 'л_hard': 'ɫ', 'л_soft': 'lʲ',
          'м': 'm',
          'н': 'n', 'н_soft': 'ɲ',
          'р': 'r',
          'й': 'j'
        },
        markers: {
          'palatalization': 'ʲ',
          'stress': 'ˈ'
        }
      }),
      
      vowels: new Set(['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я']),
      consonants: new Set(['б', 'в', 'г', 'д', 'ж', 'з', 'й', 'к', 'л', 'м', 'н', 'п', 'р', 'с', 'т', 'ф', 'х', 'ц', 'ч', 'ш', 'щ']),
      alwaysSoft: new Set(['ч', 'щ', 'й']),
      alwaysHard: new Set(['ж', 'ш', 'ц']),
      
      // Clitic data with canonical IPA for isolated forms (Grayson p. 248-257)
      // Canonical forms use pretonic reduction for proclitics, posttonic for enclitics
      cliticData: new Map([
        // Proclitics - canonical form assumes pretonic position
        // Short glosses curated for PDF display (v5.11.10)
        ['в', { type: 'proclitic', canonicalIpa: 'v', gloss: { en: 'in/into', fr: 'dans/en' } }],
        ['во', { type: 'proclitic', canonicalIpa: 'vɑ', gloss: { en: 'in/into', fr: 'dans/en' } }],
        ['к', { type: 'proclitic', canonicalIpa: 'k', gloss: { en: 'to/toward', fr: 'vers/à' } }],
        ['ко', { type: 'proclitic', canonicalIpa: 'kɑ', gloss: { en: 'to/toward', fr: 'vers/à' } }],
        ['с', { type: 'proclitic', canonicalIpa: 's', gloss: { en: 'with/from', fr: 'avec/de' } }],
        ['со', { type: 'proclitic', canonicalIpa: 'sɑ', gloss: { en: 'with/from', fr: 'avec/de' } }],
        ['о', { type: 'proclitic', canonicalIpa: 'ɑ', gloss: { en: 'about', fr: 'de/sur' } }],
        ['об', { type: 'proclitic', canonicalIpa: 'ɑb', gloss: { en: 'about', fr: 'de/sur' } }],
        ['обо', { type: 'proclitic', canonicalIpa: 'ɑbɑ', gloss: { en: 'about', fr: 'de/sur' } }],
        ['у', { type: 'proclitic', canonicalIpa: 'u', gloss: { en: 'at/by', fr: 'chez/près de' } }],
        ['на', { type: 'proclitic', canonicalIpa: 'nɑ', gloss: { en: 'on/onto', fr: 'sur' } }],
        ['за', { type: 'proclitic', canonicalIpa: 'zɑ', gloss: { en: 'behind/for', fr: 'derrière/pour' } }],
        ['по', { type: 'proclitic', canonicalIpa: 'pɑ', gloss: { en: 'along/by', fr: 'le long de/par' } }],
        ['до', { type: 'proclitic', canonicalIpa: 'dɑ', gloss: { en: 'until/to', fr: "jusqu'à" } }],
        ['из', { type: 'proclitic', canonicalIpa: 'iz', gloss: { en: 'from/out of', fr: 'de/hors de' } }],
        ['изо', { type: 'proclitic', canonicalIpa: 'izɑ', gloss: { en: 'from/out of', fr: 'de/hors de' } }],
        ['от', { type: 'proclitic', canonicalIpa: 'ɑt', gloss: { en: 'from', fr: 'de' } }],
        ['ото', { type: 'proclitic', canonicalIpa: 'ɑtɑ', gloss: { en: 'from', fr: 'de' } }],
        ['без', { type: 'proclitic', canonicalIpa: 'bʲɪz', gloss: { en: 'without', fr: 'sans' } }],
        ['не', { type: 'proclitic', canonicalIpa: 'ɲɪ', gloss: { en: 'not', fr: 'ne… pas' } }],
        ['ни', { type: 'proclitic', canonicalIpa: 'ɲi', gloss: { en: 'nor/not', fr: 'ni' } }],
        ['над', { type: 'proclitic', canonicalIpa: 'nɑt', gloss: { en: 'above', fr: 'au-dessus de' } }],
        ['надо', { type: 'proclitic', canonicalIpa: 'nɑdɑ', gloss: { en: 'above', fr: 'au-dessus de' } }],
        ['под', { type: 'proclitic', canonicalIpa: 'pɑt', gloss: { en: 'under', fr: 'sous' } }],
        ['подо', { type: 'proclitic', canonicalIpa: 'pɑdɑ', gloss: { en: 'under', fr: 'sous' } }],
        ['при', { type: 'proclitic', canonicalIpa: 'prʲi', gloss: { en: 'at/near', fr: 'près de/en présence de' } }],
        ['про', { type: 'proclitic', canonicalIpa: 'prɑ', gloss: { en: 'about', fr: 'au sujet de' } }],
        ['для', { type: 'proclitic', canonicalIpa: 'dlʲɑ', gloss: { en: 'for', fr: 'pour' } }],
        ['через', { type: 'proclitic', canonicalIpa: 'tʃʲɪrʲɪz', gloss: { en: 'through', fr: 'à travers' } }],
        ['перед', { type: 'proclitic', canonicalIpa: 'pʲɪrʲɪt', gloss: { en: 'before', fr: 'devant' } }],
        ['передо', { type: 'proclitic', canonicalIpa: 'pʲɪrʲɪdɑ', gloss: { en: 'before', fr: 'devant' } }],
        // Enclitics - canonical form assumes posttonic position
        ['ли', { type: 'enclitic', canonicalIpa: 'lʲi', gloss: { en: '(question)', fr: '(question)' } }],
        ['ль', { type: 'enclitic', canonicalIpa: 'lʲ', gloss: { en: '(question)', fr: '(question)' } }],
        ['же', { type: 'enclitic', canonicalIpa: 'ʒɨ', gloss: { en: '(emphasis)', fr: '(emphase)' } }],
        ['бы', { type: 'enclitic', canonicalIpa: 'bɨ', gloss: { en: 'would', fr: '(conditionnel)' } }],
        ['б', { type: 'enclitic', canonicalIpa: 'b', gloss: { en: 'would', fr: '(conditionnel)' } }],
        ['то', { type: 'enclitic', canonicalIpa: 'tɑ', gloss: { en: '(then)', fr: '(alors)' } }],
        ['ка', { type: 'enclitic', canonicalIpa: 'kɑ', gloss: { en: '(urging)', fr: '(exhortation)' } }],
        ['таки', { type: 'enclitic', canonicalIpa: 'tɑkʲi', gloss: { en: 'after all', fr: 'tout de même' } }],
      ]),
      
      // Derived Sets for backwards compatibility (computed once, not on every access)
      proclitics: null, // Initialized below
      enclitics: null,  // Initialized below
      
      // Regressive palatalization categorical restrictions (Grayson p. 209; Derwing & Priestly pp. 76-87)
      // These consonants BLOCK regressive palatalization — consonants before them do not soften
      // NOTE: Grayson's example сестрёнка /sʲtʲrʲ/ appears to be an error; D&P pp. 85-87 confirms
      // that р blocks regressive palatalization. <em>Ilya</em> follows D&P: сестрёнка → /strʲ/
      regressivePalatalizationBlockers: new Set(['р', 'л']), // р and л block regressive palatalization (except doubled)
      
      // Categorical restrictions for regressive palatalization (Grayson p. 209)
      // Velars only palatalize before palatalized velars
      velars: new Set(['к', 'г', 'х']),
      // Labials only palatalize before palatalized labials
      labials: new Set(['б', 'п', 'в', 'ф', 'м']),
      // Dentals palatalize more freely
      dentals: new Set(['т', 'д', 'с', 'з', 'н', 'ц']),
      // н only palatalizes before palatalized н or dental
      
      // Special consonant clusters (Grayson p. 225-247)
      // These are detected and transcribed as units before letter-by-letter processing
      specialClusters: {
        'сч': 'ʃʲʃʲ',   // Same as щ (p. 230-231)
        'зч': 'ʃʲʃʲ',   // Same as щ (p. 230-231)
        // Sibilant mergers (Grayson pp. 235-236)
        'сш': 'ʃː',     // с + ш → long unvoiced postalveolar (p. 235)
        'зш': 'ʃː',     // з + ш → long unvoiced postalveolar (devoices, p. 235)
        'сж': 'ʒː',     // с + ж → long voiced postalveolar (voices, p. 236)
        'зж': 'ʒː',     // з + ж → long voiced postalveolar (p. 236)
      },
      
      // Reflexive verb suffix clusters (Grayson p. 237-238)
      // "The clusters -тс-/-дс- and -тьс-/-дьс- resemble /ts/ but have an elongated stop"
      // These are ONLY checked at word end (suffix position)
      reflexiveSuffixes: {
        'ться': 'tːsʌ',  // купаться → /kuˈpɑtːsʌ/
        'тся': 'tːsʌ',   // боится → /bɑˈitːsʌ/
      },
      
      // Word-specific cluster overrides (p. 239-240)
      wordSpecificClusters: {
        'конечно': { 'чн': 'ʃn' },
        'скучно': { 'чн': 'ʃn' },
        'скучный': { 'чн': 'ʃn' },
        'нарочно': { 'чн': 'ʃn' },
        'яичница': { 'чн': 'ʃn' },
        'что': { 'чт': 'ʃt' },
        'чтоб': { 'чт': 'ʃt' },
        'чтобы': { 'чт': 'ʃt' },
        'ничто': { 'чт': 'ʃt' },
        // русский exception (Grayson p. 233): single /s/, not geminate
        // Also overrides Old Muscovite -кий rule — uses modern soft кʲ
        'русский': { 'сс': 's' },
        'русская': { 'сс': 's' },
        'русское': { 'сс': 's' },
        'русские': { 'сс': 's' },
        'русского': { 'сс': 's' },
        'русскому': { 'сс': 's' },
        'русским': { 'сс': 's' },
        'русскими': { 'сс': 's' },
        'русской': { 'сс': 's' },
        'русских': { 'сс': 's' },
        'русскую': { 'сс': 's' },
        'русском': { 'сс': 's' },
        // Silent consonant exceptions (Grayson p. 235-236)
        // сердце family: рдц → рц (д silent)
        'сердце': { 'рдц': 'rts' },
        'сердца': { 'рдц': 'rts' },
        'сердцу': { 'рдц': 'rts' },
        'сердцем': { 'рдц': 'rts' },
        // солнце family: лнц → нц (л silent)
        'солнце': { 'лнц': 'nts' },
        'солнца': { 'лнц': 'nts' },
        'солнцу': { 'лнц': 'nts' },
        'солнцем': { 'лнц': 'nts' },
        // здравствуй family: вств → ств (first в silent)
        'здравствуй': { 'вств': 'stv' },
        'здравствуйте': { 'вств': 'stv' },
        'здравствуют': { 'вств': 'stv' },
        // чувство family: вств → ств (first в silent)
        'чувство': { 'вств': 'stv' },
        'чувства': { 'вств': 'stv' },
        'чувствам': { 'вств': 'stv' },
        'чувствами': { 'вств': 'stv' },
        'чувствах': { 'вств': 'stv' },
        'чувствую': { 'вств': 'stv' },
        'чувствует': { 'вств': 'stv' },
        'чувствовать': { 'вств': 'stv' },
        // бесчувственный family: вств → ств (first в silent)
        'бесчувственный': { 'вств': 'stv' },
        'бесчувственная': { 'вств': 'stv' },
        'бесчувственное': { 'вств': 'stv' },
        'бесчувственные': { 'вств': 'stv' },
        'бесчувственного': { 'вств': 'stv' },
        'бесчувственной': { 'вств': 'stv' },
        'бесчувственному': { 'вств': 'stv' },
        'бесчувственным': { 'вств': 'stv' },
        'бесчувственными': { 'вств': 'stv' },
        'бесчувственных': { 'вств': 'stv' },
        'бесчувственную': { 'вств': 'stv' },
        'бесчувственном': { 'вств': 'stv' },
        // Silent т in стн cluster (Grayson p. 235)
        // честный family (honest)
        'честный': { 'стн': 'sn' },
        'честная': { 'стн': 'sn' },
        'честное': { 'стн': 'sn' },
        'честные': { 'стн': 'sn' },
        'честного': { 'стн': 'sn' },
        'честной': { 'стн': 'sn' },
        'честному': { 'стн': 'sn' },
        'честным': { 'стн': 'sn' },
        'честными': { 'стн': 'sn' },
        'честных': { 'стн': 'sn' },
        'честную': { 'стн': 'sn' },
        'честном': { 'стн': 'sn' },
        'честно': { 'стн': 'sn' },
        // известный family (famous)
        'известный': { 'стн': 'sn' },
        'известная': { 'стн': 'sn' },
        'известное': { 'стн': 'sn' },
        'известные': { 'стн': 'sn' },
        'известного': { 'стн': 'sn' },
        'известной': { 'стн': 'sn' },
        'известному': { 'стн': 'sn' },
        'известным': { 'стн': 'sn' },
        'известными': { 'стн': 'sn' },
        'известных': { 'стн': 'sn' },
        'известную': { 'стн': 'sn' },
        'известном': { 'стн': 'sn' },
        'известно': { 'стн': 'sn' },
        // грустный family (sad)
        'грустный': { 'стн': 'sn' },
        'грустная': { 'стн': 'sn' },
        'грустное': { 'стн': 'sn' },
        'грустные': { 'стн': 'sn' },
        'грустного': { 'стн': 'sn' },
        'грустной': { 'стн': 'sn' },
        'грустному': { 'стн': 'sn' },
        'грустным': { 'стн': 'sn' },
        'грустными': { 'стн': 'sn' },
        'грустных': { 'стн': 'sn' },
        'грустную': { 'стн': 'sn' },
        'грустном': { 'стн': 'sn' },
        'грустно': { 'стн': 'sn' },
        // местный family (local)
        'местный': { 'стн': 'sn' },
        'местная': { 'стн': 'sn' },
        'местное': { 'стн': 'sn' },
        'местные': { 'стн': 'sn' },
        'местного': { 'стн': 'sn' },
        'местной': { 'стн': 'sn' },
        'местному': { 'стн': 'sn' },
        'местным': { 'стн': 'sn' },
        'местными': { 'стн': 'sn' },
        'местных': { 'стн': 'sn' },
        'местную': { 'стн': 'sn' },
        'местном': { 'стн': 'sn' },
        // частный family (private)
        'частный': { 'стн': 'sn' },
        'частная': { 'стн': 'sn' },
        'частное': { 'стн': 'sn' },
        'частные': { 'стн': 'sn' },
        'частного': { 'стн': 'sn' },
        'частной': { 'стн': 'sn' },
        'частному': { 'стн': 'sn' },
        'частным': { 'стн': 'sn' },
        'частными': { 'стн': 'sn' },
        'частных': { 'стн': 'sn' },
        'частную': { 'стн': 'sn' },
        'частном': { 'стн': 'sn' },
        'частно': { 'стн': 'sn' },
        // прелестный family (lovely)
        'прелестный': { 'стн': 'sn' },
        'прелестная': { 'стн': 'sn' },
        'прелестное': { 'стн': 'sn' },
        'прелестные': { 'стн': 'sn' },
        'прелестного': { 'стн': 'sn' },
        'прелестной': { 'стн': 'sn' },
        'прелестному': { 'стн': 'sn' },
        'прелестным': { 'стн': 'sn' },
        'прелестными': { 'стн': 'sn' },
        'прелестных': { 'стн': 'sn' },
        'прелестную': { 'стн': 'sn' },
        'прелестном': { 'стн': 'sn' },
        // Silent д in здн cluster (Grayson p. 235)
        // поздно family (late)
        'поздно': { 'здн': 'zn' },
        'поздний': { 'здн': 'zn' },
        'поздняя': { 'здн': 'zn' },
        'позднее': { 'здн': 'zn' },
        'поздние': { 'здн': 'zn' },
        'позднего': { 'здн': 'zn' },
        'поздней': { 'здн': 'zn' },
        'позднему': { 'здн': 'zn' },
        'поздним': { 'здн': 'zn' },
        'поздними': { 'здн': 'zn' },
        'поздних': { 'здн': 'zn' },
        'позднюю': { 'здн': 'zn' },
        'позднем': { 'здн': 'zn' },
        // праздник family (holiday)
        'праздник': { 'здн': 'zn' },
        'праздника': { 'здн': 'zn' },
        'праздникам': { 'здн': 'zn' },
        'праздниками': { 'здн': 'zn' },
        'праздниках': { 'здн': 'zn' },
        'праздники': { 'здн': 'zn' },
        'праздников': { 'здн': 'zn' },
        'праздником': { 'здн': 'zn' },
        'праздникам': { 'здн': 'zn' },
        'праздниках': { 'здн': 'zn' },
        'праздничный': { 'здн': 'zn' },
        'праздничная': { 'здн': 'zn' },
        'праздничное': { 'здн': 'zn' },
        'праздничные': { 'здн': 'zn' },
        'праздничного': { 'здн': 'zn' },
        'праздничной': { 'здн': 'zn' },
        'праздничному': { 'здн': 'zn' },
        'праздничным': { 'здн': 'zn' },
        'праздничными': { 'здн': 'zn' },
        'праздничных': { 'здн': 'zn' },
        'праздничную': { 'здн': 'zn' },
        'праздничном': { 'здн': 'zn' },
        // звёздный family (starry) - also has здн
        'звёздный': { 'здн': 'zn' },
        'звёздная': { 'здн': 'zn' },
        'звёздное': { 'здн': 'zn' },
        'звёздные': { 'здн': 'zn' },
        'звёздного': { 'здн': 'zn' },
        'звёздной': { 'здн': 'zn' },
        'звёздному': { 'здн': 'zn' },
        'звёздным': { 'здн': 'zn' },
        'звёздными': { 'здн': 'zn' },
        'звёздных': { 'здн': 'zn' },
        'звёздную': { 'здн': 'zn' },
        'звёздном': { 'здн': 'zn' },
      },
      
      // Exception words where normal phonological rules don't apply (Grayson Appendix F)
      exceptionWords: {
        'счастье': { vowelOverrides: { 2: 'ɑ' } },
        'счастья': { vowelOverrides: { 2: 'ɑ' } },
        'счастлив': { vowelOverrides: { 2: 'ɑ' } },
        'счастливый': { vowelOverrides: { 2: 'ɑ' } },
        // русский exception (Grayson p. 233): uses modern -кий (soft), not Old Muscovite
        'русский': { skipVelarAdjectival: true },
        'русская': { skipVelarAdjectival: true },
        'русское': { skipVelarAdjectival: true },
        'русские': { skipVelarAdjectival: true },
        'русского': { skipVelarAdjectival: true },
        'русскому': { skipVelarAdjectival: true },
        'русским': { skipVelarAdjectival: true },
        'русскими': { skipVelarAdjectival: true },
        'русской': { skipVelarAdjectival: true },
        'русских': { skipVelarAdjectival: true },
        'русскую': { skipVelarAdjectival: true },
        'русском': { skipVelarAdjectival: true },
      },
      
      // Find special clusters in a word
      findSpecialClusters(word) {
        const cleanWord = word.toLowerCase();
        const clusters = [];
        
        // Check word-specific clusters first (higher priority)
        const wordOverrides = this.wordSpecificClusters[cleanWord];
        if (wordOverrides) {
          for (const [cluster, ipa] of Object.entries(wordOverrides)) {
            let idx = cleanWord.indexOf(cluster);
            while (idx !== -1) {
              clusters.push({ 
                startIndex: idx, 
                endIndex: idx + cluster.length - 1,
                cluster: cluster, 
                ipa: ipa 
              });
              idx = cleanWord.indexOf(cluster, idx + 1);
            }
          }
        }
        
        // Check reflexive suffixes (only at word end)
        for (const [suffix, ipa] of Object.entries(this.reflexiveSuffixes)) {
          if (cleanWord.endsWith(suffix)) {
            const startIdx = cleanWord.length - suffix.length;
            clusters.push({
              startIndex: startIdx,
              endIndex: cleanWord.length - 1,
              cluster: suffix,
              ipa: ipa
            });
            break; // Only one reflexive suffix per word
          }
        }
        
        // Check universal clusters
        for (const [cluster, ipa] of Object.entries(this.specialClusters)) {
          let idx = cleanWord.indexOf(cluster);
          while (idx !== -1) {
            // Skip if already covered
            const alreadyCovered = clusters.some(c => 
              (idx >= c.startIndex && idx <= c.endIndex) ||
              (idx + cluster.length - 1 >= c.startIndex && idx + cluster.length - 1 <= c.endIndex)
            );
            if (!alreadyCovered) {
              clusters.push({ 
                startIndex: idx, 
                endIndex: idx + cluster.length - 1,
                cluster: cluster, 
                ipa: ipa 
              });
            }
            idx = cleanWord.indexOf(cluster, idx + 1);
          }
        }
        
        return clusters.sort((a, b) => a.startIndex - b.startIndex);
      },
      
      // Check for vowel override in exception words
      getVowelOverride(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const exception = this.exceptionWords[cleanWord];
        if (exception?.vowelOverrides?.[charIndex] !== undefined) {
          return exception.vowelOverrides[charIndex];
        }
        return null;
      },
      
      // Check for -ая/-яя suffix exception (Grayson p. 124)
      // Feminine adjective endings are ALWAYS sung as /ɑjɑ/, never reduced
      isAyaSuffixVowel(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Check if word ends in -ая or -яя
        if (len >= 2) {
          const ending = cleanWord.slice(-2);
          if (ending === 'ая' || ending === 'яя') {
            // Check if this charIndex is one of the two final vowels
            if (charIndex === len - 2 || charIndex === len - 1) {
              return true;
            }
          }
        }
        return false;
      },
      
      // Check for Old Muscovite adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
      // When profile is 'stage': velars stay hard, и → [ɨ], й → [j]
      // Returns: { isVelarAdjectival: bool, charRole: 'velar'|'i'|'j'|null }
      checkVelarAdjectival(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Check if this word is an exception (e.g., русский uses modern -кий)
        const exception = this.exceptionWords[cleanWord];
        if (exception?.skipVelarAdjectival) {
          return { isVelarAdjectival: false, charRole: null };
        }
        
        // Check if word ends in -кий, -гий, or -хий
        if (len >= 3) {
          const ending = cleanWord.slice(-3);
          const velars = ['кий', 'гий', 'хий'];
          
          if (velars.includes(ending)) {
            const suffixStart = len - 3;
            
            // Check which part of the suffix this charIndex is
            if (charIndex === suffixStart) {
              return { isVelarAdjectival: true, charRole: 'velar' };
            } else if (charIndex === suffixStart + 1) {
              return { isVelarAdjectival: true, charRole: 'i' };
            } else if (charIndex === suffixStart + 2) {
              return { isVelarAdjectival: true, charRole: 'j' };
            }
          }
        }
        return { isVelarAdjectival: false, charRole: null };
      },
      
      // Check for genitive ending -ого/-его where г → /v/ (Grayson p. 243)
      // Exception: много, строго, etc. where -ого is NOT a genitive ending
      checkGenitiveEnding(word, charIndex) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const len = cleanWord.length;
        
        // Exceptions: words where -ого/-его is NOT a genitive ending
        const exceptions = new Set([
          'много', 'немного', 'строго', 'нестрого', 'убого', 
          'отлого', 'полого', 'дорого', 'недорого', 'другого' // 'другого' IS genitive, but listed in some sources
        ]);
        
        // Remove другого from exceptions - it IS a genitive form
        exceptions.delete('другого');
        
        if (exceptions.has(cleanWord)) {
          return false;
        }
        
        // Check if word ends in -ого or -его
        if (len >= 3) {
          const ending3 = cleanWord.slice(-3);
          if (ending3 === 'ого' || ending3 === 'его') {
            // The г is at position len - 2 (second to last character)
            const gPosition = len - 2;
            return charIndex === gPosition;
          }
        }
        
        return false;
      },
      
      // Look up stress from dictionary
      // Handles both old format and new kaikki format (including homographs)
      lookupStress(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // Helper to normalize entry format
        const normalizeEntry = (entry, source = 'dictionary') => {
          if (!entry) return null;
          
          // Handle homographs (arrays) - return first match for now, mark as homograph
          if (Array.isArray(entry)) {
            const firstEntry = entry[0];
            const rawGloss = firstEntry.gloss ?? firstEntry.g;
            return {
              stress: firstEntry.stress ?? firstEntry.s,
              gloss: rawGloss,
              pos: firstEntry.pos ?? firstEntry.p ?? '',
              lemma: firstEntry.lemma ?? firstEntry.l ?? '',
              source: source,
              isHomograph: true,
              allEntries: entry,
              canonicalForm: cleanWord
            };
          }
          
          // Single entry
          const rawGloss = entry.gloss ?? entry.g;
          return {
            stress: entry.stress ?? entry.s,
            gloss: rawGloss,
            pos: entry.pos ?? entry.p ?? '',
            lemma: entry.lemma ?? entry.l ?? '',
            source: entry.source || source,
            isHomograph: false,
            canonicalForm: cleanWord
          };
        };
        
        // Phase 1: Check SINGER_SUPPLEMENT first (authoritative overrides)
        // This catches critical corrections like и→"and" (not "the tenth letter")
        const supplementEntry = SINGER_SUPPLEMENT[cleanWord];
        if (supplementEntry) {
          return normalizeEntry(supplementEntry, 'supplement');
        }
        
        // Phase 1b: Try dictionary lookup
        const exactEntry = STRESS_DICTIONARY[cleanWord];
        if (exactEntry) {
          return normalizeEntry(exactEntry, 'dictionary');
        }
        
        // Phase 2: Word not found — try ё-restoration
        // Russian publishers often omit the dieresis, printing ⟨е⟩ where ⟨ё⟩ should appear
        const chars = [...cleanWord];
        for (let i = 0; i < chars.length; i++) {
          if (chars[i] === 'е') {
            // Try substituting this е with ё
            const candidate = [...chars];
            candidate[i] = 'ё';
            const candidateWord = candidate.join('');
            
            const restoredEntry = STRESS_DICTIONARY[candidateWord] || SINGER_SUPPLEMENT[candidateWord];
            if (restoredEntry) {
              const result = normalizeEntry(restoredEntry, 'yo-restored');
              if (result) {
                result.canonicalForm = candidateWord;
                result.originalInput = cleanWord;
              }
              return result;
            }
          }
        }
        
        // Phase 2b: Try ё→е normalization
        // Some dictionaries store the е-form even when ё is correct
        // If user types ёлка but dictionary has елка, try that
        if (cleanWord.includes('ё')) {
          const normalizedWord = cleanWord.replace(/ё/g, 'е');
          const normalizedEntry = STRESS_DICTIONARY[normalizedWord] || SINGER_SUPPLEMENT[normalizedWord];
          if (normalizedEntry) {
            const result = normalizeEntry(normalizedEntry, 'yo-normalized');
            if (result) {
              result.canonicalForm = cleanWord; // Keep the ё form as canonical
              result.originalInput = cleanWord;
            }
            return result;
          }
        }
        
        // Phase 3: No match found
        return null;
      },
      
      // Apply the case pattern from original word to canonical form
      // Preserves uppercase/lowercase pattern when restoring ё
      applyCasePattern(original, canonical) {
        // Strip punctuation from original to get just letters
        const origLetters = original.replace(/[.,!?;:"""''–—]/g, '');
        const canonLetters = canonical;
        
        // If lengths don't match, just return canonical (shouldn't happen with е→ё)
        if (origLetters.length !== canonLetters.length) {
          return canonical;
        }
        
        // Apply case from original to canonical, character by character
        const result = [];
        for (let i = 0; i < canonLetters.length; i++) {
          const origChar = origLetters[i];
          const canonChar = canonLetters[i];
          
          // Check if original was uppercase
          if (origChar === origChar.toUpperCase() && origChar !== origChar.toLowerCase()) {
            // Original was uppercase — apply to canonical
            result.push(canonChar.toUpperCase());
          } else {
            result.push(canonChar.toLowerCase());
          }
        }
        
        // Re-append any trailing punctuation from original
        const trailingPunct = original.match(/[.,!?;:"""''–—]+$/);
        return result.join('') + (trailingPunct ? trailingPunct[0] : '');
      },
      
      isVowel(char) {
        return this.vowels.has(char?.toLowerCase());
      },
      
      isConsonant(char) {
        return this.consonants.has(char?.toLowerCase());
      },
      
      isPalatalized(char, nextChar) {
        char = char?.toLowerCase();
        nextChar = nextChar?.toLowerCase();
        
        if (this.alwaysSoft.has(char)) return true;
        if (this.alwaysHard.has(char)) return false;
        if (nextChar === 'ь') return true;
        if (['е', 'ё', 'и', 'ю', 'я'].includes(nextChar)) return true;
        
        return false;
      },
      
      // COMPLETE PALATALIZATION MAP (Grayson p. 207-209; D&P pp. 76-87)
      // Computes ALL palatalization sources upfront, before any transcription.
      // This ensures vowel interpalatal detection knows about progressive palatalization.
      // Architecture per Kimi's spec: single source of truth for vowels AND consonants.
      //
      // Pass 1: Direct palatalization (consonants before front vowels/ь)
      // Pass 2: Regressive chain through consonant clusters
      // Pass 3: Progressive palatalization of р (Grayson p. 209, footnote 277)
      //
      // Returns a Map of character indices that should be palatalized.
      computeCompletePalatalizationMap(word, syllables, stressIndex) {
        const chars = [...word.toLowerCase()];
        const softIndices = new Map(); // index -> true if should be palatalized
        
        // Compute syllable boundaries: which char indices are in each syllable
        const syllableBoundaries = []; // Array of { start, end, isStressed }
        let charPos = 0;
        syllables.forEach((syl, sylIdx) => {
          const start = charPos;
          const end = charPos + syl.length - 1;
          syllableBoundaries.push({
            start,
            end,
            isStressed: sylIdx === stressIndex
          });
          charPos += syl.length;
        });
        
        // Helper: check if character index is in the stressed syllable
        const isInStressedSyllable = (index) => {
          const boundary = syllableBoundaries.find(b => index >= b.start && index <= b.end);
          return boundary ? boundary.isStressed : false;
        };
        
        // PASS 1: Mark directly palatalized consonants (before indicator letters or ь)
        for (let i = 0; i < chars.length; i++) {
          if (this.isConsonant(chars[i])) {
            if (this.isPalatalized(chars[i], chars[i + 1])) {
              softIndices.set(i, true);
            }
          }
        }
        
        // PASS 2: Process regressive palatalization right-to-left through clusters
        // Working backwards, check if palatalization can step through
        for (let i = chars.length - 2; i >= 0; i--) {
          const char = chars[i];
          const nextChar = chars[i + 1];
          
          if (!this.isConsonant(char)) continue;
          if (softIndices.has(i)) continue; // Already soft
          
          // Check if next consonant is soft
          const nextIsSoft = softIndices.has(i + 1);
          if (!nextIsSoft) continue;
          
          // Check for blockers (Grayson p. 209; D&P pp. 85-87)
          // р and л block regressive palatalization (confirmed by D&P)
          if (this.regressivePalatalizationBlockers.has(nextChar)) {
            continue; // Blocked - don't palatalize through р or л
          }
          
          // Check categorical restrictions (Grayson p. 209)
          if (!this.canRegressivelyPalatalize(char, nextChar)) {
            continue; // Categorical mismatch
          }
          
          // Check for boundaries
          if (this.alwaysHard.has(char)) continue; // ж, ш, ц never palatalize
          if (chars[i + 1] === 'ъ') continue; // Hard sign blocks (except в, с, з - handled separately)
          
          // This consonant can be regressively palatalized
          softIndices.set(i, true);
        }
        
        // PASS 3: Progressive palatalization of р (Grayson p. 209, footnote 277)
        // "Do not regressively palatalize /r/ within a cluster except...
        // directly following -и-, -е-, or -э- (in the stressed syllable only)"
        // Examples: смерть /sʲmʲerʲtʲ/, терпеть /tʲirʲˈpʲetʲ/, кирпич /kʲirʲˈpʲitʃʲ/
        // NOTE: Applies only when р is in a CLUSTER (followed by consonant).
        // Word-final р after front vowel does NOT palatalize: мир /mʲir/ not /mʲirʲ/
        const progressiveFrontVowels = new Set(['и', 'е', 'э']);
        
        for (let i = 0; i < chars.length; i++) {
          if (chars[i] !== 'р') continue;
          if (softIndices.has(i)) continue; // Already soft from Pass 1 or 2
          if (!isInStressedSyllable(i)) continue; // Must be in stressed syllable
          
          const prevChar = chars[i - 1];
          if (!prevChar || !progressiveFrontVowels.has(prevChar)) continue; // Must follow front vowel
          
          // Find what follows р (skip ь/ъ)
          let charAfterR = null;
          for (let j = i + 1; j < chars.length; j++) {
            if (chars[j] === 'ь' || chars[j] === 'ъ') continue;
            charAfterR = chars[j];
            break;
          }
          
          // Cluster requirement: р must be followed by a consonant
          if (charAfterR && this.isConsonant(charAfterR)) {
            softIndices.set(i, true); // Progressive palatalization
          }
        }
        
        return softIndices;
      },
      
      // Legacy wrapper for any code still calling the old function name
      analyzeRegressivePalatalization(word) {
        // Fallback: treat as single stressed syllable (conservative)
        return this.computeCompletePalatalizationMap(word, [word], 0);
      },
      
      // Check if consonant can regressively palatalize before another consonant (Grayson p. 209)
      canRegressivelyPalatalize(consonant, triggerConsonant) {
        consonant = consonant?.toLowerCase();
        triggerConsonant = triggerConsonant?.toLowerCase();
        
        // Always-hard consonants never palatalize
        if (this.alwaysHard.has(consonant)) return false;
        
        // л: only regressively palatalizes when doubled (лль)
        // (Grayson p. 209 rule 1)
        if (consonant === 'л') {
          return triggerConsonant === 'л'; // Only before another л
        }
        
        // р: never regressively palatalizes except when doubled (ррь)
        // (Grayson p. 209 rule 2; D&P pp. 85-87)
        // NOTE: Progressive palatalization (after front vowel in cluster) is handled separately
        if (consonant === 'р') {
          return triggerConsonant === 'р'; // Only before another р
        }
        
        // н: only before palatalized н or dental (Grayson p. 209 rule 3)
        if (consonant === 'н') {
          return triggerConsonant === 'н' || this.dentals.has(triggerConsonant);
        }
        
        // Velars (к, г, х): only before palatalized velar (Grayson p. 209 rule 4)
        if (this.velars.has(consonant)) {
          return this.velars.has(triggerConsonant);
        }
        
        // Labials (б, п, в, ф, м): only before palatalized labial (Grayson p. 209 rule 5)
        if (this.labials.has(consonant)) {
          return this.labials.has(triggerConsonant);
        }
        
        // Dentals (т, д, с, з): only before palatalized dental (Grayson p. 209)
        // Dentals do NOT palatalize before labials (e.g., д before в in дверь stays hard)
        if (this.dentals.has(consonant)) {
          return this.dentals.has(triggerConsonant);
        }
        
        // Others: can palatalize more freely
        return true;
      },
      
      // Check if a consonant at given index is palatalized (considering regressive)
      isConsonantPalatalized(word, index, softIndices) {
        if (softIndices && softIndices.has(index)) {
          return true;
        }
        const chars = [...word.toLowerCase()];
        return this.isPalatalized(chars[index], chars[index + 1]);
      },
      
      // Protected suffixes that must stay together as syllable units (Grayson p. 237-238)
      // Format: { cyrillic: 'suffix', placeholder: '◊' }
      // The placeholder replaces consonants, keeping the vowel visible for syllable counting
      protectedSuffixes: [
        { suffix: 'ться', consonants: 'ться', placeholder: '◊', vowelKept: 'я' }, // купаться
        { suffix: 'тся', consonants: 'тс', placeholder: '◊', vowelKept: 'я' },   // боится
      ],
      
      // Main syllabification entry point
      // Wraps the open-syllable logic with morphological exception handling
      syllabify(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // STEP 1: Check for protected suffixes and replace with placeholders
        let processedWord = cleanWord;
        let activeProtection = null;
        
        for (const protection of this.protectedSuffixes) {
          if (cleanWord.endsWith(protection.suffix)) {
            // Replace the consonant portion with placeholder, keep vowel
            // e.g., "боится" → "бои◊я" (тс replaced with ◊, я kept)
            const suffixStart = cleanWord.length - protection.suffix.length;
            const beforeSuffix = cleanWord.slice(0, suffixStart);
            processedWord = beforeSuffix + protection.placeholder + protection.vowelKept;
            activeProtection = { ...protection, startIndex: suffixStart };
            break; // Only one suffix per word
          }
        }
        
        // STEP 2: Apply open-syllable rules to processed word
        const rawSyllables = this.syllabifyOpenSyllable(processedWord);
        
        // STEP 3: Restore protected suffix in final syllable
        if (activeProtection) {
          const lastIdx = rawSyllables.length - 1;
          // Replace placeholder+vowel back to original suffix
          rawSyllables[lastIdx] = rawSyllables[lastIdx].replace(
            activeProtection.placeholder + activeProtection.vowelKept,
            activeProtection.suffix
          );
        }
        
        return rawSyllables;
      },
      
      // Core open-syllable logic (Maximum Onset Principle)
      // This is the original syllabify, now renamed and called by the wrapper
      syllabifyOpenSyllable(word) {
        const chars = [...word];
        const syllables = [];
        let current = '';
        
        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];
          current += char;
          
          if (this.isVowel(char)) {
            let j = i + 1;
            // Advance through consonants AND soft/hard signs (they attach to consonants)
            while (j < chars.length && !this.isVowel(chars[j])) {
              j++;
            }
            
            // If we've reached the end of the word, attach all remaining chars to this syllable
            if (j >= chars.length) {
              current += chars.slice(i + 1).join('');
              syllables.push(current);
              break;
            }
            
            // We have consonants between this vowel and the next
            const cluster = chars.slice(i + 1, j);
            if (cluster.length === 0) {
              // No consonants between vowels (e.g., two vowels in a row)
              syllables.push(current);
              current = '';
            } else if (cluster.length === 1) {
              // Single consonant goes with next syllable (CV.CV pattern)
              syllables.push(current);
              current = '';
            } else {
              // Multiple consonants: keep last one for next syllable, rest stay with current
              // But soft/hard signs always stay with preceding consonant
              let splitPoint = cluster.length - 1;
              // If the last char is a soft/hard sign, move split point back
              while (splitPoint > 0 && (cluster[splitPoint] === 'ь' || cluster[splitPoint] === 'ъ')) {
                splitPoint--;
              }
              // Keep at least one consonant for the next syllable (unless it's all signs)
              if (splitPoint === cluster.length - 1) {
                splitPoint = Math.max(1, cluster.length - 1);
              }
              current += cluster.slice(0, splitPoint).join('');
              syllables.push(current);
              current = '';
              i = i + splitPoint;
            }
          }
        }
        
        if (current && !syllables.includes(current)) {
          syllables.push(current);
        }
        
        return syllables.length > 0 ? syllables : [word];
      },
      
      countVowels(word) {
        return [...word.toLowerCase()].filter(c => this.isVowel(c)).length;
      },
      
      // Detect if word contains ё and return its syllable index
      // ё always carries stress in Russian — this is non-negotiable
      findYoSyllable(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        const syllables = this.syllabify(cleanWord);
        for (let i = 0; i < syllables.length; i++) {
          if (syllables[i].includes('ё')) {
            return i;
          }
        }
        return -1; // No ё found
      },
      
      // Check if word contains ё (for UI decisions)
      hasYo(word) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        return cleanWord.includes('ё');
      },
      
      getSyllablePosition(index, stressIndex, total) {
        if (index === stressIndex) return 'stressed';
        if (stressIndex === -1) return 'unstressed';
        if (index === stressIndex - 1) return 'pretonic';
        // Grayson p. 266, fn. 306: immediate post-tonic а stays /ɑ/ to distinguish from о
        if (index === stressIndex + 1) return 'posttonic-immediate';
        return 'remote';
      },
      
      // Transcribe vowel based on position and palatal context
      // Grayson Ch. 3: Fronting to [a] or [e] requires INTERPALATAL position
      // (sandwiched between two palatalized consonants or followed by й)
      transcribeVowel(vowel, position, isPrecededByPalatalized, isFollowedByPalatalized, precedingConsonant) {
        vowel = vowel.toLowerCase();
        
        // Interpalatal = preceded by soft C AND followed by soft C (Grayson p. 207)
        // Note: For word-initial position, the /j/ glide counts as "preceded by soft"
        const isInterpalatal = isPrecededByPalatalized && isFollowedByPalatalized;
        
        // Always-hard consonants ж, ш, ц (Grayson p. 102-103)
        const isAfterAlwaysHard = ['ж', 'ш', 'ц'].includes(precedingConsonant);
        
        if (position === 'stressed') {
          // а → [a] only when interpalatal (Grayson p. 104)
          if (vowel === 'а') return isInterpalatal ? 'a' : 'ɑ';
          if (vowel === 'о') return 'o';
          
          // RULE B: -е- requires INTERPALATAL for [e] (Grayson p. 207)
          // "е and its cluster /jɛ/ shift to [e]/[je] when interpalatal 
          // (between two palatalized consonants or palatalizing agents)"
          if (vowel === 'е') return isInterpalatal ? 'e' : 'ɛ';
          
          if (vowel === 'ё') return 'o';
          // и after ж/ш/ц → ɨ (Grayson p. 93-95)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у') return 'u';
          if (vowel === 'ю') return 'u';
          // я → [a] only when interpalatal (Grayson p. 104)
          if (vowel === 'я') return isInterpalatal ? 'a' : 'ɑ';
          
          // RULE A: -э- only checks FOLLOWING consonant for [e] (Grayson p. 207)
          // "-э- shifts from /ɛ/ to [e] when followed by a palatalized consonant"
          // (Note: -э- cannot follow soft consonants orthographically)
          if (vowel === 'э') return isFollowedByPalatalized ? 'e' : 'ɛ';
        } else if (position === 'pretonic') {
          if (vowel === 'а' || vowel === 'о') return 'ɑ';
          // е after ж/ш/ц → ɨ (Grayson p. 102-103)
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'я' || vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          // и after ж/ш/ц → ɨ (Grayson p. 102)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        } else if (position === 'posttonic-immediate') {
          // Grayson p. 266, footnote 306: "This guide suggests that -а- in 
          // the immediate-post-stress position be read as /ɑ/ in order to 
          // aurally differentiate from words that have the letter -о- in 
          // the same position."
          // Example: блюдa /ˈblʲu dɑ/ (platters) vs блюдо /ˈblʲu dʌ/ (a platter)
          if (vowel === 'а') return 'ɑ';
          if (vowel === 'я') return 'ɑ';  // я follows а pattern (underlying /ja/)
          if (vowel === 'о') return 'ʌ';
          // Other vowels follow remote patterns
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        } else {
          // Remote unstressed positions (Grayson p. 109-112)
          if (vowel === 'а') return 'ʌ';
          if (vowel === 'о') return 'ʌ';
          // е after ж/ш/ц → ɨ (Grayson p. 102-103)
          // Interpalatal: /ɪ/ fronts to /i/ (Grayson p. 125, Ch. 3.7)
          if (vowel === 'е') return isAfterAlwaysHard ? 'ɨ' : (isInterpalatal ? 'i' : 'ɪ');
          if (vowel === 'я' || vowel === 'э') return isInterpalatal ? 'i' : 'ɪ';
          // и after ж/ш/ц → ɨ (Grayson p. 102)
          if (vowel === 'и') return isAfterAlwaysHard ? 'ɨ' : 'i';
          if (vowel === 'ы') return 'ɨ';
          if (vowel === 'у' || vowel === 'ю') return 'u';
        }
        
        return vowel;
      },
      
      transcribeConsonant(consonant, nextChar, prevChar, isStressedSyllable, isSoftFromRegressive = false, nextCharInWord = null) {
        consonant = consonant.toLowerCase();
        prevChar = prevChar?.toLowerCase();
        // Combine direct palatalization with regressive palatalization analysis
        const softDirect = this.isPalatalized(consonant, nextChar);
        const soft = softDirect || isSoftFromRegressive;
        const base = this.inventory.consonants[consonant] || consonant;
        
        // Progressive palatalization of р (Grayson p. 209, footnote 277)
        // "Do not regressively palatalize /r/ within a cluster except... 
        // directly following -и-, -е-, or -э- (in the stressed syllable only)"
        // Examples: смерть /sʲmʲerʲtʲ/, терпеть /tʲirʲˈpʲetʲ/, кирпич /kʲirʲˈpʲitʃʲ/
        // NOTE: This applies only when р is IN A CLUSTER (followed by consonant)
        // Word-final р after front vowel does NOT palatalize: мир /mʲir/ not /mʲirʲ/
        // v5.11.21: Use nextCharInWord to check across syllable boundaries
        if (consonant === 'р' && isStressedSyllable) {
          const frontVowels = ['и', 'е', 'э'];
          // Check both syllable-local nextChar AND word-level nextCharInWord
          const effectiveNextChar = nextChar || nextCharInWord;
          const nextIsConsonant = effectiveNextChar && this.consonants.has(effectiveNextChar.toLowerCase());
          if (frontVowels.includes(prevChar) && nextIsConsonant) {
            return 'rʲ'; // Progressive palatalization in cluster only
          }
        }
        
        if (consonant === 'л') {
          return soft ? 'lʲ' : 'ɫ';
        }
        if (consonant === 'н' && soft) {
          return 'ɲ';
        }
        
        if (soft && !this.alwaysSoft.has(consonant)) {
          return base + 'ʲ';
        }
        
        return base;
      },
      
      // Final consonant devoicing (Grayson Ch. 4 Sec. 4, pp. 199-202)
      // "In Russian, as in German, final consonants are generally unvoiced, 
      // regardless of spelling. This does not apply to sonorants."
      voicedToVoiceless: Object.freeze({
        'b': 'p',    // б → п (p. 199-200)
        'bʲ': 'pʲ',  // бь → пь
        'v': 'f',    // в → ф (p. 200)
        'vʲ': 'fʲ',  // вь → фь
        'd': 't',    // д → т (p. 201)
        'dʲ': 'tʲ',  // дь → ть
        'ɡ': 'k',    // г → к (p. 201) — note: гь does not occur
        'z': 's',    // з → с (p. 202)
        'zʲ': 'sʲ',  // зь → сь
        'ʒ': 'ʃ'     // ж → ш (p. 202) — ж never palatalizes, so жь also → ш
      }),
      
      // Reverse mapping for voicing (voiceless → voiced)
      voicelessToVoiced: Object.freeze({
        'p': 'b',    // п → б
        'pʲ': 'bʲ',  // пь → бь
        'f': 'v',    // ф → в
        'fʲ': 'vʲ',  // фь → вь
        't': 'd',    // т → д
        'tʲ': 'dʲ',  // ть → дь
        'k': 'ɡ',    // к → г
        's': 'z',    // с → з
        'sʲ': 'zʲ',  // сь → зь
        'ʃ': 'ʒ'     // ш → ж
      }),
      
      // Sets for classification (Grayson Ch. 6 Sec. 1, pp. 213-214)
      // Sonorants: "do not influence the voicing of preceding, unvoiced consonants 
      // and are never devoiced themselves in lyric diction"
      sonorantIPA: new Set(['ɫ', 'lʲ', 'm', 'mʲ', 'n', 'nʲ', 'ɲ', 'r', 'rʲ', 'j']),
      
      // Voiced obstruents (can trigger voicing of preceding consonants)
      voicedObstruents: new Set(['b', 'bʲ', 'd', 'dʲ', 'ɡ', 'z', 'zʲ', 'ʒ']),
      
      // Voiceless obstruents (can trigger devoicing of preceding consonants)
      voicelessObstruents: new Set(['p', 'pʲ', 't', 'tʲ', 'k', 's', 'sʲ', 'ʃ', 'x', 'ts', 'tʃ', 'ʃtʃ']),
      
      // /v/ phonemes: "has no assimilative voicing influence of its own, 
      // but is influenced by most other consonants" (Grayson p. 214)
      vPhonemes: new Set(['v', 'vʲ', 'f', 'fʲ']),
      
      // Regressive voicing assimilation within words (Grayson Ch. 6 Sec. 1, pp. 214-224)
      // "The baseline approach to consonant clusters in Russian is to pronounce each 
      // consonant member in the cluster and to determine the voicing of all the 
      // consonants based upon the status of the last member of the cluster."
      applyRegressiveVoicing(ipa) {
        // Parse IPA into segments (consonants may be multi-char like tʃ, ʃtʃ, or have ʲ)
        const segments = this.parseIPASegments(ipa);
        if (segments.length < 2) return ipa;
        
        // Process clusters: find sequences of consonants
        // Note: stress marks (ˈ) can appear mid-cluster and must be preserved
        let result = [];
        let i = 0;
        
        while (i < segments.length) {
          const seg = segments[i];
          
          // If it's a vowel, just add it
          if (this.isIPAVowel(seg)) {
            result.push(seg);
            i++;
            continue;
          }
          
          // If it's a stress mark at start (before any consonant), just add it
          if (seg === 'ˈ') {
            result.push(seg);
            i++;
            continue;
          }
          
          // Found a consonant - collect the cluster (including any stress marks)
          let cluster = [seg];
          let stressPositions = []; // Track where stress marks appear in cluster
          let j = i + 1;
          while (j < segments.length && !this.isIPAVowel(segments[j])) {
            if (segments[j] === 'ˈ') {
              // Record position and skip for now (will reinsert after assimilation)
              stressPositions.push(cluster.length);
            } else {
              cluster.push(segments[j]);
            }
            j++;
          }
          
          // Apply voicing assimilation to this cluster (consonants only)
          if (cluster.length > 1) {
            cluster = this.assimilateClusterVoicing(cluster);
          }
          
          // Reinsert stress marks at their original positions
          for (let k = stressPositions.length - 1; k >= 0; k--) {
            cluster.splice(stressPositions[k], 0, 'ˈ');
          }
          
          result.push(...cluster);
          i = j;
        }
        
        return result.join('');
      },
      
      // Parse IPA string into segments (handling multi-char consonants)
      parseIPASegments(ipa) {
        const segments = [];
        let i = 0;
        
        while (i < ipa.length) {
          // Check for multi-char consonants first (longest match)
          if (ipa.slice(i, i + 3) === 'ʃtʃ') {
            segments.push('ʃtʃ');
            i += 3;
          } else if (ipa.slice(i, i + 2) === 'tʃ') {
            segments.push('tʃ');
            i += 2;
          } else if (ipa.slice(i, i + 2) === 'ts') {
            segments.push('ts');
            i += 2;
          } else if (ipa[i + 1] === 'ʲ' && ipa[i + 2] === 'ː') {
            // Consonant + palatalization + length (e.g., ʃʲː)
            segments.push(ipa.slice(i, i + 3));
            i += 3;
          } else if (ipa[i + 1] === 'ʲ') {
            // Consonant + palatalization marker
            segments.push(ipa.slice(i, i + 2));
            i += 2;
          } else if (ipa[i + 1] === 'ː') {
            // Consonant + length marker (e.g., ʃː, ʒː)
            segments.push(ipa.slice(i, i + 2));
            i += 2;
          } else {
            segments.push(ipa[i]);
            i++;
          }
        }
        
        return segments;
      },
      
      // Check if IPA segment is a vowel
      isIPAVowel(seg) {
        const ipaVowels = new Set(['ɑ', 'a', 'o', 'ɛ', 'e', 'i', 'ɪ', 'ɨ', 'u', 'ʊ', 'ʌ']);
        return ipaVowels.has(seg);
      },
      
      // Assimilate voicing within a consonant cluster (Grayson p. 214-215)
      // "the voicing of the entire cluster is that of the final member"
      assimilateClusterVoicing(cluster) {
        // Find the last non-sonorant, non-/v/ consonant - this is the "agent"
        let agentIndex = -1;
        for (let i = cluster.length - 1; i >= 0; i--) {
          const seg = cluster[i];
          if (this.sonorantIPA.has(seg)) continue;
          if (this.vPhonemes.has(seg)) continue;
          agentIndex = i;
          break;
        }
        
        // No agent found (all sonorants or /v/) - no assimilation
        if (agentIndex === -1) return cluster;
        
        const agent = cluster[agentIndex];
        const agentIsVoiced = this.voicedObstruents.has(agent);
        
        // Apply voicing/devoicing to all preceding consonants (and /v/ phonemes)
        const result = [...cluster];
        for (let i = 0; i < agentIndex; i++) {
          const seg = result[i];
          
          // Sonorants never change
          if (this.sonorantIPA.has(seg)) continue;
          
          if (agentIsVoiced) {
            // Voice the consonant if it's voiceless
            if (this.voicelessToVoiced[seg]) {
              result[i] = this.voicelessToVoiced[seg];
            }
          } else {
            // Devoice the consonant if it's voiced
            if (this.voicedToVoiceless[seg]) {
              result[i] = this.voicedToVoiceless[seg];
            }
          }
        }
        
        return result;
      },
      
      // Apply final devoicing to IPA string
      applyFinalDevoicing(ipa) {
        // Find the final consonant segment (may include palatalization marker)
        // Sonorants (ɫ, lʲ, m, mʲ, n, ɲ, r, rʲ, j) are never devoiced
        const sonorantPattern = /[ɫmnrj]ʲ?$/;
        if (sonorantPattern.test(ipa)) {
          return ipa; // Sonorants don't devoice
        }
        
        // Remove any trailing spaces for matching
        const trimmedIpa = ipa.trimEnd();
        
        // Check for voiced consonants at end and replace
        for (const [voiced, voiceless] of Object.entries(this.voicedToVoiceless)) {
          if (trimmedIpa.endsWith(voiced)) {
            return trimmedIpa.slice(0, -voiced.length) + voiceless;
          }
        }
        
        return ipa;
      },
      
      transcribe(word, stressIndex = -1, isClitic = false, procliticPosition = null) {
        const cleanWord = word.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
        
        // Check for isolated clitic — use canonical form from registry
        // (Phrase-context clitics have procliticPosition set by the caller)
        const cliticInfo = this.cliticData.get(cleanWord);
        if (cliticInfo && isClitic && !procliticPosition) {
          // Return canonical citation form for isolated clitic
          return {
            ipa: cliticInfo.canonicalIpa,
            ipaUnderlying: cliticInfo.canonicalIpa,
            syllables: [{
              cyrillic: cleanWord,
              ipa: cliticInfo.canonicalIpa,
              isStressed: false
            }],
            transcriptionLog: [{
              cyrillic: cleanWord,
              ipa: cliticInfo.canonicalIpa,
              source: 'isolated-clitic',
              note: 'Canonical citation form — contextual pronunciation varies'
            }],
            source: 'isolated-clitic'
          };
        }
        
        const syllables = this.syllabify(cleanWord);
        const vowelCount = this.countVowels(cleanWord);
        
        // Find special clusters (e.g., сч → /ʃʲʃʲ/)
        const specialClusters = this.findSpecialClusters(cleanWord);
        
        // ё always carries stress — override any other stress assignment
        const yoSyllable = this.findYoSyllable(cleanWord);
        let effectiveStress;
        if (yoSyllable !== -1) {
          // ё found: stress is locked to that syllable
          effectiveStress = yoSyllable;
        } else if (vowelCount === 1 && !isClitic) {
          // Monosyllable (non-clitic): stress on only syllable
          effectiveStress = 0;
        } else {
          // Normal case: use provided stress index
          effectiveStress = stressIndex;
        }
        
        // Compute COMPLETE palatalization map for the whole word (Grayson p. 207-209)
        // This includes regressive AND progressive palatalization (for р after front vowels)
        // Architecture: single source of truth computed BEFORE any transcription
        const softIndices = this.computeCompletePalatalizationMap(cleanWord, syllables, effectiveStress);
        
        // Build a map of character position in full word to track palatalization
        let charIndexInWord = 0;
        
        let ipa = '';
        let syllableData = [];
        let transcriptionLog = [];  // Phase 1: Phoneme Ribbon data
        
        syllables.forEach((syl, sylIdx) => {
          // For proclitics with host-stress-aware reduction, use procliticPosition
          // This overrides the default 'unstressed' position for accurate vowel reduction
          let position;
          if (isClitic && procliticPosition) {
            position = procliticPosition;  // 'pretonic' or 'remote' based on host word stress
          } else {
            position = this.getSyllablePosition(sylIdx, effectiveStress, syllables.length);
          }
          let sylIpa = '';
          const chars = [...syl];
          
          // v5.11.45: Always add stress mark for stressed syllables
          // Previously only polysyllables got marks in underlying IPA, causing
          // monosyllables to lose their mark after cross-word assimilation
          if (position === 'stressed') {
            sylIpa += 'ˈ';
          }
          
          for (let i = 0; i < chars.length; i++) {
            const char = chars[i];
            const nextChar = chars[i + 1];
            const globalIndex = charIndexInWord + i; // Position in full word
            
            // Log soft/hard signs before skipping
            if (char === 'ь' || char === 'ъ') {
              transcriptionLog.push({
                char: char,
                ipa: '',  // Signs produce no sound of their own (v5.11.1)
                features: {
                  type: 'sign',
                  signType: char === 'ь' ? 'soft' : 'hard',
                  silent: true  // Mark as silent for ribbon display
                },
                syllableIndex: sylIdx,
                position: globalIndex
              });
              continue;
            }
            
            // Check if this character is part of a special cluster
            const clusterInfo = specialClusters.find(c => 
              globalIndex >= c.startIndex && globalIndex <= c.endIndex
            );
            
            if (clusterInfo) {
              // First char of cluster outputs the IPA and logs the cluster
              if (globalIndex === clusterInfo.startIndex) {
                sylIpa += clusterInfo.ipa;
                
                transcriptionLog.push({
                  char: clusterInfo.cluster,
                  ipa: clusterInfo.ipa,
                  features: {
                    type: 'cluster',
                    clusterChars: clusterInfo.cluster.length
                  },
                  syllableIndex: sylIdx,
                  position: globalIndex
                });
              }
              continue;
            }
            
            if (this.isVowel(char)) {
              const prevCharInSyllable = chars[i - 1];
              // Use word-level previous char for j-glide and interpalatal detection
              const prevCharInWord = cleanWord[globalIndex - 1];
              
              // Standard j-glide: iotated vowels at word-initial or after vowel/ъ/ь
              let needsGlide = ['е', 'ё', 'ю', 'я'].includes(char) && 
                               (globalIndex === 0 || this.isVowel(prevCharInWord) || prevCharInWord === 'ь' || prevCharInWord === 'ъ');
              
              // EXCEPTION: -ии suffix (Grayson p. 89, 120)
              // The suffix -ии is pronounced /i ji/ for singing clarity.
              // This is an exception to the rule that и after vowels doesn't get a j-glide.
              // Example: странствии → /ˈstrɑnst vʲi ji/, в здании → /v ˈzdɑ ɲi ji/
              const isIiSuffix = char === 'и' && prevCharInWord === 'и' && globalIndex === cleanWord.length - 1;
              if (isIiSuffix) {
                needsGlide = true;
              }
              
              // Add j-glide to IPA and log it
              if (needsGlide) {
                sylIpa += 'j';
                
                // Determine j-glide source for ribbon display
                let jGlideSource = 'iotated';  // default: iotated vowel
                if (isIiSuffix) {
                  jGlideSource = 'ii-suffix';
                } else if (prevCharInWord === 'ь') {
                  jGlideSource = 'after-sign';
                } else if (prevCharInWord === 'ъ') {
                  jGlideSource = 'after-sign';
                } else if (this.isVowel(prevCharInWord)) {
                  jGlideSource = 'after-vowel';
                } else if (globalIndex === 0) {
                  jGlideSource = 'word-initial';
                }
                
                // Log j-glide for Phoneme Ribbon
                transcriptionLog.push({
                  char: '',  // No Cyrillic character - it's implicit
                  ipa: 'j',
                  features: {
                    type: 'glide',
                    source: jGlideSource,
                    triggeredBy: char  // The vowel that triggered the glide
                  },
                  syllableIndex: sylIdx,
                  position: globalIndex - 0.5  // Position between prev and current char
                });
              }
              
              // Initialize vowel tracking
              let vowelIpa = null;
              let vowelFeatures = {
                type: 'vowel',
                position: position,
                interpalatal: false,
                afterHard: false,
                exception: null
              };
              
              // Check for exception word vowel override
              const vowelOverride = this.getVowelOverride(cleanWord, globalIndex);
              if (vowelOverride !== null) {
                vowelIpa = vowelOverride;
                vowelFeatures.exception = 'word-override';
              }
              
              // Check for -ая/-яя suffix exception (Grayson p. 124)
              // These endings are ALWAYS /ɑjɑ/, never reduced
              if (vowelIpa === null && this.isAyaSuffixVowel(cleanWord, globalIndex)) {
                vowelIpa = 'ɑ';
                vowelFeatures.exception = 'aya-suffix';
              }
              
              // Check for Old Muscovite velar adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
              // When profile adjectival='stage': и → [ɨ] after hard velar
              const profileParams = ProfileController.getParams();
              const velarAdj = this.checkVelarAdjectival(cleanWord, globalIndex);
              if (vowelIpa === null && velarAdj.isVelarAdjectival && velarAdj.charRole === 'i' && profileParams.adjectival === 'stage') {
                vowelIpa = 'ɨ';
                vowelFeatures.exception = 'velar-adjectival';
              }
              
              // Normal vowel transcription (if no exception applied)
              if (vowelIpa === null) {
                // Check preceding consonant palatalization (using regressive analysis)
                // Use word-level previous char, not within-syllable
                const prevConsonant = this.isConsonant(prevCharInWord) ? prevCharInWord : null;
                const prevGlobalIndex = globalIndex - 1;
                
                // Check if preceded by a special cluster (for interpalatal)
                const prevCluster = specialClusters.find(c => c.endIndex === prevGlobalIndex);
                
                // Iotated vowels at word-initial or after vowel/ъ/ь produce /j/ glide
                // The /j/ glide counts as a palatalizing agent (Grayson p. 125)
                const iotatedVowels = ['е', 'ё', 'ю', 'я'];
                const isIotated = iotatedVowels.includes(char);
                const isWordInitialOrAfterVowel = globalIndex === 0 || 
                  this.isVowel(prevCharInWord) || prevCharInWord === 'ъ' || prevCharInWord === 'ь';
                const precededByJGlide = isIotated && isWordInitialOrAfterVowel;
                
                const isPrecededByPal = prevCluster ?
                  prevCluster.ipa.includes('ʲ') :
                  (prevConsonant ? 
                    (softIndices.has(prevGlobalIndex) || this.isPalatalized(prevConsonant, char)) : 
                    precededByJGlide);  // Word-initial iotated → preceded by /j/
                
                // Check following consonant palatalization (Grayson p. 104, 106: interpalatal requires BOTH)
                // Find the next consonant after this vowel - must search in FULL WORD, not just current syllable
                let followingConsonant = null;
                let followingConsonantGlobalIndex = -1;
                let charAfterFollowingC = null;
                const wordChars = [...cleanWord];
                for (let j = globalIndex + 1; j < wordChars.length; j++) {
                  if (wordChars[j] === 'ь' || wordChars[j] === 'ъ') continue;
                  if (this.isConsonant(wordChars[j])) {
                    followingConsonant = wordChars[j];
                    followingConsonantGlobalIndex = j;
                    charAfterFollowingC = wordChars[j + 1];
                    break;
                  }
                  if (this.isVowel(wordChars[j])) break; // Hit another vowel first
                }
                
                // Check if the following consonant is part of a special cluster
                // If so, check the cluster's IPA for palatalization, not the Cyrillic letter
                const followingCluster = followingConsonant ? 
                  specialClusters.find(c => 
                    followingConsonantGlobalIndex >= c.startIndex && 
                    followingConsonantGlobalIndex <= c.endIndex
                  ) : null;
                
                let isFollowedByPal = false;
                if (followingConsonant === 'й') {
                  // й always counts as palatalized
                  isFollowedByPal = true;
                } else if (followingCluster) {
                  // Check the cluster's IPA output for palatalization
                  // e.g., чн→/ʃn/ starts with /ʃ/ which is hard (no ʲ at start)
                  // But сч→/ʃʲʃʲ/ starts with /ʃʲ/ which is soft
                  const clusterIPA = followingCluster.ipa;
                  // The first sound in the cluster is what follows the vowel
                  isFollowedByPal = clusterIPA.length > 1 && clusterIPA[1] === 'ʲ';
                } else if (followingConsonant) {
                  // Normal case: check the Cyrillic consonant
                  isFollowedByPal = softIndices.has(followingConsonantGlobalIndex) || 
                    this.isPalatalized(followingConsonant, charAfterFollowingC);
                } else {
                  // No following consonant found - check if next vowel is iotated
                  // Iotated vowels (е, ё, ю, я) produce /j/ glide which is a palatalizing agent
                  // This handles cases like её where /j/-[vowel]-/j/ is interpalatal
                  const iotatedVowels = ['е', 'ё', 'ю', 'я'];
                  for (let j = globalIndex + 1; j < wordChars.length; j++) {
                    if (wordChars[j] === 'ь' || wordChars[j] === 'ъ') continue;
                    if (this.isVowel(wordChars[j])) {
                      isFollowedByPal = iotatedVowels.includes(wordChars[j]);
                      break;
                    }
                    if (this.isConsonant(wordChars[j])) break;
                  }
                }
                
                // Capture interpalatal and afterHard features
                const prevConsonantForFeatures = this.isConsonant(prevCharInWord) ? prevCharInWord : null;
                vowelFeatures.interpalatal = isPrecededByPal && isFollowedByPal;
                vowelFeatures.afterHard = ['ж', 'ш', 'ц'].includes(prevConsonantForFeatures);
                
                vowelIpa = this.transcribeVowel(char, position, isPrecededByPal, isFollowedByPal, prevConsonantForFeatures);
              }
              
              sylIpa += vowelIpa;
              
              // Populate transcriptionLog for vowel
              transcriptionLog.push({
                char: char,
                ipa: vowelIpa,
                features: vowelFeatures,
                syllableIndex: sylIdx,
                position: globalIndex
              });
            } else if (this.isConsonant(char)) {
              const prevChar = chars[i - 1];
              const nextCharInWord = cleanWord[globalIndex + 1]; // For cross-syllable checks
              const isStressedSyl = (position === 'stressed');
              // Pass regressive palatalization info
              let isSoftFromRegressive = softIndices.has(globalIndex);
              
              // Check for Old Muscovite velar adjectival suffix -кий/-гий/-хий (Grayson p. 301-303)
              // When profile adjectival='stage': velar stays HARD (not palatalized)
              const profileParams = ProfileController.getParams();
              const velarAdj = this.checkVelarAdjectival(cleanWord, globalIndex);
              
              // Check for genitive ending -ого/-его: г → /v/ (Grayson p. 243)
              const isGenitiveG = (char === 'г') && this.checkGenitiveEnding(cleanWord, globalIndex);
              
              let consonantIpa;
              if (isGenitiveG) {
                // Genitive г → /v/
                consonantIpa = 'v';
              } else if (velarAdj.isVelarAdjectival && velarAdj.charRole === 'velar' && profileParams.adjectival === 'stage') {
                // Force hard velar: output base consonant without palatalization
                consonantIpa = this.inventory.consonants[char] || char;
              } else {
                consonantIpa = this.transcribeConsonant(char, nextChar, prevChar, isStressedSyl, isSoftFromRegressive, nextCharInWord);
              }
              sylIpa += consonantIpa;
              
              // Populate transcriptionLog for consonant
              const isSoft = consonantIpa.includes('ʲ') || consonantIpa === 'ɲ';
              let softTrigger = null;
              if (isSoft) {
                // Priority: direct triggers first, then regressive
                // A consonant before a front vowel is soft because of the vowel, not regressive assimilation
                if (nextChar === 'ь') {
                  softTrigger = 'ь';
                } else if (['е', 'ё', 'ю', 'я', 'и'].includes(nextChar)) {
                  softTrigger = nextChar;
                } else if (isSoftFromRegressive) {
                  softTrigger = 'regressive';
                }
              }
              
              transcriptionLog.push({
                char: char,
                ipa: consonantIpa,
                features: {
                  type: 'consonant',
                  soft: isSoft,
                  softTrigger: softTrigger,
                  genitiveEnding: isGenitiveG
                },
                syllableIndex: sylIdx,
                position: globalIndex
              });
            }
          }
          
          charIndexInWord += syl.length;
          
          syllableData.push({
            cyrillic: syl,
            ipa: sylIpa.replace(/^ˈ/, ''),
            isStressed: position === 'stressed'
          });
          
          ipa += sylIpa;
        });
        
        // Step 2 (Grayson p. 247): Apply regressive voicing assimilation
        ipa = this.applyRegressiveVoicing(ipa);
        
        // Sync syllable IPAs with word-level assimilation (v5.10.20)
        // Cross-syllable clusters (e.g., кз in вок-зал) are only caught at word level
        // Re-split the assimilated word IPA back into syllables
        const assimilatedSegments = this.parseIPASegments(ipa.replace(/ˈ/g, ''));
        let segmentIdx = 0;
        syllableData.forEach(syl => {
          // Count how many segments this syllable originally had
          const originalSegments = this.parseIPASegments(syl.ipa);
          const segmentCount = originalSegments.length;
          
          // Extract that many segments from the assimilated word
          const newSegments = assimilatedSegments.slice(segmentIdx, segmentIdx + segmentCount);
          syl.ipa = newSegments.join('');
          segmentIdx += segmentCount;
        });
        
        // Sync transcriptionLog to match surface IPA after voicing assimilation (v5.10.20)
        // The log was built before assimilation, so consonant entries may have stale IPA
        transcriptionLog.forEach(entry => {
          if (entry.features?.type === 'consonant') {
            const originalIpa = entry.ipa;
            // Check if this consonant was devoiced
            if (this.voicedToVoiceless[originalIpa]) {
              // Look at what's in the syllable data to see if it changed
              const sylData = syllableData[entry.syllableIndex];
              if (sylData && !sylData.ipa.includes(originalIpa)) {
                // The original voiced consonant is not in the syllable anymore
                // Check if the devoiced version is there
                const devoiced = this.voicedToVoiceless[originalIpa];
                if (sylData.ipa.includes(devoiced)) {
                  entry.ipa = devoiced;
                  entry.features.voicingAssimilation = true;
                  entry.features.devoiced = true;
                }
              }
            }
            // Check if this consonant was voiced
            if (this.voicelessToVoiced[originalIpa]) {
              const sylData = syllableData[entry.syllableIndex];
              if (sylData && !sylData.ipa.includes(originalIpa)) {
                const voiced = this.voicelessToVoiced[originalIpa];
                if (sylData.ipa.includes(voiced)) {
                  entry.ipa = voiced;
                  entry.features.voicingAssimilation = true;
                  entry.features.voiced = true;
                }
              }
            }
          }
        });
        
        // Step 3-4 will be special clusters and palatalization (future phases)
        
        // Final consonant devoicing (Grayson Ch. 4 Sec. 4, pp. 199-202)
        // For clitics, devoicing is deferred to cross-word stage (boundary-dependent)
        // For standalone words, apply devoicing now
        let ipaSurface = ipa;
        if (!isClitic) {
          // Exception: бог → /box/ (Grayson p. 242) — г becomes /x/ not /k/
          // This is a Church Slavonic preservation
          if (cleanWord === 'бог' && ipa.endsWith('ɡ')) {
            ipaSurface = ipa.slice(0, -1) + 'x';
            // Update syllable data to show /x/ not /ɡ/
            const lastSyl = syllableData[syllableData.length - 1];
            if (lastSyl && lastSyl.ipa.endsWith('ɡ')) {
              lastSyl.ipa = lastSyl.ipa.slice(0, -1) + 'x';
            }
            // Update transcriptionLog for the final г
            const lastConsonantEntry = transcriptionLog.findLast(e => e.char === 'г');
            if (lastConsonantEntry) {
              lastConsonantEntry.ipa = 'x';
              lastConsonantEntry.features.bogException = true;
              lastConsonantEntry.features.finalDevoicing = false; // Not standard devoicing
            }
          } else {
            ipaSurface = this.applyFinalDevoicing(ipa);
          }
        }
        
        return { ipa: ipaSurface, ipaUnderlying: ipa, syllables: syllableData, transcriptionLog };
      },
      
      /**
       * Auto-detect boundary types for a line of words.
       * Called after initial transcription, before cross-word assimilation.
       * 
       * Rules (in priority order):
       * 1. User-set boundaries are never overwritten
       * 2. Final word → always 'hard'
       * 3. Punctuation after word → 'hard'
       * 4. Current word is proclitic → 'clitic'
       * 5. Next word is enclitic → 'clitic'
       * 6. Otherwise → 'hard' (conservative default)
       */
      autoDetectBoundaries(words) {
        const punctuationRegex = /[.,!?;:"""''–—]$/;
        
        words.forEach((word, i) => {
          // Rule 1: Preserve user-set boundaries
          if (word.boundarySource === 'user') return;
          
          const isLastWord = (i === words.length - 1);
          const cleanWord = word.cyrillic.replace(/[.,!?;:"""''–—]/g, '').toLowerCase();
          const hasPunctuation = punctuationRegex.test(word.cyrillic);
          const isProclitic = this.proclitics.has(cleanWord);
          
          // Check if next word is enclitic
          const nextWord = words[i + 1];
          const nextCleanWord = nextWord 
            ? nextWord.cyrillic.replace(/[.,!?;:"""''–—]/g, '').toLowerCase() 
            : null;
          const nextIsEnclitic = nextCleanWord && this.enclitics.has(nextCleanWord);
          
          // Apply rules in priority order
          if (isLastWord) {
            word.rightBoundary = 'hard';
            word.boundarySource = 'auto';
          } else if (hasPunctuation) {
            word.rightBoundary = 'hard';
            word.boundarySource = 'punctuation';
          } else if (isProclitic) {
            word.rightBoundary = 'clitic';
            word.boundarySource = 'auto';
          } else if (nextIsEnclitic) {
            word.rightBoundary = 'clitic';
            word.boundarySource = 'auto';
          } else {
            // Default: SOFT — assimilation happens automatically
            // User can insert barriers when music has rests
            word.rightBoundary = 'soft';
            word.boundarySource = 'auto';
          }
        });
      },
      
      // ========================================
      // CROSS-WORD BOUNDARY ASSIMILATION
      // Grayson p. 248-257
      // ========================================
      
      // Voiceless → Voiced (for cross-boundary voicing)
      crossWordVoicingMap: {
        'p': 'b', 'pʲ': 'bʲ',
        'f': 'v', 'fʲ': 'vʲ',
        't': 'd', 'tʲ': 'dʲ',
        's': 'z', 'sʲ': 'zʲ',
        'ʃ': 'ʒ',
        'k': 'ɡ', 'kʲ': 'ɡʲ',
        'x': 'ɣ', 'xʲ': 'ɣʲ',      // Cross-boundary allophone
        'ts': 'dz',                 // Cross-boundary allophone
        'tʃʲ': 'dʒʲ'                // Cross-boundary allophone
      },
      
      // Voiced → Voiceless (for cross-boundary devoicing)
      crossWordDevoicingMap: {
        'b': 'p', 'bʲ': 'pʲ',
        'v': 'f', 'vʲ': 'fʲ',
        'd': 't', 'dʲ': 'tʲ',
        'z': 's', 'zʲ': 'sʲ',
        'ʒ': 'ʃ',
        'ɡ': 'k', 'ɡʲ': 'kʲ',
        'g': 'k', 'gʲ': 'kʲ'        // Handle both ɡ and g
      },
      
      // Consonant sets for cross-word assimilation
      crossWordVoicelessSet: new Set(['p', 'pʲ', 'f', 'fʲ', 't', 'tʲ', 's', 'sʲ', 'ʃ', 'ʃʲ', 'k', 'kʲ', 'x', 'xʲ', 'ts', 'tʃʲ', 'ʃʲʃʲ']),
      crossWordVoicedObstruentSet: new Set(['b', 'bʲ', 'd', 'dʲ', 'g', 'gʲ', 'ɡ', 'ɡʲ', 'z', 'zʲ', 'ʒ', 'ʒʲ']),
      crossWordSonorantSet: new Set(['m', 'mʲ', 'n', 'nʲ', 'ɲ', 'l', 'lʲ', 'ɫ', 'r', 'rʲ', 'j']),
      crossWordVSet: new Set(['v', 'vʲ']),
      
      /**
       * Extract final consonant(s) from IPA string.
       * Returns null if word ends in vowel.
       */
      getFinalConsonant(ipa) {
        // Remove stress marks first
        const clean = ipa.replace(/[ˈˌ]/g, '');
        // Match final consonant cluster (including affricates and palatalization)
        // Order matters: try longer sequences first
        const patterns = [
          'ʃʲʃʲ', 'tʃʲ', 'dʒʲ', 'ts', 'dz',  // Affricates
          'bʲ', 'pʲ', 'vʲ', 'fʲ', 'dʲ', 'tʲ', 'gʲ', 'ɡʲ', 'kʲ', 'zʲ', 'sʲ', 'ʒʲ', 'ʃʲ', 'xʲ', 'mʲ', 'nʲ', 'lʲ', 'rʲ',  // Palatalized
          'b', 'p', 'v', 'f', 'd', 't', 'g', 'ɡ', 'k', 'z', 's', 'ʒ', 'ʃ', 'x', 'm', 'n', 'ɲ', 'l', 'ɫ', 'r', 'j'  // Plain
        ];
        
        for (const pat of patterns) {
          if (clean.endsWith(pat)) {
            return pat;
          }
        }
        return null;
      },
      
      /**
       * Extract initial consonant(s) from IPA string.
       * Returns null if word starts with vowel.
       */
      getInitialConsonant(ipa) {
        // Remove stress marks first
        const clean = ipa.replace(/[ˈˌ]/g, '');
        // Match initial consonant cluster
        const patterns = [
          'ʃʲʃʲ', 'tʃʲ', 'dʒʲ', 'ts', 'dz',
          'bʲ', 'pʲ', 'vʲ', 'fʲ', 'dʲ', 'tʲ', 'gʲ', 'ɡʲ', 'kʲ', 'zʲ', 'sʲ', 'ʒʲ', 'ʃʲ', 'xʲ', 'mʲ', 'nʲ', 'lʲ', 'rʲ',
          'b', 'p', 'v', 'f', 'd', 't', 'g', 'ɡ', 'k', 'z', 's', 'ʒ', 'ʃ', 'x', 'm', 'n', 'ɲ', 'l', 'ɫ', 'r', 'j'
        ];
        
        for (const pat of patterns) {
          if (clean.startsWith(pat)) {
            return pat;
          }
        }
        return null;
      },
      
      /**
       * Check if consonant is voiceless.
       */
      isVoicelessConsonant(c) {
        return this.crossWordVoicelessSet.has(c);
      },
      
      /**
       * Check if consonant is voiced obstruent (can trigger voicing).
       */
      isVoicedObstruent(c) {
        return this.crossWordVoicedObstruentSet.has(c);
      },
      
      /**
       * Check if consonant is sonorant (neutral for voicing).
       */
      isSonorantConsonant(c) {
        return this.crossWordSonorantSet.has(c);
      },
      
      /**
       * Check if consonant is /v/ (special: no assimilative influence per Grayson).
       */
      isVPhoneme(c) {
        return this.crossWordVSet.has(c);
      },
      
      /**
       * Apply voicing to final consonant of IPA string.
       */
      applyVoicingToFinal(ipa, finalC) {
        const voiced = this.crossWordVoicingMap[finalC];
        if (!voiced) return ipa;
        return ipa.slice(0, -finalC.length) + voiced;
      },
      
      /**
       * Apply devoicing to final consonant of IPA string.
       */
      applyDevoicingToFinal(ipa, finalC) {
        const devoiced = this.crossWordDevoicingMap[finalC];
        if (!devoiced) return ipa;
        return ipa.slice(0, -finalC.length) + devoiced;
      },
      
      /**
       * Apply cross-word voicing assimilation to a line of words.
       * Modifies word objects in place, setting ipaSurface.
       * 
       * Grayson p. 248-257:
       * - Voicing determined by RIGHTMOST consonant (regressive)
       * - Only crosses 'soft' or 'clitic' boundaries
       * - Sonorants and /v/ are neutral (don't trigger, but DO undergo)
       */
      applyCrossWordAssimilation(words) {
        // Initialize: copy ipaUnderlying to ipaSurface, set skipFinalDevoicing
        words.forEach(word => {
          word.ipaSurface = word.ipaUnderlying;
          word.skipFinalDevoicing = false;
        });
        
        // Process each boundary
        for (let i = 0; i < words.length - 1; i++) {
          const leftWord = words[i];
          const rightWord = words[i + 1];
          
          // Skip hard boundaries
          if (leftWord.rightBoundary === 'hard') continue;
          
          const leftFinal = this.getFinalConsonant(leftWord.ipaSurface);
          const rightInitial = this.getInitialConsonant(rightWord.ipaSurface);
          
          // Skip if either word lacks consonant at boundary
          if (!leftFinal || !rightInitial) continue;
          
          // Skip if right initial is sonorant or /v/ (no assimilative influence)
          if (this.isSonorantConsonant(rightInitial) || this.isVPhoneme(rightInitial)) continue;
          
          // SIBILANT MERGERS (Grayson pp. 235-236)
          // с/з + ш → /ʃː/, с/з + ж → /ʒː/
          // These take priority over voicing assimilation (complete merger, not just voicing change)
          const sibilantMergers = {
            's':  { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'z':  { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'sʲ': { 'ʃ': 'ʃː', 'ʒ': 'ʒː' },
            'zʲ': { 'ʃ': 'ʃː', 'ʒ': 'ʒː' }
          };
          
          if (sibilantMergers[leftFinal]?.[rightInitial]) {
            // Complete merger: delete left final, geminate right initial
            // Example: с шумом → /ʃːumʌm/ (not /s ʃumʌm/)
            const geminate = sibilantMergers[leftFinal][rightInitial];
            leftWord.ipaSurface = leftWord.ipaSurface.slice(0, -leftFinal.length);
            
            // Handle stress marks: getInitialConsonant strips stress marks before matching,
            // but ipaSurface may start with ˈ or ˌ. Preserve stress position.
            const rightSurface = rightWord.ipaSurface;
            const stressMatch = rightSurface.match(/^[ˈˌ]+/);
            const stressPrefix = stressMatch ? stressMatch[0] : '';
            const afterStress = rightSurface.slice(stressPrefix.length);
            const afterConsonant = afterStress.slice(rightInitial.length);
            rightWord.ipaSurface = stressPrefix + geminate + afterConsonant;
            
            leftWord.skipFinalDevoicing = true;
            continue; // Skip voicing assimilation - merger already handled
          }
          
          // Determine assimilation direction
          if (this.isVoicedObstruent(rightInitial) && this.isVoicelessConsonant(leftFinal)) {
            // Voice the left final: слух был → sɫuɣ bɨɫ
            leftWord.ipaSurface = this.applyVoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;
          } else if (this.isVoicelessConsonant(rightInitial) && this.isVoicedObstruent(leftFinal)) {
            // Devoice the left final: друг там → druk tam
            leftWord.ipaSurface = this.applyDevoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;  // Already handled
          } else if (this.isVoicelessConsonant(rightInitial) && this.isVPhoneme(leftFinal)) {
            // Special case: /v/ devoices before voiceless consonants (в шутку → f ʃutku)
            // Grayson: /v/ doesn't TRIGGER voicing, but DOES UNDERGO devoicing
            leftWord.ipaSurface = this.applyDevoicingToFinal(leftWord.ipaSurface, leftFinal);
            leftWord.skipFinalDevoicing = true;
          }
        }
        
        // Apply final devoicing to words that didn't undergo cross-word assimilation
        words.forEach((word, i) => {
          const isLastWord = (i === words.length - 1);
          const hasHardBoundary = (word.rightBoundary === 'hard');
          
          if ((isLastWord || hasHardBoundary) && !word.skipFinalDevoicing) {
            word.ipaSurface = this.applyFinalDevoicing(word.ipaSurface);
          }
        });
      }
    };
    
    // Initialize derived clitic Sets from cliticData (DRY - single source of truth)
    GraysonEngine.proclitics = new Set(
      [...GraysonEngine.cliticData.entries()]
        .filter(([_, d]) => d.type === 'proclitic')
        .map(([k, _]) => k)
    );
    GraysonEngine.enclitics = new Set(
      [...GraysonEngine.cliticData.entries()]
        .filter(([_, d]) => d.type === 'enclitic')
        .map(([k, _]) => k)
    );

    /* ========================================
       OCR MODULE - Russian Text Recognition
       Lazy-loads Tesseract.js for image-to-text
       ======================================== */
    const OCRModule = {
      // Configuration
      TESSERACT_VERSION: '5',
      CDN_PRIMARY: 'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js',
      CDN_FALLBACK: 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js',
      INIT_TIMEOUT: 60000, // OCR can be slow
      MAX_IMAGE_WIDTH: 1200,
      CONFIDENCE_SKIP: 40,
      CONFIDENCE_DUBIOUS: 80,
      
      // State
      isLoaded: false,
      isProcessing: false,
      
      // Callbacks
      _onProgress: null,
      _onError: null,
      
      /**
       * Check if OCR is supported in this browser
       */
      isSupported() {
        return !!(
          window.Worker &&
          window.Blob &&
          window.URL &&
          window.FileReader &&
          HTMLCanvasElement.prototype.toBlob
        );
      },
      
      /**
       * Load external script with promise
       */
      loadScript(url) {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = url;
          script.async = true;
          script.onload = resolve;
          script.onerror = () => reject(new Error(`Failed to load: ${url}`));
          document.head.appendChild(script);
        });
      },
      
      /**
       * Initialize - just load the Tesseract.js library
       */
      async init() {
        if (this.isLoaded) return true;
        if (!this.isSupported()) {
          this._onError?.('OCR not supported in this browser');
          return false;
        }
        
        try {
          // Load Tesseract.js library with fallback
          if (!window.Tesseract) {
            console.log('Loading Tesseract.js...');
            try {
              await this.loadScript(this.CDN_PRIMARY);
              console.log('Tesseract.js loaded from primary CDN');
            } catch (e) {
              console.warn('Primary CDN failed, trying fallback...');
              await this.loadScript(this.CDN_FALLBACK);
              console.log('Tesseract.js loaded from fallback CDN');
            }
          }
          
          this.isLoaded = true;
          console.log('OCR module ready');
          return true;
        } catch (err) {
          this.isLoaded = false;
          this._onError?.('OCR unavailable. Please type or paste text.');
          console.error('OCR init failed:', err);
          return false;
        }
      },
      
      /**
       * Resize image to max width while preserving aspect ratio
       */
      async resizeImage(file) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const url = URL.createObjectURL(file);
          
          img.onload = () => {
            URL.revokeObjectURL(url); // Free memory immediately
            
            let { width, height } = img;
            
            // Only downscale, never upscale
            if (width > this.MAX_IMAGE_WIDTH) {
              const ratio = this.MAX_IMAGE_WIDTH / width;
              width = this.MAX_IMAGE_WIDTH;
              height = Math.round(height * ratio);
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            resolve(canvas);
          };
          
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
          };
          
          img.src = url;
        });
      },
      
      /**
       * Preprocess canvas for better OCR (grayscale + contrast)
       */
      preprocessCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Convert to grayscale and boost contrast
        for (let i = 0; i < data.length; i += 4) {
          // Grayscale using luminance formula
          const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
          
          // Simple contrast boost (stretch to 0-255)
          const contrast = Math.min(255, Math.max(0, (gray - 128) * 1.5 + 128));
          
          data[i] = data[i + 1] = data[i + 2] = contrast;
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
      },
      
      /**
       * Fix common OCR errors and filter non-Russian content
       */
      cleanRussianText(text) {
        if (!text) return '';
        
        // Helper: calculate Cyrillic density of a string (0-1)
        const cyrillicDensity = (str) => {
          const letters = str.match(/[a-zA-Zа-яА-ЯёЁ]/g) || [];
          if (letters.length === 0) return 0;
          const cyrillic = str.match(/[а-яА-ЯёЁ]/g) || [];
          return cyrillic.length / letters.length;
        };
        
        // Helper: detect garbage patterns (garbled English→Cyrillic)
        const isGarbage = (str) => {
          // Contains $ or multiple punctuation mixed with letters
          if (/\$/.test(str)) return true;
          if (/[!?]{2,}/.test(str)) return true;
          // Parentheses with mostly non-Cyrillic inside
          if (/\([^)]*\)/.test(str)) {
            const parenContent = str.match(/\(([^)]*)\)/)?.[1] || '';
            if (cyrillicDensity(parenContent) < 0.3) return true;
          }
          // Backslash (common OCR error)
          if (/\\/.test(str)) return true;
          return false;
        };
        
        let result = text;
        
        // Filter lines: keep only those with >50% Cyrillic letters
        result = result.split('\n').filter(line => {
          const trimmed = line.trim();
          if (!trimmed) return false;
          
          // Skip garbage patterns
          if (isGarbage(trimmed)) {
            console.log('OCR filter: removing garbage line:', trimmed);
            return false;
          }
          
          // Check Cyrillic density
          const density = cyrillicDensity(trimmed);
          if (density < 0.5) {
            console.log('OCR filter: removing low-density line:', trimmed, `(${(density*100).toFixed(0)}%)`);
            return false;
          }
          
          return true;
        }).join('\n');
        
        // Latin→Cyrillic fixes (only between Cyrillic chars)
        const latinToCyrillic = [
          [/(?<=[а-яА-ЯёЁ])3(?=[а-яА-ЯёЁ])/g, 'з'],
          [/(?<=[а-яА-ЯёЁ])e(?=[а-яА-ЯёЁ])/gi, 'е'],
          [/(?<=[а-яА-ЯёЁ])c(?=[а-яА-ЯёЁ])/gi, 'с'],
          [/(?<=[а-яА-ЯёЁ])o(?=[а-яА-ЯёЁ])/gi, 'о'],
          [/(?<=[а-яА-ЯёЁ])p(?=[а-яА-ЯёЁ])/gi, 'р'],
          [/(?<=[а-яА-ЯёЁ])x(?=[а-яА-ЯёЁ])/gi, 'х'],
          [/(?<=[а-яА-ЯёЁ])a(?=[а-яА-ЯёЁ])/gi, 'а'],
          [/(?<=[а-яА-ЯёЁ])y(?=[а-яА-ЯёЁ])/gi, 'у'],
          [/(?<=[а-яА-ЯёЁ])H(?=[а-яА-ЯёЁ])/g, 'Н'],
          [/(?<=[а-яА-ЯёЁ])B(?=[а-яА-ЯёЁ])/g, 'В'],
          [/(?<=[а-яА-ЯёЁ])K(?=[а-яА-ЯёЁ])/g, 'К'],
          [/(?<=[а-яА-ЯёЁ])M(?=[а-яА-ЯёЁ])/g, 'М'],
        ];
        
        for (const [pattern, replacement] of latinToCyrillic) {
          result = result.replace(pattern, replacement);
        }
        
        // Filter out garbage words within lines
        result = result.split('\n').map(line => {
          return line.split(/\s+/).filter(word => {
            // Keep if word contains at least one Cyrillic letter
            if (/[а-яА-ЯёЁ]/.test(word)) return true;
            // Filter out pure numbers (page numbers like "219")
            if (/^\d+$/.test(word)) return false;
            // Filter out single non-Cyrillic characters
            if (word.length === 1 && !/[а-яА-ЯёЁ]/.test(word)) return false;
            // Keep punctuation
            if (/^[.,!?;:\-—–]+$/.test(word)) return true;
            return false;
          }).join(' ');
        }).filter(line => line.trim()).join('\n');
        
        // Structural cleanup
        result = result
          .replace(/[ \t]+/g, ' ')           // Collapse spaces
          .replace(/\n{3,}/g, '\n\n')        // Max 2 newlines
          .replace(/^\s+|\s+$/gm, '');       // Trim lines
        
        return result;
      },
      
      /**
       * Main entry point: process image file → Russian text
       * Uses Tesseract.recognize() which handles worker lifecycle internally
       */
      async processImage(file, onProgress) {
        if (this.isProcessing) {
          console.warn('OCR already processing');
          return null;
        }
        
        if (!this.isLoaded) {
          const loaded = await this.init();
          if (!loaded) {
            throw new Error('OCR initialization failed');
          }
        }
        
        this.isProcessing = true;
        
        try {
          // Step 1: Resize image
          onProgress?.('processing', 0);
          console.log('Resizing image...');
          const canvas = await this.resizeImage(file);
          
          // Step 2: Preprocess for better recognition
          onProgress?.('processing', 0.1);
          console.log('Preprocessing image...');
          this.preprocessCanvas(canvas);
          
          // Step 3: Run Tesseract using simple recognize() API
          // Use rus+eng to handle mixed content (headers, metadata)
          // Then filter to keep only Cyrillic-dominant lines
          onProgress?.('recognizing text', 0.2);
          console.log('Running OCR recognition (rus+eng)...');
          
          const result = await Tesseract.recognize(canvas, 'rus+eng', {
            logger: m => {
              console.log('Tesseract:', m.status, m.progress);
              if (m.status) {
                onProgress?.(m.status, m.progress);
              }
            }
          });
          
          // Step 4: Use full text (preserves line structure) instead of rebuilding from words
          onProgress?.('cleaning', 0.9);
          console.log('Processing results...');
          
          // Use data.text which preserves line breaks and layout
          let text = result.data.text || '';
          
          // Step 5: Clean up the text
          text = this.cleanRussianText(text);
          
          // Validate we got Cyrillic content
          if (!/[а-яА-ЯёЁ]{3,}/.test(text)) {
            throw new Error('No Cyrillic text found in image');
          }
          
          console.log('OCR complete, extracted', text.length, 'characters');
          return text;
          
        } finally {
          this.isProcessing = false;
        }
      },
      
      /**
       * Set error callback
       */
      onError(callback) {
        this._onError = callback;
      }
    };

    /* ========================================
       RULE REGISTRY - Phoneme Ribbon Blurbs
       Maps transcription features → educational blurbs
       ======================================== */
    const RuleRegistry = {
      // Blurb data - keyed by "IPA:rule:char"
      // Full 85 entries from PHONEME_BLURBS_DRAFT.md
      blurbs: {
        // ========================================
        // SECTION 1: VOWELS — STRESSED (Entries 1–10)
        // ========================================
        
        // Entry 1 | Dark-a
        'ɑ:stressed:а': { 
          blurb: { 
            en: 'The Russian phoneme notated /ɑ/ ("dark-a" or "back-a") is pronounced further back in the mouth than the "bright-a" /a/ of languages like Italian or Spanish. Depending on your accent, think of the vowel in "father" (British RP) or "cot/caught" (merged North American). Grayson recommends a slightly more forward articulation for singability; always listen to your teacher or coach.',
            fr: 'Le phonème russe noté /ɑ/ (a-sombre ou a-postérieur) se prononce plus en arrière dans la bouche que le a-clair /a/ de langues comme l\'italien ou l\'espagnol. C\'est la variante postérieure familière du mot « pâte ». Grayson recommande une articulation légèrement plus antérieure pour le chant ; suivez toujours les conseils de votre professeur ou coach.'
          }, 
          citation: 'p. 81', 
          notable: false 
        },
        
        // Entry 2 | Bright-a / Interpalatal
        'a:stressed-interpalatal:а': { 
          blurb: { 
            en: 'The phoneme /ɑ/ (dark-a) fronts to its brighter allophone /a/ when it sits between two palatalizing agents: a preceding soft consonant and a following soft consonant (e.g., ⟨мяч⟩ /mʲatʃʲ/ "ball"). This is purely coarticulatory. It takes no extra effort.',
            fr: 'Le phonème /ɑ/ (a-sombre) s\'antériorise vers son allophone plus clair /a/ lorsqu\'il se trouve entre deux agents palatalisants : une consonne molle précédente et une consonne molle suivante (p. ex. ⟨мяч⟩ /mʲatʃʲ/ « ballon »). C\'est un effet purement coarticulatoire qui ne demande aucun effort supplémentaire.'
          }, 
          citation: 'pp. 81–85, 125', 
          notable: true 
        },
        
        // Entry 3 | Open-e
        'ɛ:stressed:е': { 
          blurb: { 
            en: 'The Russian phoneme notated /ɛ/ is the familiar open-mid front vowel. It is the "default" sound for stressed ⟨е⟩ and ⟨э⟩ when no closing environment applies.',
            fr: 'Le phonème russe noté /ɛ/ est la voyelle antérieure mi-ouverte bien connue. C\'est le son par défaut pour ⟨е⟩ et ⟨э⟩ accentués lorsqu\'aucun contexte de fermeture ne s\'applique.'
          }, 
          citation: 'pp. 87–90', 
          notable: false 
        },
        
        // Entry 4 | Close-e / Interpalatal
        'e:stressed-interpalatal:е': { 
          blurb: { 
            en: 'When stressed ⟨е⟩ or ⟨э⟩ is sandwiched between two palatalizing agents, it closes from /ɛ/ to /e/. This closing is a natural coarticulatory effect.',
            fr: 'Lorsque ⟨е⟩ ou ⟨э⟩ accentué se trouve entre deux agents palatalisants, il se ferme de /ɛ/ à /e/. Cette fermeture est un effet coarticulatoire naturel.'
          }, 
          citation: 'pp. 87–90, 125', 
          notable: true 
        },
        
        // Entry 5 | Stressed-o
        'o:stressed:о': { 
          blurb: { 
            en: 'Stressed ⟨о⟩ is pronounced /o/, a true mid-back rounded vowel. It does not diphthongize as it might in some English dialects (avoid "oh-oo").',
            fr: '⟨о⟩ accentué se prononce /o/, une véritable voyelle postérieure mi-fermée arrondie. Il ne se diphtongue pas comme dans certains dialectes anglais (évitez « oh-ou »). La voyelle française dans « beau » est une bonne approximation.'
          }, 
          citation: 'p. 86', 
          notable: false 
        },
        
        // Entry 4b | Stressed-o (ё spelling)
        'o:stressed:ё': { 
          blurb: { 
            en: 'The letter ⟨ё⟩ represents a stressed /o/ preceded by palatalization. After a soft consonant, the sequence is /ʲo/. Word-initially or after a vowel, a /j/-glide precedes the vowel: /jo/.',
            fr: 'La lettre ⟨ё⟩ représente un /o/ accentué précédé d\'une palatalisation. Après une consonne molle, la séquence est /ʲo/. En début de mot ou après une voyelle, une glissante /j/ précède la voyelle : /jo/.'
          }, 
          citation: 'pp. 85–86', 
          notable: false 
        },
        
        // Entry 6 | Stressed-u
        'u:stressed:у': { 
          blurb: { 
            en: 'Whether stressed or unstressed, the letter ⟨у⟩ is always pronounced /u/. Russian /u/ is a true close back rounded vowel, like Italian or German /u/.',
            fr: 'Qu\'elle soit accentuée ou non, la lettre ⟨у⟩ se prononce toujours /u/. Le /u/ russe est une véritable voyelle postérieure fermée arrondie, comme le « ou » français dans « vous ».'
          }, 
          citation: 'pp. 91–93', 
          notable: false 
        },
        
        // Entry 6b | Stressed-u (ю spelling)
        'u:stressed:ю': { 
          blurb: { 
            en: 'Whether stressed or unstressed, the letter ⟨у⟩ is always pronounced /u/. Russian /u/ is a true close back rounded vowel, like Italian or German /u/.',
            fr: 'Qu\'elle soit accentuée ou non, la lettre ⟨у⟩ se prononce toujours /u/. Le /u/ russe est une véritable voyelle postérieure fermée arrondie, comme le « ou » français dans « vous ».'
          }, 
          citation: 'pp. 91–92', 
          notable: false 
        },
        
        // Entry 7 | Stressed-i
        'i:stressed:и': { 
          blurb: { 
            en: 'Stressed ⟨и⟩ is pronounced /i/, the familiar close front unrounded vowel. Russian /i/ is bright and forward, similar to the vowel in "see" or Italian "si."',
            fr: '⟨и⟩ accentué se prononce /i/, la voyelle antérieure fermée non arrondie bien connue. Le /i/ russe est clair et antérieur, semblable au « i » français dans « si ».'
          }, 
          citation: 'p. 96', 
          notable: false 
        },
        
        // Entry 8 | Barred-i / Velar-i
        'ɨ:stressed:ы': { 
          blurb: { 
            en: 'The Russian phoneme /ɨ/ (sometimes called "velar-i" or "barred-i") has no English equivalent. It is produced with the tongue positioned as for /i/, but retracted toward the velum. Think of trying to say /i/ while pulling your tongue back. This vowel is intrinsically linked to the preceding hard consonant.',
            fr: 'Malheureusement, cette voyelle est totalement étrangère au français. Le phonème russe /ɨ/ (parfois appelé i-vélaire) se produit avec la langue positionnée comme pour /i/, mais rétractée vers le velum. Imaginez prononcer /i/ tout en reculant la langue. Cette voyelle est intrinsèquement liée à la consonne dure qui la précède.'
          }, 
          citation: 'pp. 93–95', 
          notable: false 
        },
        
        // ========================================
        // SECTION 2: VOWELS — UNSTRESSED (Entries 11–25)
        // ========================================
        
        // Entry 11 | Pretonic-o / Akanye
        'ɑ:pretonic:о': { 
          blurb: { 
            en: 'Pretonic ⟨о⟩ reduces to /ʌ/. This is akanye /ˈɑ kʌn jə/, one of the signature features of sung Russian. The vowel loses its lip rounding and centralizes.',
            fr: '⟨о⟩ prétonique se réduit à /ʌ/. C\'est l\'<em>akanié</em> /ˈɑ kʌ ɲɪ/, l\'un des traits distinctifs du russe chanté. La voyelle perd son arrondissement labial et se centralise.'
          }, 
          citation: 'pp. 108, 127', 
          notable: true 
        },
        
        // Entry 12 | Pretonic-a
        'ɑ:pretonic:а': { 
          blurb: { 
            en: 'Pretonic ⟨а⟩ is pronounced /ʌ/. Although spelled differently from pretonic ⟨о⟩, both vowels neutralize to the same reduced vowel in pretonic position.',
            fr: '⟨а⟩ prétonique se prononce /ʌ/. Bien qu\'orthographié différemment de ⟨о⟩ prétonique, les deux voyelles se neutralisent en la même voyelle réduite en position prétonique.'
          }, 
          citation: 'pp. 97–102', 
          notable: false 
        },
        
        // Entry 11b | Pretonic interpalatal а → /a/
        'a:pretonic-interpalatal:а': { 
          blurb: { 
            en: 'Pretonic ⟨а⟩ is pronounced /ʌ/. Although spelled differently from pretonic ⟨о⟩, both vowels neutralize to the same reduced vowel in pretonic position.',
            fr: '⟨а⟩ prétonique se prononce /ʌ/. Bien qu\'orthographié différemment de ⟨о⟩ prétonique, les deux voyelles se neutralisent en la même voyelle réduite en position prétonique.'
          }, 
          citation: 'pp. 108, 127', 
          notable: false 
        },
        
        // Entry 12b | Word-initial о → /ɑ/
        'ɑ:initial:о': { 
          blurb: { 
            en: 'Pretonic ⟨о⟩ reduces to /ʌ/. This is akanye /ˈɑ kʌn jə/, one of the signature features of sung Russian. The vowel loses its lip rounding and centralizes.',
            fr: '⟨о⟩ prétonique se réduit à /ʌ/. C\'est l\'<em>akanié</em> /ˈɑ kʌ ɲɪ/, l\'un des traits distinctifs du russe chanté. La voyelle perd son arrondissement labial et se centralise.'
          }, 
          citation: 'pp. 108, 127', 
          notable: true 
        },
        
        // Entry 14 | Word-initial а → /ɑ/
        'ɑ:initial:а': { 
          blurb: { 
            en: 'Pretonic ⟨а⟩ is pronounced /ʌ/. Although spelled differently from pretonic ⟨о⟩, both vowels neutralize to the same reduced vowel in pretonic position.',
            fr: '⟨а⟩ prétonique se prononce /ʌ/. Bien qu\'orthographié différemment de ⟨о⟩ prétonique, les deux voyelles se neutralisent en la même voyelle réduite en position prétonique.'
          }, 
          citation: 'pp. 108, 127', 
          notable: false 
        },
        
        // Entry 15 | Post-stress immediate а → /ɑ/
        'ɑ:post-stress-immediate:а': { 
          blurb: { 
            en: 'Post-stress ⟨а⟩ reduces to /ʌ/, just like post-stress ⟨о⟩. The two vowels are indistinguishable in this position.',
            fr: '⟨а⟩ post-tonique se réduit à /ʌ/, tout comme ⟨о⟩ post-tonique. Les deux voyelles sont indistinguables dans cette position.'
          }, 
          citation: 'pp. 108, 127', 
          notable: false 
        },
        
        // Entry 13 | Post-stress-o
        'ʌ:post-stress:о': { 
          blurb: { 
            en: 'Post-stress ⟨о⟩ reduces to /ʌ/. This reduction applies to all unstressed positions after the stress, not just immediately following it.',
            fr: '⟨о⟩ post-tonique se réduit à /ʌ/. Cette réduction s\'applique à toutes les positions inaccentuées après l\'accent, pas seulement immédiatement après.'
          }, 
          citation: 'pp. 108, 127', 
          notable: false 
        },
        
        // Entry 14b | Post-stress-a
        'ʌ:post-stress:а': { 
          blurb: { 
            en: 'Post-stress ⟨а⟩ reduces to /ʌ/, just like post-stress ⟨о⟩. The two vowels are indistinguishable in this position.',
            fr: '⟨а⟩ post-tonique se réduit à /ʌ/, tout comme ⟨о⟩ post-tonique. Les deux voyelles sont indistinguables dans cette position.'
          }, 
          citation: 'pp. 108, 127', 
          notable: false 
        },
        
        // Entry 15b | Unstressed-e / Ikanye
        'ɪ:ikanye:е': { 
          blurb: { 
            en: 'Unstressed ⟨е⟩ reduces to /ɪ/. This is ikanye /i ˈkɑn jə/, another signature feature of sung Russian vowel reduction.',
            fr: '⟨е⟩ inaccentué se réduit à /ɪ/. C\'est l\'<em>ikanié</em> /i ˈkɑ ɲɪ/, un autre trait distinctif de la réduction vocalique en russe chanté.'
          }, 
          citation: 'pp. 97–107', 
          notable: true 
        },
        
        // Entry 16 | Turned-v (remote о)
        'ʌ:remote:о': { 
          blurb: { 
            en: '<em>Ilya</em> uses /ʌ/ (turned-v) rather than schwa /ə/ to avoid confusion with the French schwa, which is rounded. The symbol /ʌ/ better represents the unrounded, centralized quality of unstressed Russian ⟨о⟩ and ⟨а⟩.',
            fr: '<em>Ilya</em> utilise /ʌ/ (v-renversé) plutôt que le schwa /ə/ pour éviter toute confusion avec le e-caduc français, qui est arrondi. Le symbole /ʌ/ représente mieux la qualité non arrondie et centralisée de ⟨о⟩ et ⟨а⟩ inaccentués en russe.'
          }, 
          citation: 'pp. 108, 127', 
          notable: true 
        },
        
        // Entry 17 | Turned-v (remote а)
        'ʌ:remote:а': { 
          blurb: { 
            en: '<em>Ilya</em> uses /ʌ/ (turned-v) rather than schwa /ə/ to avoid confusion with the French schwa, which is rounded. The symbol /ʌ/ better represents the unrounded, centralized quality of unstressed Russian ⟨о⟩ and ⟨а⟩.',
            fr: '<em>Ilya</em> utilise /ʌ/ (v-renversé) plutôt que le schwa /ə/ pour éviter toute confusion avec le e-caduc français, qui est arrondi. Le symbole /ʌ/ représente mieux la qualité non arrondie et centralisée de ⟨о⟩ et ⟨а⟩ inaccentués en russe.'
          }, 
          citation: 'pp. 108, 127', 
          notable: true 
        },
        
        // Entry 18 | Unstressed-ya
        'ɪ:ikanye:я': { 
          blurb: { 
            en: 'Unstressed ⟨я⟩ reduces to /ɪ/, preceded by palatalization of the preceding consonant (or a /j/-glide word-initially). The vowel quality matches unstressed ⟨е⟩.',
            fr: '⟨я⟩ inaccentué se réduit à /ɪ/, précédé de la palatalisation de la consonne précédente (ou d\'une glissante /j/ en début de mot). La qualité vocalique correspond à celle de ⟨е⟩ inaccentué.'
          }, 
          citation: 'pp. 97–107', 
          notable: true 
        },
        
        // Entry 19 | Reflexive я → [ʌ]
        'ʌ:reflexive:я': { 
          blurb: { 
            en: 'Unstressed ⟨я⟩ reduces to /ɪ/, preceded by palatalization of the preceding consonant (or a /j/-glide word-initially). The vowel quality matches unstressed ⟨е⟩.',
            fr: '⟨я⟩ inaccentué se réduit à /ɪ/, précédé de la palatalisation de la consonne précédente (ou d\'une glissante /j/ en début de mot). La qualité vocalique correspond à celle de ⟨е⟩ inaccentué.'
          }, 
          citation: 'pp. 237–238, 281–282', 
          notable: true 
        },
        
        // Entry 20 | Unstressed-u
        'u:unstressed:у': { 
          blurb: { 
            en: 'Unlike other vowels, ⟨у⟩ does not reduce when unstressed. It remains /u/ in all positions, though it may be slightly shorter in duration.',
            fr: 'Contrairement aux autres voyelles, ⟨у⟩ ne se réduit pas en position inaccentuée. Il reste /u/ dans toutes les positions, bien qu\'il puisse être légèrement plus bref.'
          }, 
          citation: 'pp. 91–92', 
          notable: false 
        },
        
        // Entry 20b | Unstressed-u (ю spelling)
        'u:unstressed:ю': { 
          blurb: { 
            en: 'Unlike other vowels, ⟨у⟩ does not reduce when unstressed. It remains /u/ in all positions, though it may be slightly shorter in duration.',
            fr: 'Contrairement aux autres voyelles, ⟨у⟩ ne se réduit pas en position inaccentuée. Il reste /u/ dans toutes les positions, bien qu\'il puisse être légèrement plus bref.'
          }, 
          citation: 'pp. 91–92', 
          notable: false 
        },
        
        // Entry 21 | Unstressed-i
        'i:unstressed:и': { 
          blurb: { 
            en: 'Unstressed ⟨и⟩ remains /i/, though slightly reduced in duration and intensity. As Grayson notes: "The vowel keeps its essential quality but loses some of its \'punch.\'"',
            fr: '⟨и⟩ inaccentué reste /i/, bien que légèrement réduit en durée et en intensité. Comme le note Grayson : « La voyelle conserve sa qualité essentielle mais perd un peu de son éclat. » [traduction Mitton]'
          }, 
          citation: 'p. 96', 
          notable: true 
        },
        
        // Entry 22 | Unstressed-y
        'ɨ:unstressed:ы': { 
          blurb: { 
            en: 'Unstressed ⟨ы⟩ remains /ɨ/, maintaining its retracted tongue position. Like unstressed /i/ and /u/, it resists the neutralization that affects /o/, /a/, and /e/.',
            fr: '⟨ы⟩ inaccentué reste /ɨ/, maintenant sa position linguale rétractée. Comme /i/ et /u/ inaccentués, il résiste à la neutralisation qui affecte /o/, /a/ et /e/.'
          }, 
          citation: 'pp. 93–95', 
          notable: false 
        },
        
        // Entry 23 | И after hard consonant
        'ɨ:after-hard:и': { 
          blurb: { 
            en: 'When ⟨и⟩ follows an intrinsically hard consonant (⟨ж⟩, ⟨ш⟩, or ⟨ц⟩), it is pronounced /ɨ/ rather than /i/. The hard consonant "retracts" the vowel.',
            fr: 'Lorsque ⟨и⟩ suit une consonne intrinsèquement dure (⟨ж⟩, ⟨ш⟩ ou ⟨ц⟩), il se prononce /ɨ/ plutôt que /i/. La consonne dure « rétracte » la voyelle.'
          }, 
          citation: 'pp. 93–95', 
          notable: false 
        },
        
        // Entry 24 | Е after hard consonant
        'ɨ:after-hard:е': { 
          blurb: { 
            en: 'When unstressed ⟨е⟩ follows an intrinsically hard consonant (⟨ж⟩, ⟨ш⟩, or ⟨ц⟩), it is pronounced /ɨ/ rather than reducing to /ɪ/. The hard consonant overrides the normal ikanye reduction.',
            fr: 'Lorsque ⟨е⟩ inaccentué suit une consonne intrinsèquement dure (⟨ж⟩, ⟨ш⟩ ou ⟨ц⟩), il se prononce /ɨ/ plutôt que de se réduire à /ɪ/. La consonne dure prévaut sur la réduction normale de l\'<em>ikanié</em>.'
          }, 
          citation: 'pp. 97–107', 
          notable: false 
        },
        
        // Entry 25 | Unstressed э → /ɪ/
        'ɪ:unstressed:э': { 
          blurb: { 
            en: 'Unstressed ⟨е⟩ reduces to /ɪ/. This is ikanye /i ˈkɑn jə/, another signature feature of sung Russian vowel reduction.',
            fr: '⟨е⟩ inaccentué se réduit à /ɪ/. C\'est l\'<em>ikanié</em> /i ˈkɑ ɲɪ/, un autre trait distinctif de la réduction vocalique en russe chanté.'
          }, 
          citation: 'pp. 97–107', 
          notable: false 
        },
        
        // ========================================
        // SECTION 3: J-GLIDES (Entries 26–33b)
        // ========================================
        
        // Entry 26 | Word-initial е
        'jɑ:initial:я': { 
          blurb: { 
            en: 'Word-initial ⟨я⟩ is preceded by a /j/-glide: the letter represents /jɑ/ when stressed or /jɪ/ when unstressed.',
            fr: '⟨я⟩ en début de mot est précédé d\'une glissante /j/ : la lettre représente /jɑ/ si accentuée ou /jɪ/ si inaccentuée.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 27 | Word-initial е
        'jɛ:initial:е': { 
          blurb: { 
            en: 'Word-initial ⟨е⟩ is preceded by a /j/-glide: the letter represents /jɛ/ when stressed or /jɪ/ when unstressed.',
            fr: '⟨е⟩ en début de mot est précédé d\'une glissante /j/ : la lettre représente /jɛ/ si accentuée ou /jɪ/ si inaccentuée.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 28 | Word-initial ё
        'jo:initial:ё': { 
          blurb: { 
            en: 'Word-initial ⟨ё⟩ is preceded by a /j/-glide: the letter represents /jo/. Since ⟨ё⟩ is always stressed, no reduced variant exists.',
            fr: '⟨ё⟩ en début de mot est précédé d\'une glissante /j/ : la lettre représente /jo/. Puisque ⟨ё⟩ est toujours accentué, aucune variante réduite n\'existe.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 29 | Word-initial ю
        'ju:initial:ю': { 
          blurb: { 
            en: 'Word-initial ⟨ю⟩ is preceded by a /j/-glide: the letter represents /ju/ whether stressed or unstressed.',
            fr: '⟨ю⟩ en début de mot est précédé d\'une glissante /j/ : la lettre représente /ju/, qu\'elle soit accentuée ou non.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 30 | Word-initial unstressed е → /jɪ/
        'jɪ:initial:е': { 
          blurb: { 
            en: 'Word-initial unstressed ⟨е⟩ is pronounced /ɪ/, typically preceded by a light /j/-glide. The combination sounds like /jɪ/.',
            fr: '⟨е⟩ inaccentué en début de mot se prononce /ɪ/, généralement précédé d\'une légère glissante /j/. La combinaison sonne comme /jɪ/.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 31 | Word-initial unstressed я → /jɪ/
        'jɪ:initial:я': { 
          blurb: { 
            en: 'Word-initial unstressed ⟨я⟩ is pronounced /jɪ/, identical to word-initial unstressed ⟨е⟩. The spelling difference reflects historical orthography, not modern pronunciation.',
            fr: '⟨я⟩ inaccentué en début de mot se prononce /jɪ/, identique à ⟨е⟩ inaccentué en début de mot. La différence orthographique reflète l\'histoire de la langue, non la prononciation moderne.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 32 | Е after vowel
        'jɛ:postvocalic:е': { 
          blurb: { 
            en: 'When ⟨е⟩ follows another vowel (hiatus position), a /j/-glide is inserted: the sequence is pronounced /jɛ/ when stressed or /jɪ/ when unstressed.',
            fr: 'Lorsque ⟨е⟩ suit une autre voyelle (position de hiatus), une glissante /j/ s\'insère : la séquence se prononce /jɛ/ si accentuée ou /jɪ/ si inaccentuée.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 32b | Ё after vowel
        'jo:postvocalic:ё': { 
          blurb: { 
            en: 'When ⟨ё⟩ follows another vowel, a /j/-glide is inserted: the sequence is pronounced /jo/.',
            fr: 'Lorsque ⟨ё⟩ suit une autre voyelle, une glissante /j/ s\'insère : la séquence se prononce /jo/.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 32c | Ю after vowel
        'ju:postvocalic:ю': { 
          blurb: { 
            en: 'When ⟨ю⟩ follows another vowel, a /j/-glide is inserted: the sequence is pronounced /ju/. Although English speakers often call /j/ a semi-vowel, Russians classify it as a consonant.',
            fr: 'Lorsque ⟨ю⟩ suit une autre voyelle, une glissante /j/ s\'insère : la séquence se prononce /ju/. Bien que les francophones classent souvent /j/ parmi les semi-voyelles, la glissante /j/ (que les Russes classent parmi les consonnes) fonctionne ici comme une attaque syllabique.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 33 | Я after vowel
        'jɑ:postvocalic:я': { 
          blurb: { 
            en: 'When ⟨я⟩ follows another vowel, a /j/-glide is inserted: the sequence is pronounced /jɑ/ when stressed or /jɪ/ when unstressed.',
            fr: 'Lorsque ⟨я⟩ suit une autre voyelle, une glissante /j/ s\'insère : la séquence se prononce /jɑ/ si accentuée ou /jɪ/ si inaccentuée.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 33b | Double-i suffix
        'ij:suffix:ии': { 
          blurb: { 
            en: 'The suffix ⟨-ии⟩ (common in genitive/dative/prepositional singular of feminine nouns) is pronounced /ij/ + /i/, with a clear /j/-glide separating the two vowels. This singing convention ensures clarity and prevents the two identical vowels from merging.',
            fr: 'Le suffixe ⟨-ии⟩ (courant au génitif/datif/prépositionnel singulier des noms féminins) se prononce /ij/ + /i/, avec une glissante /j/ claire séparant les deux voyelles. Cette convention du chant assure la clarté et empêche les deux voyelles identiques de se confondre.'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // ========================================
        // SECTION 4: SOFT CONSONANTS (Entries 34–50)
        // ========================================
        
        // Entry 34 | Palatal nasal
        'ɲ:soft:н': { 
          blurb: { 
            en: 'Soft ⟨н⟩ is a true palatal nasal /ɲ/, not simply /n/ with a palatalization marker. Grayson\'s transcription distinguishes palatalized /nʲ/ (dental, rare) from palatal /ɲ/ (default soft н).',
            fr: '⟨н⟩ mou est une véritable nasale palatale /ɲ/, et non un simple /n/ avec un marqueur de palatalisation. La transcription de Grayson distingue /nʲ/ palatalisé (dental, rare) de /ɲ/ palatal (⟨н⟩ mou par défaut).'
          }, 
          citation: 'pp. 171–175', 
          notable: false 
        },
        
        // Entry 35 | Soft-l
        'lʲ:soft:л': { 
          blurb: { 
            en: 'Soft ⟨л⟩ is pronounced /lʲ/. Unlike hard ⟨л⟩ [ɫ], which is velarized, soft /lʲ/ has a clear, bright quality similar to the "l" in "million."',
            fr: '⟨л⟩ mou se prononce /lʲ/. Contrairement à ⟨л⟩ dur [ɫ], qui est vélarisé, /lʲ/ mou possède une qualité claire et brillante, semblable au « ll » de « million ».'
          }, 
          citation: 'pp. 171–175', 
          notable: false 
        },
        
        // Entry 36 | Soft-r
        'rʲ:soft:р': { 
          blurb: { 
            en: 'Soft ⟨р⟩ is pronounced /rʲ/, a palatalized trill. The tongue maintains the trilled articulation while the body of the tongue rises toward the palate.',
            fr: '⟨р⟩ mou se prononce /rʲ/, un roulé palatalisé. La langue maintient l\'articulation roulée tandis que le dos de la langue s\'élève vers le palais.'
          }, 
          citation: 'pp. 171–175', 
          notable: false 
        },
        
        // Entry 37 | Soft-s
        'sʲ:soft:с': { 
          blurb: { 
            en: 'Predictably, ⟨с⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant).',
            fr: 'Comme prévu, ⟨с⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 38 | Soft-t
        'tʲ:soft:т': { 
          blurb: { 
            en: 'Predictably, ⟨т⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Like \'hard\' /t/, \'soft\' /tʲ/ is dental (tongue on teeth).',
            fr: 'Comme prévu, ⟨т⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée). Comme /t/ dur, /tʲ/ mou est dental (langue contre les dents).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 39 | Soft-d
        'dʲ:soft:д': { 
          blurb: { 
            en: 'Predictably, ⟨д⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Like \'hard\' /d/, \'soft\' /dʲ/ is dental (tongue on teeth).',
            fr: 'Comme prévu, ⟨д⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée). Comme /d/ dur, /dʲ/ mou est dental (langue contre les dents).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 40 | Soft-p
        'pʲ:soft:п': { 
          blurb: { 
            en: 'Predictably, ⟨п⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Like hard /p/, soft /pʲ/ is unaspirated.',
            fr: 'Comme prévu, ⟨п⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée). Comme /p/ dur, /pʲ/ mou est non aspiré.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 41 | Soft-b
        'bʲ:soft:б': { 
          blurb: { 
            en: 'Predictably, ⟨б⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant).',
            fr: 'Comme prévu, ⟨б⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 42 | Soft-v
        'vʲ:soft:в': { 
          blurb: { 
            en: 'In sung Russian, the Cyrillic letter ⟨в⟩ (as /v/ or /f/) is phonemically weak: processes happen to it, but it won\'t transmit them to preceding consonants.<br><br>Within a word (this includes the prefix ⟨в-⟩, e.g., ⟨вниз⟩ /vʲɲis/), ⟨в⟩ softens normally before any palatalizing agent (soft-series vowels, ⟨ь⟩, palatalized consonants).<br><br>The (proclitic) preposition ⟨в⟩ will also soften from what follows (e.g., ⟨в небе⟩ /vʲ ˈɲebʲɪ/) because clitics bind to their host words; we can consider it part of the host word and treat it accordingly.<br><br>Words ending in ⟨в⟩ devoice normally (e.g., ⟨гнев⟩ /ɡɲɛf/).',
            fr: 'En russe chanté, la lettre ⟨в⟩ (réalisée /v/ ou /f/) est phonémiquement faible : les processus phonologiques l\'affectent, mais elle ne les transmet pas aux consonnes qui la précèdent.<br><br>À l\'intérieur d\'un mot (y compris le préfixe ⟨в-⟩, p. ex. ⟨вниз⟩ /vʲɲis/), ⟨в⟩ se palatalise normalement devant tout agent palatalisant (voyelles de la série molle, ⟨ь⟩, consonnes palatalisées).<br><br>La préposition (proclitique) ⟨в⟩ se palatalise également selon ce qui suit (p. ex. ⟨в небе⟩ /vʲ ˈɲebʲɪ/), car les clitiques se lient à leur mot hôte ; on peut les considérer comme faisant partie du mot hôte.<br><br>Les mots terminés par ⟨в⟩ se dévoisent normalement (p. ex. ⟨гнев⟩ /ɡɲɛf/).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 43 | Soft-f
        'fʲ:soft:ф': { 
          blurb: { 
            en: 'Predictably, ⟨ф⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant).',
            fr: 'Comme prévu, ⟨ф⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 44 | Soft-m
        'mʲ:soft:м': { 
          blurb: { 
            en: 'Predictably, ⟨м⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). In isolation, /mʲ/ is practically indistinguishable from unpalatalized /m/ to the ear.',
            fr: 'Comme prévu, ⟨м⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée). Isolé, /mʲ/ est pratiquement indiscernable de /m/ non palatalisé à l\'oreille.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 45 | Soft-k
        'kʲ:soft:к': { 
          blurb: { 
            en: '⟨К⟩ /k/ is one of the three sung Russian velar consonants alongside ⟨г⟩ /ɡ/ and ⟨х⟩ /x/ (or its voiced allophone [ɣ]). While ⟨к⟩ softens before some palatalizing agents (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩) or the soft sign ⟨ь⟩), only another velar consonant can regressively palatalize it. Like hard /k/, soft /kʲ/ is unaspirated.',
            fr: '⟨К⟩ /k/ est l\'une des trois consonnes vélaires du russe chanté, aux côtés de ⟨г⟩ /ɡ/ et ⟨х⟩ /x/ (ou son allophone voisé [ɣ]). Bien que ⟨к⟩ se palatalise devant certains agents palatalisants (une voyelle de la série molle ⟨я е и ё ю⟩ ou le signe mou ⟨ь⟩), seule une autre consonne vélaire peut le palataliser régressivement. Comme /k/ dur, /kʲ/ mou est non aspiré.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 46 | Soft-g
        'ɡʲ:soft:г': { 
          blurb: { 
            en: '⟨Г⟩ /ɡ/ is one of the three sung Russian velar consonants alongside ⟨к⟩ /k/ and ⟨х⟩ /x/ (or its voiced allophone [ɣ]). While ⟨г⟩ softens before some palatalizing agents (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩) or the soft sign ⟨ь⟩), only another velar consonant can regressively palatalize it. Note: Grayson\'s preferred IPA symbol is opentail [ɡ], although the International Phonetic Association accepts Latin [g] as equally valid.',
            fr: '⟨Г⟩ /ɡ/ est l\'une des trois consonnes vélaires du russe chanté, aux côtés de ⟨к⟩ /k/ et ⟨х⟩ /x/ (ou son allophone voisé [ɣ]). Bien que ⟨г⟩ se palatalise devant certains agents palatalisants (une voyelle de la série molle ⟨я е и ё ю⟩ ou le signe mou ⟨ь⟩), seule une autre consonne vélaire peut le palataliser régressivement. Remarque : Grayson préfère le symbole API à queue ouverte [ɡ], bien que l\'Association phonétique internationale accepte également le [g] latin.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 47 | Soft-x
        'xʲ:soft:х': { 
          blurb: { 
            en: '⟨Х⟩ /x/ (or its voiced allophone [ɣ]) is one of the three sung Russian velar consonants alongside ⟨к⟩ /k/ and ⟨г⟩ /ɡ/. While ⟨х⟩ softens before some palatalizing agents (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩) or the soft sign ⟨ь⟩), only another velar consonant can regressively palatalize it. Russian /xʲ/ is velar, articulated midway between German ich-laut /ç/ (palatal) and ach-laut /χ/ (uvular); avoid substituting either.',
            fr: '⟨Х⟩ /x/ (ou son allophone voisé [ɣ]) est l\'une des trois consonnes vélaires du russe chanté, aux côtés de ⟨к⟩ /k/ et ⟨г⟩ /ɡ/. Bien que ⟨х⟩ se palatalise devant certains agents palatalisants (une voyelle de la série molle ⟨я е и ё ю⟩ ou le signe mou ⟨ь⟩), seule une autre consonne vélaire peut le palataliser régressivement. Le /xʲ/ russe est vélaire, articulé à mi-chemin entre le <em>ich-Laut</em> allemand /ç/ (palatal) et le <em>ach-Laut</em> /χ/ (uvulaire) ; évitez de substituer l\'un ou l\'autre.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 48 | Soft-z
        'zʲ:soft:з': { 
          blurb: { 
            en: 'Predictably, ⟨з⟩ softens before any palatalizing agent (i.e., a vowel from the \'soft\' series (⟨я е и ё ю⟩), the soft sign ⟨ь⟩, or a palatalized consonant). Note: the prepositions ⟨из⟩ "from" and ⟨без⟩ "without" do accept palatalization across the word boundary (e.g., ⟨из них⟩ /izʲ ɲix/ "from them"). This behaviour never applies to content words that end in ⟨з⟩.',
            fr: 'Comme prévu, ⟨з⟩ se palatalise devant tout agent palatalisant (c.-à-d. une voyelle de la série molle ⟨я е и ё ю⟩, le signe mou ⟨ь⟩ ou une consonne palatalisée). Remarque : les prépositions ⟨из⟩ « de » et ⟨без⟩ « sans » acceptent la palatalisation à travers la frontière de mot (p. ex. ⟨из них⟩ /izʲ ɲix/ « d\'eux »). Ce comportement ne s\'applique jamais aux mots lexicaux terminés par ⟨з⟩.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 49 | Intrinsically soft ч
        'tʃʲ:always-soft:ч': { 
          blurb: { 
            en: 'The letter ⟨ч⟩ /tʃʲ/ is intrinsically palatalized. Grayson notates it with the indivisible trigraph /tʃʲ/.',
            fr: 'La lettre ⟨ч⟩ /tʃʲ/ est intrinsèquement palatalisée. Grayson la note avec le trigraphe indivisible /tʃʲ/.'
          }, 
          citation: 'pp. 183–186', 
          notable: false 
        },
        
        // Entry 50 | Intrinsically soft щ
        'ʃʲʃʲ:always-soft:щ': { 
          blurb: { 
            en: 'The letter ⟨щ⟩ /ʃʲʃʲ/ is intrinsically palatalized and intrinsically geminate. Grayson prefers to notate this soft consonant as /ʃʲʃʲ/ to emphasize that Russians rearticulate the sound, but it is equally valid to notate it as /ʃʲː/ to reduce visual clutter. You may choose your own preference in the <em>Ilya</em> dashboard. Note: a dated Peterburgian or Church Slavonic pronunciation /ʃʲtʃʲ/ exists, but this is not <em>Ilya</em>\'s default for sung Russian.',
            fr: 'La lettre ⟨щ⟩ /ʃʲʃʲ/ est intrinsèquement palatalisée et intrinsèquement géminée. Grayson préfère noter cette consonne molle /ʃʲʃʲ/ pour souligner que les Russes réarticulent le son, mais la notation /ʃʲː/ est tout aussi valide pour réduire l\'encombrement visuel. Vous pouvez choisir votre préférence dans le tableau de bord d\'<em>Ilya</em>. Remarque : une prononciation pétersbourgeoise ou en slavon d\'église ancienne /ʃʲtʃʲ/ existe, mais ce n\'est pas le choix par défaut d\'<em>Ilya</em> pour le russe chanté.'
          }, 
          citation: 'pp. 183–186', 
          notable: false 
        },
        
        // ========================================
        // SECTION 5: HARD CONSONANTS (Entries 51–69)
        // ========================================
        
        // Entry 51 | Intrinsically hard ж
        'ʒ:always-hard:ж': { 
          blurb: { 
            en: 'The letter ⟨ж⟩ /ʒ/ is intrinsically hard: it cannot soften, regardless of what follows. When it is followed by ⟨и⟩ or unstressed ⟨е⟩ (as is common due to traditional Russian spelling rules), ⟨ж⟩ remains unpalatalized /ʒ/ while these vowels are sung instead as the more compatible /ɨ/ (e.g., ⟨жить⟩ /ʒɨtʲ/ "to live," ⟨жена⟩ /ʒɨˈnɑ/ "wife").',
            fr: 'La lettre ⟨ж⟩ /ʒ/ est intrinsèquement dure : elle ne peut pas se palataliser, peu importe ce qui suit. Lorsqu\'elle est suivie de ⟨и⟩ ou de ⟨е⟩ inaccentué (fréquent en raison des règles orthographiques traditionnelles), ⟨ж⟩ reste non palatalisé /ʒ/ tandis que ces voyelles se chantent /ɨ/, plus compatible (p. ex. ⟨жить⟩ /ʒɨtʲ/ « vivre », ⟨жена⟩ /ʒɨˈnɑ/ « épouse »).'
          }, 
          citation: 'pp. 176–182', 
          notable: false 
        },
        
        // Entry 52 | Intrinsically hard ш
        'ʃ:always-hard:ш': { 
          blurb: { 
            en: 'The letter ⟨ш⟩ /ʃ/ is intrinsically hard: it cannot soften, regardless of what follows. When it is followed by ⟨и⟩ or unstressed ⟨е⟩ (as is common due to traditional Russian spelling rules), ⟨ш⟩ remains unpalatalized /ʃ/ while these vowels are sung instead as the more compatible /ɨ/ (e.g., ⟨шить⟩ /ʃɨtʲ/ "to sew," ⟨шептать⟩ /ʃɨpˈtɑtʲ/ "to whisper").',
            fr: 'La lettre ⟨ш⟩ /ʃ/ est intrinsèquement dure : elle ne peut pas se palataliser, peu importe ce qui suit. Lorsqu\'elle est suivie de ⟨и⟩ ou de ⟨е⟩ inaccentué (fréquent en raison des règles orthographiques traditionnelles), ⟨ш⟩ reste non palatalisé /ʃ/ tandis que ces voyelles se chantent /ɨ/, plus compatible (p. ex. ⟨шить⟩ /ʃɨtʲ/ « coudre », ⟨шептать⟩ /ʃɨpˈtɑtʲ/ « chuchoter »).'
          }, 
          citation: 'pp. 176–182', 
          notable: false 
        },
        
        // Entry 53 | Intrinsically hard ц
        'ts:always-hard:ц': { 
          blurb: { 
            en: 'The letter ⟨ц⟩ /ts/ is intrinsically hard: it cannot soften, regardless of what follows. This digraph notates a single phoneme, /ts/, which can be confusing to Anglophones who routinely encounter mid-word /ts/ (i.e. /t/ + /s/) at a morpheme boundary (e.g., ⟨отсюда⟩ /ɑtʲˈsʲudʌ/ "from here"). Structurally, these very common cases are the result of the meeting of two separate phonemes, not the affricate ⟨ц⟩ /ts/, even though they are visually indistinguishable. When ⟨ц⟩ is followed by ⟨и⟩ or unstressed ⟨е⟩ (as is common due to traditional Russian spelling rules), it remains unpalatalized /ts/ and these vowels are sung instead as the more compatible /ɨ/ (e.g., ⟨цирк⟩ /tsɨrk/ "circus," ⟨цена⟩ /tsɨˈnɑ/ "price").',
            fr: 'La lettre ⟨ц⟩ /ts/ est intrinsèquement dure : elle ne peut pas se palataliser, peu importe ce qui suit. Ce digraphe note un seul phonème, /ts/, à ne pas confondre avec la séquence /t/ + /s/ qui apparaît à la frontière de morphèmes (p. ex. ⟨отсюда⟩ /ɑtʲˈsʲudʌ/ « d\'ici »). Ces cas très fréquents résultent de la rencontre de deux phonèmes distincts, et non de l\'affriquée ⟨ц⟩ /ts/, même s\'ils sont visuellement identiques. Lorsque ⟨ц⟩ est suivi de ⟨и⟩ ou de ⟨е⟩ inaccentué (fréquent en raison des règles orthographiques traditionnelles), il reste non palatalisé /ts/ et ces voyelles se chantent /ɨ/, plus compatible (p. ex. ⟨цирк⟩ /tsɨrk/ « cirque », ⟨цена⟩ /tsɨˈnɑ/ « prix »).'
          }, 
          citation: 'pp. 176–182', 
          notable: false 
        },
        
        // Entry 54 | Hard-l / Velar-l
        'ɫ:hard:л': { 
          blurb: { 
            en: 'Velarized hard-l [ɫ] is the default for ⟨л⟩ when no palatalizing agent follows. Note: the phoneme [l] never exists unqualified in sung Russian: it is always either \'soft\' (palatalized) /lʲ/ or \'hard\' (velarized) [ɫ], never a standalone [l].',
            fr: 'Le [ɫ] vélarisé (l-dur) est la réalisation par défaut de ⟨л⟩ lorsqu\'aucun agent palatalisant ne suit. Remarque : le phonème [l] n\'existe jamais seul en russe chanté : il est toujours soit mou (palatalisé) /lʲ/, soit dur (vélarisé) [ɫ], jamais un simple [l].'
          }, 
          citation: 'pp. 171–175', 
          notable: false 
        },
        
        // Entry 55 | /j/-glide
        'j:glide:й': { 
          blurb: { 
            en: 'The letter ⟨й⟩ represents the familiar palatal glide /j/. Although English speakers often call this phoneme a semi-vowel, Russians consider /j/ a consonant. In native Russian words, ⟨й⟩ only appears after vowels, typically as the closing element in diphthongs (e.g., ⟨мой⟩ /moj/ "my/mine," ⟨чайка⟩ /ˈtʃʲajkʌ/ "seagull").',
            fr: 'La lettre ⟨й⟩ représente la glissante palatale /j/. Bien que les francophones la classent parmi les semi-voyelles, les Russes considèrent /j/ comme une consonne. Dans les mots russes natifs, ⟨й⟩ n\'apparaît qu\'après une voyelle, généralement comme élément final d\'une diphtongue (p. ex. ⟨мой⟩ /moj/ « mon/le mien », ⟨чайка⟩ /ˈtʃʲajkʌ/ « mouette »).'
          }, 
          citation: 'pp. 114–124', 
          notable: false 
        },
        
        // Entry 56 | Hard-s
        's:hard:с': { 
          blurb: { 
            en: 'Unpalatalized ⟨с⟩ /s/ is the default when no palatalizing agent follows.',
            fr: '⟨с⟩ non palatalisé /s/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 57 | Hard-z
        'z:hard:з': { 
          blurb: { 
            en: 'Unpalatalized ⟨з⟩ /z/ is the default when no palatalizing agent follows.',
            fr: '⟨з⟩ non palatalisé /z/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 58 | Hard-t
        't:hard:т': { 
          blurb: { 
            en: 'Unpalatalized ⟨т⟩ /t/ is the default when no palatalizing agent follows. Russian /t/ is dental (tongue on teeth, not alveolar as in English), but <em>Ilya</em> notates it as plain /t/.',
            fr: '⟨т⟩ non palatalisé /t/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Le /t/ russe est dental (langue contre les dents, comme en français), mais <em>Ilya</em> le note simplement /t/.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 59 | Hard-d
        'd:hard:д': { 
          blurb: { 
            en: 'Unpalatalized ⟨д⟩ /d/ is the default when no palatalizing agent follows. Russian /d/ is dental (tongue on teeth, not alveolar as in English), but <em>Ilya</em> notates it as plain /d/.',
            fr: '⟨д⟩ non palatalisé /d/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Le /d/ russe est dental (langue contre les dents, comme en français), mais <em>Ilya</em> le note simplement /d/.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 60 | Hard-p
        'p:hard:п': { 
          blurb: { 
            en: 'Unpalatalized ⟨п⟩ /p/ is the default when no palatalizing agent follows. Russian /p/ is unaspirated (like Italian), unlike English /pʰ/.',
            fr: '⟨п⟩ non palatalisé /p/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Le /p/ russe est non aspiré (comme en français ou en italien).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 61 | Hard-b
        'b:hard:б': { 
          blurb: { 
            en: 'Unpalatalized ⟨б⟩ /b/ is the default when no palatalizing agent follows.',
            fr: '⟨б⟩ non palatalisé /b/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 62 | Hard-k
        'k:hard:к': { 
          blurb: { 
            en: 'Unpalatalized ⟨к⟩ /k/ is the default when no palatalizing agent follows. Russian /k/ is unaspirated (like Italian), unlike English /kʰ/.',
            fr: '⟨к⟩ non palatalisé /k/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Le /k/ russe est non aspiré (comme en français ou en italien).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 63 | Hard-g
        'ɡ:hard:г': { 
          blurb: { 
            en: 'Unpalatalized ⟨г⟩ /ɡ/ is the default when no palatalizing agent follows. Note: Grayson\'s preferred IPA symbol is opentail [ɡ], although the International Phonetic Association accepts Latin [g] as equally valid.',
            fr: '⟨г⟩ non palatalisé /ɡ/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Remarque : Grayson préfère le symbole API à queue ouverte [ɡ], bien que l\'Association phonétique internationale accepte également le [g] latin.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 64 | Hard-x
        'x:hard:х': { 
          blurb: { 
            en: 'The letter ⟨х⟩ /x/ (or its voiced allophone [ɣ]) is one of the three sung Russian velar consonants alongside ⟨к⟩ /k/ and ⟨г⟩ /ɡ/. Unpalatalized /x/ is the default when no palatalizing agent follows, although this phoneme may undergo regressive voicing assimilation to become [ɣ]. This voiceless velar fricative resembles German ach-laut /χ/, but Russian /x/ is articulated further forward on the velum.',
            fr: 'La lettre ⟨х⟩ /x/ (ou son allophone voisé [ɣ]) est l\'une des trois consonnes vélaires du russe chanté, aux côtés de ⟨к⟩ /k/ et ⟨г⟩ /ɡ/. Le /x/ non palatalisé est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit, bien que ce phonème puisse subir une assimilation régressive de voisement pour devenir [ɣ]. Cette fricative vélaire sourde ressemble au <em>ach-Laut</em> allemand /χ/, mais le /x/ russe s\'articule plus en avant sur le velum.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 65 | Hard-f
        'f:hard:ф': { 
          blurb: { 
            en: 'Unpalatalized ⟨ф⟩ /f/ is the default when no palatalizing agent follows. All Russian words spelled with ⟨ф⟩ are loanwords.',
            fr: '⟨ф⟩ non palatalisé /f/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Tous les mots russes contenant ⟨ф⟩ sont des emprunts.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 66 | Hard-v
        'v:hard:в': { 
          blurb: { 
            en: 'Unpalatalized ⟨в⟩ /v/ is the default when no palatalizing agent follows. Note: ⟨в⟩ is phonemically weak. While it undergoes devoicing like any voiced consonant does (e.g., ⟨кров⟩ /krof/ "shelter"), ⟨в⟩ does not transmit voicing to preceding consonants (e.g., ⟨свет⟩ /svʲɛt/ "light," not */zvʲɛt/; ⟨твой⟩ /tvoj/ "your," not */dvoj/).',
            fr: '⟨в⟩ non palatalisé /v/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Remarque : ⟨в⟩ est phonémiquement faible. Bien qu\'il subisse le dévoisement comme toute consonne voisée (p. ex. ⟨кров⟩ /krof/ « abri »), ⟨в⟩ ne transmet pas le voisement aux consonnes qui le précèdent (p. ex. ⟨свет⟩ /svʲɛt/ « lumière », et non */zvʲɛt/ ; ⟨твой⟩ /tvoj/ « ton », et non */dvoj/).'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 67 | Hard-m
        'm:hard:м': { 
          blurb: { 
            en: 'Unpalatalized ⟨м⟩ /m/ is the default when no palatalizing agent follows.',
            fr: '⟨м⟩ non palatalisé /m/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 68 | Hard-n
        'n:hard:н': { 
          blurb: { 
            en: 'Unpalatalized ⟨н⟩ /n/ is the default when no palatalizing agent follows. Russian /n/ is dental (tongue on teeth, not alveolar as in English), but <em>Ilya</em> notates it as plain /n/.',
            fr: '⟨н⟩ non palatalisé /n/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Le /n/ russe est dental (langue contre les dents, comme en français), mais <em>Ilya</em> le note simplement /n/.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // Entry 69 | Hard-r
        'r:hard:р': { 
          blurb: { 
            en: 'Unpalatalized ⟨р⟩ /r/ is the default when no palatalizing agent follows. Russian /r/ is a trilled alveolar, like Italian or Spanish /r/.',
            fr: '⟨р⟩ non palatalisé /r/ est la réalisation par défaut lorsqu\'aucun agent palatalisant ne suit. Le /r/ russe est un roulé alvéolaire, comme le /r/ italien ou espagnol.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // ========================================
        // SECTION 6: SIGNS (Entries 70–71)
        // ========================================
        
        // Entry 70 | Hard sign
        'hard-sign:ъ': { 
          blurb: { 
            en: 'The hard sign ⟨ъ⟩ has no sound of its own. It serves as a silent boundary marker, preserving the unpalatalized state of its preceding consonant while signalling the insertion of a /j/-glide before the following vowel (e.g., ⟨съел⟩ /sjɛɫ/ "ate").',
            fr: 'Le signe dur ⟨ъ⟩ n\'a pas de son propre. Il sert de marqueur de frontière silencieux, préservant l\'état non palatalisé de la consonne qui le précède tout en signalant l\'insertion d\'une glissante /j/ avant la voyelle suivante (p. ex. ⟨съел⟩ /sjɛɫ/ « a mangé »).'
          }, 
          citation: 'pp. 136–140', 
          notable: false 
        },
        
        // Entry 71 | Soft sign
        'soft-sign:ь': { 
          blurb: { 
            en: 'The soft sign ⟨ь⟩ /ʲ/ is silent yet phonetically consequential. It palatalizes its preceding consonant. When followed by a vowel, it also signals the insertion of a /j/-glide between the now-palatalized consonant and the following vowel (e.g., ⟨пьеса⟩ /pʲˈjɛsʌ/ "play"; note the contiguous /ʲ/ and /j/, which are not interchangeable). Exception: after the intrinsically hard consonants ⟨ж⟩ and ⟨ш⟩, the soft sign is purely orthographic and does not indicate palatalization. Ignore it.',
            fr: 'Le signe mou ⟨ь⟩ /ʲ/ est silencieux mais phonétiquement significatif. Il palatalise la consonne qui le précède. Lorsqu\'il est suivi d\'une voyelle, il signale également l\'insertion d\'une glissante /j/ entre la consonne désormais palatalisée et la voyelle suivante (p. ex. ⟨пьеса⟩ /pʲˈjɛsʌ/ « pièce de théâtre » ; notez la contiguïté de /ʲ/ et /j/, qui ne sont pas interchangeables). Exception : après les consonnes intrinsèquement dures ⟨ж⟩ et ⟨ш⟩, le signe mou est purement orthographique et n\'indique pas de palatalisation. Ignorez-le.'
          }, 
          citation: 'pp. 136–140', 
          notable: false 
        },
        
        // ========================================
        // SECTION 7: ALLOPHONES & PROCESSES (Entry 72)
        // ========================================
        
        // Entry 72 | Gamma
        'ɣ:allophone:х': { 
          blurb: { 
            en: 'Just as /k/ becomes [ɡ] before a voiced consonant, ⟨х⟩ becomes [ɣ]. This voiced velar fricative [ɣ] is an allophone of /x/ without its own dedicated letterform.',
            fr: 'Tout comme /k/ devient [ɡ] devant une consonne voisée, ⟨х⟩ devient [ɣ]. Cette fricative vélaire voisée [ɣ] est un allophone de /x/ sans lettre propre.'
          }, 
          citation: 'pp. 152–170', 
          notable: false 
        },
        
        // ========================================
        // SECTION 8: SPECIAL CLUSTERS & EXCEPTIONS (Entries 73–85)
        // ========================================
        
        // Entry 73 | Reflexive endings
        'tːs:cluster:тс': { 
          blurb: { 
            en: 'The reflexive verb endings ⟨-тся⟩ and ⟨-ться⟩ are two orthographic representations of the same cluster, both pronounced /tːsʌ/. (The soft sign in ⟨-ться⟩ is ignored: no palatalization occurs.) Either spelling features an elongated /tː/ followed by /s/; by contrast, the similar affricate /ts/ is quicker to pronounce.',
            fr: 'Les terminaisons réfléchies ⟨-тся⟩ et ⟨-ться⟩ sont deux représentations orthographiques du même groupe, toutes deux prononcées /tːsʌ/. (Le signe mou dans ⟨-ться⟩ est ignoré : aucune palatalisation n\'a lieu.) Les deux graphies comportent un /tː/ allongé suivi de /s/ ; par contraste, l\'affriquée /ts/ se prononce plus rapidement.'
          }, 
          citation: 'pp. 237–238, 281–282', 
          notable: true 
        },
        
        // Entry 74 | ⟨чн⟩ → /ʃn/
        'ʃn:cluster:чн': { 
          blurb: { 
            en: 'In a subset of common words, the cluster ⟨чн⟩ is pronounced /ʃn/ rather than the expected /tʃʲn/. This subset includes ⟨конечно⟩ /kɑˈɲeʃnʌ/ "of course," ⟨скучно⟩ /ˈskuʃnʌ/ "boring," ⟨яичница⟩ /jɪˈiʃɲitsʌ/ "fried eggs," and a handful of others.',
            fr: 'Dans un sous-ensemble de mots courants, le groupe ⟨чн⟩ se prononce /ʃn/ plutôt que le /tʃʲn/ attendu. Ce sous-ensemble comprend ⟨конечно⟩ /kɑˈɲeʃnʌ/ « bien sûr », ⟨скучно⟩ /ˈskuʃnʌ/ « ennuyeux », ⟨яичница⟩ /jɪˈiʃɲitsʌ/ « œufs au plat », et quelques autres.'
          }, 
          citation: 'pp. 187–190', 
          notable: true 
        },
        
        // Entry 75 | ⟨чт⟩ → /ʃt/
        'ʃt:cluster:чт': { 
          blurb: { 
            en: 'In a subset of common words, the cluster ⟨чт⟩ is pronounced /ʃt/ rather than the expected /tʃʲt/. This subset includes ⟨что⟩ /ʃto/ "what," ⟨чтобы⟩ /ˈʃtobɨ/ "in order to," ⟨ничто⟩ /ɲiˈʃto/ "nothing," and a handful of others.',
            fr: 'Dans un sous-ensemble de mots courants, le groupe ⟨чт⟩ se prononce /ʃt/ plutôt que le /tʃʲt/ attendu. Ce sous-ensemble comprend ⟨что⟩ /ʃto/ « quoi », ⟨чтобы⟩ /ˈʃtobɨ/ « afin de », ⟨ничто⟩ /ɲiˈʃto/ « rien », et quelques autres.'
          }, 
          citation: 'pp. 187–190', 
          notable: true 
        },
        
        // Entry 76 | ⟨бог⟩ → /box/
        'x:exception:бог': { 
          blurb: { 
            en: 'In the word ⟨бог⟩ /box/ "God," the final ⟨г⟩ is pronounced /x/ rather than the expected devoiced /k/. This pronunciation is preserved from Church Slavonic tradition.',
            fr: 'Dans le mot ⟨бог⟩ /box/ « Dieu », le ⟨г⟩ final se prononce /x/ plutôt que le /k/ dévoisé attendu. Cette prononciation est préservée de la tradition du slavon d\'église.'
          }, 
          citation: 'pp. 187–190', 
          notable: true 
        },
        
        // Entry 77 | Genitive ⟨г⟩ → /v/
        'v:genitive:г': { 
          blurb: { 
            en: 'In the very common genitive singular endings ⟨-его⟩ and ⟨-ого⟩, the letter ⟨г⟩ is pronounced /v/, not /ɡ/. This applies to adjectives, pronouns, and ordinal numbers (e.g., ⟨его⟩ /jɪˈvo/ "his/him," ⟨сегодня⟩ /sʲɪˈvodɲʌ/ "today," ⟨красного⟩ /ˈkrɑsnʌvʌ/ "of the red"). Beware the common word ⟨много⟩ /ˈmnoɡʌ/ "much/many," where the identical-looking cluster is not a genitive ending, so it retains the voiced velar plosive /ɡ/ we would otherwise expect.',
            fr: 'Dans les terminaisons très courantes du génitif singulier ⟨-его⟩ et ⟨-ого⟩, la lettre ⟨г⟩ se prononce /v/, et non /ɡ/. Cela s\'applique aux adjectifs, pronoms et nombres ordinaux (p. ex. ⟨его⟩ /jɪˈvo/ « son/lui », ⟨сегодня⟩ /sʲɪˈvodɲʌ/ « aujourd\'hui », ⟨красного⟩ /ˈkrɑsnʌvʌ/ « du rouge »). Attention au mot courant ⟨много⟩ /ˈmnoɡʌ/ « beaucoup », où le groupe identique n\'est pas une terminaison génitive et conserve donc l\'occlusive vélaire voisée /ɡ/ attendue.'
          }, 
          citation: 'pp. 187–190', 
          notable: true 
        },
        
        // Entry 78 | ⟨сш⟩ → /ʃː/
        'ʃː:cluster:сш': { 
          blurb: { 
            en: 'When ⟨с⟩ precedes ⟨ш⟩, the /s/ transforms to match the /ʃ/ that follows, lengthening it (e.g., ⟨сшить⟩ /ʃːɨtʲ/ "to sew together").',
            fr: 'Lorsque ⟨с⟩ précède ⟨ш⟩, le /s/ s\'assimile au /ʃ/ qui suit, l\'allongeant (p. ex. ⟨сшить⟩ /ʃːɨtʲ/ « coudre ensemble »).'
          }, 
          citation: 'pp. 200–210', 
          notable: false 
        },
        
        // Entry 79 | ⟨зж⟩ → /ʒː/
        'ʒː:cluster:зж': { 
          blurb: { 
            en: 'When ⟨з⟩ precedes ⟨ж⟩, the /z/ transforms to match the /ʒ/ that follows, lengthening it (e.g., ⟨изжога⟩ /ɪˈʒːoɡʌ/ "heartburn").',
            fr: 'Lorsque ⟨з⟩ précède ⟨ж⟩, le /z/ s\'assimile au /ʒ/ qui suit, l\'allongeant (p. ex. ⟨изжога⟩ /ɪˈʒːoɡʌ/ « brûlures d\'estomac »).'
          }, 
          citation: 'pp. 200–210', 
          notable: false 
        },
        
        // Entry 80 | ⟨сч⟩ → /ʃʲʃʲ/
        'ʃʲʃʲ:cluster:сч': { 
          blurb: { 
            en: 'When ⟨с⟩ precedes ⟨ч⟩, the cluster assimilates to /ʃʲʃʲ/ (or /ʃʲː/ if you prefer), identical to ⟨щ⟩ (e.g., ⟨счастье⟩ /ˈʃʲːɑsʲtʲjɪ/ "happiness" (note the exceptional /ɑ/ in this common word), ⟨считать⟩ /ʃʲːɪˈtɑtʲ/ "to count," and ⟨расчёт⟩ /rʌˈʃʲːot/ "calculation").',
            fr: 'Lorsque ⟨с⟩ précède ⟨ч⟩, le groupe s\'assimile en /ʃʲʃʲ/ (ou /ʃʲː/ si vous préférez), identique à ⟨щ⟩ (p. ex. ⟨счастье⟩ /ˈʃʲːɑsʲtʲjɪ/ « bonheur » (notez le /ɑ/ exceptionnel dans ce mot courant), ⟨считать⟩ /ʃʲːɪˈtɑtʲ/ « compter » et ⟨расчёт⟩ /rʌˈʃʲːot/ « calcul »).'
          }, 
          citation: 'pp. 200–210', 
          notable: true 
        },
        
        // Entry 80b | ⟨зч⟩ → /ʃʲʃʲ/
        'ʃʲʃʲ:cluster:зч': { 
          blurb: { 
            en: 'When ⟨з⟩ precedes ⟨ч⟩, the cluster assimilates to /ʃʲʃʲ/, identical to ⟨щ⟩ (e.g., ⟨резчик⟩ /ˈrʲeʃʲʃʲɪk/ "carver," ⟨образчик⟩ /ɐˈbraʃʲʃʲɪk/ "sample"). The voiced ⟨з⟩ fully assimilates to match the following ⟨ч⟩.',
            fr: 'Lorsque ⟨з⟩ précède ⟨ч⟩, le groupe s\'assimile en /ʃʲʃʲ/, identique à ⟨щ⟩ (p. ex. ⟨резчик⟩ /ˈrʲeʃʲʃʲɪk/ « graveur », ⟨образчик⟩ /ɐˈbraʃʲʃʲɪk/ « échantillon »). Le ⟨з⟩ voisé s\'assimile entièrement au ⟨ч⟩ suivant.'
          }, 
          citation: 'pp. 200–210', 
          notable: false 
        },
        
        // Entry 81 | Silent ⟨л⟩ in ⟨лнц⟩
        'silent:cluster:лнц': { 
          blurb: { 
            en: '⟨л⟩ is silent in the cluster ⟨лнц⟩; this is an exceptional rule of one.',
            fr: '⟨л⟩ est muet dans le groupe ⟨лнц⟩ ; cas unique.'
          }, 
          citation: 'pp. 220–230', 
          notable: false 
        },
        
        // Entry 82 | Silent ⟨д⟩ in ⟨рдц⟩
        'silent:cluster:рдц': { 
          blurb: { 
            en: '⟨д⟩ is silent in the cluster ⟨рдц⟩; this is an exceptional rule of one.',
            fr: '⟨д⟩ est muet dans le groupe ⟨рдц⟩ ; cas unique.'
          }, 
          citation: 'pp. 220–230', 
          notable: false 
        },
        
        // Entry 83 | Silent ⟨т⟩ in ⟨стн⟩
        'silent:cluster:стн': { 
          blurb: { 
            en: 'In the cluster ⟨стн⟩, the ⟨т⟩ is silent (e.g., ⟨честный⟩ /ˈtʃʲesnɨj/ "honest," ⟨известный⟩ /ɪzˈvʲesnɨj/ "famous," and ⟨грустный⟩ /ˈɡrusnɨj/ "sad").',
            fr: 'Dans le groupe ⟨стн⟩, le ⟨т⟩ est muet (p. ex. ⟨честный⟩ /ˈtʃʲesnɨj/ « honnête », ⟨известный⟩ /ɪzˈvʲesnɨj/ « célèbre » et ⟨грустный⟩ /ˈɡrusnɨj/ « triste »).'
          }, 
          citation: 'pp. 220–230', 
          notable: false 
        },
        
        // Entry 84 | Silent ⟨д⟩ in ⟨здн⟩
        'silent:cluster:здн': { 
          blurb: { 
            en: 'In the cluster ⟨здн⟩, the ⟨д⟩ is silent (e.g., ⟨поздно⟩ /ˈpoznʌ/ "late," ⟨праздник⟩ /ˈprazɲɪk/ "holiday").',
            fr: 'Dans le groupe ⟨здн⟩, le ⟨д⟩ est muet (p. ex. ⟨поздно⟩ /ˈpoznʌ/ « tard », ⟨праздник⟩ /ˈprazɲɪk/ « fête »).'
          }, 
          citation: 'pp. 220–230', 
          notable: false 
        },
        
        // Entry 85 | Silent ⟨в⟩ in ⟨вств⟩
        'silent:cluster:вств': { 
          blurb: { 
            en: 'In the cluster ⟨вств⟩, the first ⟨в⟩ is silent (e.g., ⟨чувство⟩ /ˈtʃʲustvʌ/ "feeling," ⟨здравствуй⟩ /ˈzdrastvuj/ "hello").',
            fr: 'Dans le groupe ⟨вств⟩, le premier ⟨в⟩ est muet (p. ex. ⟨чувство⟩ /ˈtʃʲustvʌ/ « sentiment », ⟨здравствуй⟩ /ˈzdrastvuj/ « bonjour »).'
          }, 
          citation: 'pp. 220–230', 
          notable: false 
        },
        
        // ========================================
        // SECTION 9: LEGACY ENTRIES (Backward Compatibility)
        // ========================================
        
        // Legacy stressed я
        'ɑ:stressed:я': { 
          blurb: { 
            en: 'Stressed ⟨я⟩ following a soft consonant is pronounced /ɑ/. The preceding consonant carries the palatalization.',
            fr: '⟨я⟩ accentué après une consonne molle se prononce /ɑ/. La consonne précédente porte la palatalisation.'
          }, 
          citation: 'pp. 81–85', 
          notable: false 
        },
        
        // Legacy stressed э
        'ɛ:stressed:э': { 
          blurb: { 
            en: 'Stressed ⟨э⟩ is pronounced /ɛ/, the open-mid front vowel.',
            fr: '⟨э⟩ accentué se prononce /ɛ/, la voyelle antérieure mi-ouverte.'
          }, 
          citation: 'pp. 87–90', 
          notable: false 
        },
        
        // Legacy interpalatal а
        'a:interpalatal:а': { 
          blurb: { 
            en: '⟨а⟩ fronts to /a/ when sandwiched between two palatalizing agents.',
            fr: '⟨а⟩ s\'antériorise en /a/ lorsqu\'il est encadré par deux agents palatalisants.'
          }, 
          citation: 'pp. 81–85, 125', 
          notable: true 
        },
        
        // Legacy interpalatal я
        'a:interpalatal:я': { 
          blurb: { 
            en: '⟨я⟩ fronts to /a/ when sandwiched between two palatalizing agents.',
            fr: '⟨я⟩ s\'antériorise en /a/ lorsqu\'il est encadré par deux agents palatalisants.'
          }, 
          citation: 'pp. 81–85, 125', 
          notable: true 
        },
        
        // Legacy interpalatal е
        'e:interpalatal:е': { 
          blurb: { 
            en: '⟨е⟩ closes to /e/ when sandwiched between two palatalizing agents.',
            fr: '⟨е⟩ se ferme en /e/ lorsqu\'il est encadré par deux agents palatalisants.'
          }, 
          citation: 'pp. 87–90, 125', 
          notable: true 
        },
        
        // Legacy interpalatal э
        'e:interpalatal:э': { 
          blurb: { 
            en: 'When stressed ⟨э⟩ is word-initial before a palatalized consonant, it fronts from /ɛ/ to /e/ (e.g., ⟨эти⟩ → /ˈetʲi/, in contrast to ⟨это⟩ → /ˈɛtʌ/).',
            fr: 'Lorsque ⟨э⟩ accentué est en début de mot devant une consonne palatalisée, il s\'antériorise de /ɛ/ à /e/ (p. ex. ⟨эти⟩ → /ˈetʲi/, par opposition à ⟨это⟩ → /ˈɛtʌ/).'
          }, 
          citation: 'pp. 87–90, 125', 
          notable: false 
        },
        
        // Legacy post-stress о
        'ʌ:post-stress:о': { 
          blurb: { 
            en: 'Post-stress ⟨о⟩ reduces to /ʌ/.',
            fr: '⟨о⟩ post-tonique se réduit à /ʌ/.'
          }, 
          citation: 'pp. 108, 127', 
          notable: true 
        },
        
        // Legacy unstressed е
        'ɪ:unstressed:е': { 
          blurb: { 
            en: 'Unstressed ⟨е⟩ reduces to /ɪ/.',
            fr: '⟨е⟩ inaccentué se réduit à /ɪ/.'
          }, 
          citation: 'pp. 97–107', 
          notable: true 
        },
        
        // Legacy unstressed я
        'ɪ:unstressed:я': { 
          blurb: { 
            en: 'Unstressed ⟨я⟩ reduces to /ɪ/.',
            fr: '⟨я⟩ inaccentué se réduit à /ɪ/.'
          }, 
          citation: 'pp. 97–107', 
          notable: true 
        },
        
        // Legacy и after hard consonant
        'ɨ:after-hard:и': { 
          blurb: { 
            en: 'When ⟨и⟩ follows an intrinsically hard consonant (⟨ж⟩, ⟨ш⟩, or ⟨ц⟩), it is pronounced /ɨ/. The hard consonant retracts the cardinal-i to velar-i.',
            fr: 'Lorsque ⟨и⟩ suit une consonne intrinsèquement dure (⟨ж⟩, ⟨ш⟩ ou ⟨ц⟩), il se prononce /ɨ/. La consonne dure rétracte le i-cardinal vers le i-vélaire.'
          }, 
          citation: 'pp. 93–96', 
          notable: true 
        },
        
        // Legacy е after hard consonant
        'ɨ:after-hard:е': { 
          blurb: { 
            en: 'When unstressed ⟨е⟩ follows an intrinsically hard consonant (⟨ж⟩, ⟨ш⟩, or ⟨ц⟩), it is pronounced /ɨ/.',
            fr: 'Lorsque ⟨е⟩ inaccentué suit une consonne intrinsèquement dure (⟨ж⟩, ⟨ш⟩ ou ⟨ц⟩), il se prononce /ɨ/.'
          }, 
          citation: 'pp. 97–107', 
          notable: true 
        },
        
        // Devoicing process
        'devoicing:process': { 
          blurb: { 
            en: 'In Russian, as in German, final consonants are generally devoiced regardless of spelling (e.g., ⟨год⟩ → /ɡot/, ⟨кровь⟩ → /krofʲ/). Exception: sonorants (/m/, /mʲ/, /n/, /ɲ/, /ɫ/, /lʲ/, /r/, /rʲ/) are never devoiced.',
            fr: 'En russe, comme en allemand, les consonnes finales sont généralement dévoisées quelle que soit l\'orthographe (p. ex. ⟨год⟩ → /ɡot/, ⟨кровь⟩ → /krofʲ/). Exception : les sonantes (/m/, /mʲ/, /n/, /ɲ/, /ɫ/, /lʲ/, /r/, /rʲ/) ne sont jamais dévoisées.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        // Final devoicing blurbs
        'k:final-devoicing:г': { 
          blurb: { 
            en: 'Word-final ⟨г⟩ is devoiced to /k/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨г⟩ en fin de mot se dévoise en /k/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        'p:final-devoicing:б': { 
          blurb: { 
            en: 'Word-final ⟨б⟩ is devoiced to /p/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨б⟩ en fin de mot se dévoise en /p/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        'f:final-devoicing:в': { 
          blurb: { 
            en: 'Word-final ⟨в⟩ is devoiced to /f/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨в⟩ en fin de mot se dévoise en /f/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        'fʲ:final-devoicing:в': { 
          blurb: { 
            en: 'Word-final soft ⟨в⟩ is devoiced to /fʲ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨в⟩ mou en fin de mot se dévoise en /fʲ/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        't:final-devoicing:д': { 
          blurb: { 
            en: 'Word-final ⟨д⟩ is devoiced to /t/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨д⟩ en fin de mot se dévoise en /t/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        'tʲ:final-devoicing:д': { 
          blurb: { 
            en: 'Word-final soft ⟨д⟩ is devoiced to /tʲ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨д⟩ mou en fin de mot se dévoise en /tʲ/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        's:final-devoicing:з': { 
          blurb: { 
            en: 'Word-final ⟨з⟩ is devoiced to /s/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨з⟩ en fin de mot se dévoise en /s/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        'sʲ:final-devoicing:з': { 
          blurb: { 
            en: 'Word-final soft ⟨з⟩ is devoiced to /sʲ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨з⟩ mou en fin de mot se dévoise en /sʲ/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        'ʃ:final-devoicing:ж': { 
          blurb: { 
            en: 'Word-final ⟨ж⟩ is devoiced to /ʃ/. In Russian, voiced obstruents at the end of a word or phrase become voiceless.',
            fr: '⟨ж⟩ en fin de mot se dévoise en /ʃ/. En russe, les obstruantes voisées en fin de mot ou de groupe deviennent sourdes.'
          }, 
          citation: 'p. 199', 
          notable: false 
        },
        
        // Regressive devoicing blurbs
        'f:regressive-devoicing:в': { 
          blurb: { 
            en: '⟨в⟩ is devoiced to /f/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant (e.g., ⟨завтра⟩ → /ˈzɑftrʌ/).',
            fr: '⟨в⟩ se dévoise en /f/ devant une consonne sourde. À l\'intérieur des mots russes, les obstruantes voisées s\'assimilent régressivement au voisement de la consonne suivante (p. ex. ⟨завтра⟩ → /ˈzɑftrʌ/).'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'p:regressive-devoicing:б': { 
          blurb: { 
            en: '⟨б⟩ is devoiced to /p/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨б⟩ se dévoise en /p/ devant une consonne sourde. À l\'intérieur des mots russes, les obstruantes voisées s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'k:regressive-devoicing:г': { 
          blurb: { 
            en: '⟨г⟩ is devoiced to /k/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨г⟩ se dévoise en /k/ devant une consonne sourde. À l\'intérieur des mots russes, les obstruantes voisées s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        't:regressive-devoicing:д': { 
          blurb: { 
            en: '⟨д⟩ is devoiced to /t/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨д⟩ se dévoise en /t/ devant une consonne sourde. À l\'intérieur des mots russes, les obstruantes voisées s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        's:regressive-devoicing:з': { 
          blurb: { 
            en: '⟨з⟩ is devoiced to /s/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨з⟩ se dévoise en /s/ devant une consonne sourde. À l\'intérieur des mots russes, les obstruantes voisées s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'ʃ:regressive-devoicing:ж': { 
          blurb: { 
            en: '⟨ж⟩ is devoiced to /ʃ/ before a voiceless consonant. Within Russian words, voiced obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨ж⟩ se dévoise en /ʃ/ devant une consonne sourde. À l\'intérieur des mots russes, les obstruantes voisées s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        // Regressive voicing blurbs
        'ɡ:regressive-voicing:к': { 
          blurb: { 
            en: '⟨к⟩ is voiced to /ɡ/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant (e.g., ⟨вокзал⟩ → /vɑɡˈzɑɫ/).',
            fr: '⟨к⟩ se voise en /ɡ/ devant une consonne voisée. À l\'intérieur des mots russes, les obstruantes sourdes s\'assimilent régressivement au voisement de la consonne suivante (p. ex. ⟨вокзал⟩ → /vɑɡˈzɑɫ/).'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'b:regressive-voicing:п': { 
          blurb: { 
            en: '⟨п⟩ is voiced to /b/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨п⟩ se voise en /b/ devant une consonne voisée. À l\'intérieur des mots russes, les obstruantes sourdes s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'd:regressive-voicing:т': { 
          blurb: { 
            en: '⟨т⟩ is voiced to /d/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨т⟩ se voise en /d/ devant une consonne voisée. À l\'intérieur des mots russes, les obstruantes sourdes s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'v:regressive-voicing:ф': { 
          blurb: { 
            en: '⟨ф⟩ is voiced to /v/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨ф⟩ se voise en /v/ devant une consonne voisée. À l\'intérieur des mots russes, les obstruantes sourdes s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'z:regressive-voicing:с': { 
          blurb: { 
            en: '⟨с⟩ is voiced to /z/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨с⟩ se voise en /z/ devant une consonne voisée. À l\'intérieur des mots russes, les obstruantes sourdes s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        'ʒ:regressive-voicing:ш': { 
          blurb: { 
            en: '⟨ш⟩ is voiced to /ʒ/ before a voiced consonant. Within Russian words, voiceless obstruents assimilate regressively to match the voicing of the following consonant.',
            fr: '⟨ш⟩ se voise en /ʒ/ devant une consonne voisée. À l\'intérieur des mots russes, les obstruantes sourdes s\'assimilent régressivement au voisement de la consonne suivante.'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        // Voicing assimilation blurbs
        'voicing:within-word': { 
          blurb: { 
            en: 'Within words, voiced and voiceless consonants assimilate regressively: a voiceless consonant becomes voiced before a voiced consonant (e.g., ⟨вокзал⟩ → /vɑɡˈzɑɫ/), and a voiced consonant becomes voiceless before a voiceless consonant (e.g., ⟨водка⟩ → /ˈvotkʌ/). Exception: ⟨в⟩ does not trigger voicing in preceding consonants (e.g., ⟨свет⟩ → /svʲɛt/, not */zvʲɛt/).',
            fr: 'À l\'intérieur des mots, les consonnes voisées et sourdes s\'assimilent régressivement : une consonne sourde devient voisée devant une consonne voisée (p. ex. ⟨вокзал⟩ → /vɑɡˈzɑɫ/), et une consonne voisée devient sourde devant une consonne sourde (p. ex. ⟨водка⟩ → /ˈvotkʌ/). Exception : ⟨в⟩ ne déclenche pas le voisement des consonnes qui le précèdent (p. ex. ⟨свет⟩ → /svʲɛt/, et non */zvʲɛt/).'
          }, 
          citation: 'pp. 215–221', 
          notable: false 
        },
        
        // CRITICAL: Updated voicing:cross-word with drawer inspector reference
        'voicing:cross-word': { 
          blurb: { 
            en: 'Voicing assimilation also operates across word boundaries within a single thought or phrase: a final consonant voices before an initial voiced consonant (e.g., ⟨ваш дом⟩ → /vaʒ dom/) or devoices before an initial voiceless consonant (e.g., ⟨год прошёл⟩ → /ɡot prɑˈʃoɫ/). As within words, ⟨в⟩ does not trigger voicing in preceding consonants. In <em>Ilya</em>, you can insert breaks in cross-word assimilation through the drawer inspector to mirror the composer\'s phrasing.',
            fr: 'L\'assimilation de voisement opère également à travers les frontières de mots au sein d\'un même groupe de souffle : une consonne finale se voise devant une consonne initiale voisée (p. ex. ⟨ваш дом⟩ → /vaʒ dom/) ou se dévoise devant une consonne initiale sourde (p. ex. ⟨год прошёл⟩ → /ɡot prɑˈʃoɫ/). Comme à l\'intérieur des mots, ⟨в⟩ ne déclenche pas le voisement des consonnes qui le précèdent. Dans <em>Ilya</em>, vous pouvez insérer des coupures dans l\'assimilation inter-mots via l\'inspecteur pour refléter le phrasé du compositeur.'
          }, 
          citation: 'pp. 248–254', 
          notable: false 
        },
        
        // Geminate blurb
        'ː:geminate': { 
          blurb: { 
            en: 'Geminate (doubled) consonants are pronounced with extended duration. Grayson describes this as "speaking the single consonant twice without any break in between" — a rearticulation rather than simply holding the sound longer. Notation using either doubled symbols (/nn/) or the length mark (/nː/) is acceptable; <em>Ilya</em> uses the length mark (e.g., ⟨ванна⟩ → /ˈvɑnːʌ/) to lessen visual clutter. Notable exception: the very common word ⟨русский⟩ and all of its declensions are pronounced with a single /s/, not a geminate: /ˈruskɨj/.',
            fr: 'Les consonnes géminées (doublées) se prononcent avec une durée prolongée. Grayson décrit cela comme « prononcer la consonne simple deux fois sans interruption » — une réarticulation plutôt qu\'un simple allongement. La notation avec symboles doublés (/nn/) ou avec la marque de longueur (/nː/) est acceptable ; <em>Ilya</em> utilise la marque de longueur (p. ex. ⟨ванна⟩ → /ˈvɑnːʌ/) pour réduire l\'encombrement visuel. Exception notable : le mot très courant ⟨русский⟩ et toutes ses déclinaisons se prononcent avec un simple /s/, et non une géminée : /ˈruskɨj/.'
          }, 
          citation: 'pp. 225–226, 233', 
          notable: true 
        },
        
        // Reflexive ending blurb
        'tːsʌ:reflexive:тся': { 
          blurb: { 
            en: 'The reflexive verb endings ⟨-тся⟩ and ⟨-ться⟩ are both pronounced /tːsʌ/. These clusters resemble the affricate ⟨ц⟩ (/ts/), but have an elongated stop on the /t/ portion (e.g., ⟨боится⟩ → /bɑˈitːsʌ/, ⟨купаться⟩ → /kuˈpɑtːsʌ/). The soft sign in ⟨-ться⟩ has no effect in this construct. Ignore it.',
            fr: 'Les terminaisons réfléchies ⟨-тся⟩ et ⟨-ться⟩ se prononcent toutes deux /tːsʌ/. Ces groupes ressemblent à l\'affriquée ⟨ц⟩ (/ts/), mais comportent une occlusion allongée sur le /t/ (p. ex. ⟨боится⟩ → /bɑˈitːsʌ/, ⟨купаться⟩ → /kuˈpɑtːsʌ/). Le signe mou dans ⟨-ться⟩ n\'a aucun effet ici. Ignorez-le.'
          }, 
          citation: 'pp. 237–238', 
          notable: true 
        },
        
        // Deletion cluster blurb
        'deletion:cluster': { 
          blurb: { 
            en: 'Certain consonant clusters contain "silent" letters that are not pronounced. Common examples: ⟨солнце⟩ → /ˈsontsɨ/ (⟨л⟩ silent), ⟨сердце⟩ → /ˈsʲertsɨ/ (⟨д⟩ silent), ⟨праздник⟩ → /ˈprazʲɲik/ (⟨д⟩ silent), ⟨чувство⟩ → /ˈtʃʲustvʌ/ (first ⟨в⟩ silent), ⟨здравствуйте⟩ → /ˈzdrastvujtʲe/ (first ⟨в⟩ silent).',
            fr: 'Certains groupes consonantiques contiennent des lettres « muettes » qui ne se prononcent pas. Exemples courants : ⟨солнце⟩ → /ˈsontsɨ/ (⟨л⟩ muet), ⟨сердце⟩ → /ˈsʲertsɨ/ (⟨д⟩ muet), ⟨праздник⟩ → /ˈprazʲɲik/ (⟨д⟩ muet), ⟨чувство⟩ → /ˈtʃʲustvʌ/ (premier ⟨в⟩ muet), ⟨здравствуйте⟩ → /ˈzdrastvujtʲe/ (premier ⟨в⟩ muet).'
          }, 
          citation: 'pp. 235–247', 
          notable: true 
        },
        
        // Hard sign legacy blurb
        'none:hard-sign:ъ': { 
          blurb: { 
            en: 'The hard sign ⟨ъ⟩ has no sound of its own. It serves as a visual boundary marker: the consonant before it stays hard, and a /j/ glide is articulated before the following vowel (e.g., ⟨съел⟩ → /sjɛɫ/). ⟨Ъ⟩ once appeared at the end of every Russian Cyrillic word ending in a hard consonant; these final hard signs were eliminated by post-1917 spelling reforms (<em>Ilya</em> silently removes them), but hard signs within words still work as described.',
            fr: 'Le signe dur ⟨ъ⟩ n\'a pas de son propre. Il sert de marqueur de frontière visuel : la consonne qui le précède reste dure, et une glissante /j/ s\'articule avant la voyelle suivante (p. ex. ⟨съел⟩ → /sjɛɫ/). ⟨Ъ⟩ apparaissait autrefois à la fin de chaque mot cyrillique russe terminé par une consonne dure ; ces signes durs finaux ont été éliminés par les réformes orthographiques postérieures à 1917 (<em>Ilya</em> les supprime silencieusement), mais les signes durs à l\'intérieur des mots fonctionnent toujours comme décrit.'
          }, 
          citation: 'pp. 192–194', 
          notable: false 
        },
        
        // Soft sign legacy blurb
        'ʲ:soft-sign:ь': { 
          blurb: { 
            en: 'The soft sign ⟨ь⟩ has no sound of its own, but it causes an obvious sound shift by palatalizing the preceding consonant. When followed by a vowel from the soft series (е, ё, ю, я), a /j/ glide is articulated between the palatalized consonant and the vowel (e.g., ⟨вьюга⟩ → /vʲˈjuɡʌ/). Note: the superscript [ʲ] (palatalization marker) and the baseline /j/ (palatal glide) are distinct symbols and not interchangeable.',
            fr: 'Le signe mou ⟨ь⟩ n\'a pas de son propre, mais il provoque un changement sonore évident en palatalisant la consonne précédente. Lorsqu\'il est suivi d\'une voyelle de la série molle (е, ё, ю, я), une glissante /j/ s\'articule entre la consonne palatalisée et la voyelle (p. ex. ⟨вьюга⟩ → /vʲˈjuɡʌ/). Remarque : l\'exposant [ʲ] (marqueur de palatalisation) et le /j/ sur la ligne de base (glissante palatale) sont des symboles distincts et non interchangeables.'
          }, 
          citation: 'pp. 195–198', 
          notable: false 
        }
      },
      
      // Derive rule name from transcriptionLog features
      // Expected softTrigger values:
      // - Soft vowels: 'е', 'ё', 'ю', 'я', 'и'
      // - Soft sign: 'ь'
      // - Regressive palatalization: 'regressive'
      deriveRule(features, char) {
        if (features.type === 'vowel') {
          // Check for exception rules first
          if (features.exception) return features.exception;
          
          // Stressed vowels
          if (features.position === 'stressed') {
            return features.interpalatal ? 'interpalatal' : 'stressed';
          }
          
          // Unstressed vowels
          // afterHard only applies to и and е (which become ɨ after ж/ш/ц)
          // а is unaffected by preceding hard consonants - it still follows position rules
          const lowerChar = char?.toLowerCase();
          if (features.afterHard && (lowerChar === 'и' || lowerChar === 'е')) return 'after-hard';
          if (features.position === 'pretonic') return 'pretonic';
          if (features.position === 'initial') return 'initial';
          if (features.position === 'posttonic-immediate') return 'post-stress-immediate';
          if (features.position === 'remote') return 'remote';
          return 'unstressed';
        }
        
        if (features.type === 'consonant') {
          const lowerChar = char?.toLowerCase();
          
          // Final devoicing takes precedence (v5.5.1)
          if (features.finalDevoicing) {
            return 'final-devoicing';
          }
          
          // Always-soft consonants (ч, щ)
          if (['ч', 'щ'].includes(lowerChar)) {
            return 'always-soft';
          }
          // Always-hard consonants (ж, ш, ц)
          if (['ж', 'ш', 'ц'].includes(lowerChar)) {
            return 'always-hard';
          }
          // Glide й
          if (lowerChar === 'й') {
            return 'glide';
          }
          // Soft consonants → 'soft'
          if (features.soft) {
            return 'soft';
          }
          // Hard consonants → 'hard'
          return 'hard';
        }
        
        if (features.type === 'sign') {
          return features.signType === 'soft' ? 'soft-sign' : 'hard-sign';
        }
        
        if (features.type === 'cluster') {
          return 'cluster';
        }
        
        return 'unknown';
      },
      
      // Look up blurb data for a transcriptionLog entry
      lookupBlurb(entry) {
        const { features, char, ipa } = entry;
        
        // Check for regressive devoicing assimilation (v5.10.20)
        if (features?.voicingAssimilation && features?.devoiced) {
          const key = `${ipa}:regressive-devoicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for regressive voicing assimilation (v5.10.21)
        if (features?.voicingAssimilation && features?.voiced) {
          const key = `${ipa}:regressive-voicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for final devoicing
        if (features?.finalDevoicing) {
          const key = `${ipa}:final-devoicing:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for genitive ending г → /v/ (Grayson p. 243)
        if (features?.genitiveEnding) {
          const key = `${ipa}:genitive:${char}`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for бог exception г → /x/ (Grayson p. 242)
        if (features?.bogException) {
          const key = `x:exception:бог`;
          if (this.blurbs[key]) {
            return this.blurbs[key];
          }
        }
        
        // Check for j-glide entries (v5.11.44)
        if (features?.type === 'glide' && ipa === 'j') {
          const source = features.source;
          const triggeredBy = features.triggeredBy || 'е';
          
          // Map source to blurb key
          if (source === 'ii-suffix') {
            const key = 'j:ii-suffix:и';
            if (this.blurbs[key]) {
              return this.blurbs[key];
            }
          } else if (source === 'after-vowel') {
            const key = `j:after-vowel:${triggeredBy}`;
            if (this.blurbs[key]) {
              return this.blurbs[key];
            }
          } else if (source === 'after-sign') {
            const key = `j:after-sign:${triggeredBy}`;
            if (this.blurbs[key]) {
              return this.blurbs[key];
            }
          }
          
          // Default j-glide blurb
          return {
            blurb: {
              en: 'The palatal glide /j/ precedes this vowel.',
              fr: 'La glissante palatale /j/ précède cette voyelle.'
            },
            citation: 'pp. 114–124',
            notable: false
          };
        }
        
        const rule = this.deriveRule(features, char);
        
        // Signs have empty IPA - key format is just 'rule:char' (e.g., 'soft-sign:ь')
        const key = ipa ? `${ipa}:${rule}:${char}` : `${rule}:${char}`;
        
        if (this.blurbs[key]) return this.blurbs[key];
        
        // Fallback for non-reducing vowels (у, ю, и, ы): try generic 'unstressed' or 'stressed'
        if (features?.type === 'vowel' && !this.blurbs[key]) {
          const fallbackRule = features.position === 'stressed' ? 'stressed' : 'unstressed';
          const fallbackKey = `${ipa}:${fallbackRule}:${char}`;
          if (this.blurbs[fallbackKey]) return this.blurbs[fallbackKey];
        }
        
        return {
          blurb: `${char} → ${ipa}`,
          citation: null,
          notable: false
        };
      },
      
      // Build display log with blurb data (memoizable)
      // Expands cluster entries into per-character rows for educational clarity
      buildDisplayLog(transcriptionLog) {
        // Cluster breakdowns for educational display
        // Maps cluster string to array of per-character entries
        const CLUSTER_BREAKDOWNS = {
          // Silent consonant clusters (Grayson pp. 235-236)
          'рдц': [
            { char: 'р', ipa: 'r', features: { type: 'consonant', soft: false } },
            { char: 'д', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'ц', ipa: 'ts', features: { type: 'consonant', soft: false, alwaysHard: true } }
          ],
          'лнц': [
            { char: 'л', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'н', ipa: 'n', features: { type: 'consonant', soft: false } },
            { char: 'ц', ipa: 'ts', features: { type: 'consonant', soft: false, alwaysHard: true } }
          ],
          'вств': [
            { char: 'в', ipa: '', features: { type: 'consonant', silent: true, deletionCluster: true } },
            { char: 'с', ipa: 's', features: { type: 'consonant', soft: false } },
            { char: 'т', ipa: 't', features: { type: 'consonant', soft: false } },
            { char: 'в', ipa: 'v', features: { type: 'consonant', soft: false } }
          ],
          // Geminate simplification (Grayson p. 233)
          'сс': [
            { char: 'с', ipa: 's', features: { type: 'consonant', soft: false } },
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, geminateSimplified: true } }
          ],
          // Assimilated clusters - TRUE MERGERS (Grayson pp. 230-231)
          // Both letters merge into ONE sound - use merged display
          'сч': {
            type: 'merged',
            mergedIpa: 'ʃʲʃʲ',
            members: [
              { char: 'с', features: { type: 'consonant', soft: true, clusterAssimilation: true } },
              { char: 'ч', features: { type: 'consonant', soft: true, alwaysSoft: true } }
            ]
          },
          'зч': {
            type: 'merged',
            mergedIpa: 'ʃʲʃʲ',
            members: [
              { char: 'з', features: { type: 'consonant', soft: true, clusterAssimilation: true } },
              { char: 'ч', features: { type: 'consonant', soft: true, alwaysSoft: true } }
            ]
          },
          // Sibilant mergers (Grayson pp. 235-236)
          'сш': [
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ш' } },
            { char: 'ш', ipa: 'ʃː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'зш': [
            { char: 'з', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ш', devoices: true } },
            { char: 'ш', ipa: 'ʃː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'сж': [
            { char: 'с', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ж', voices: true } },
            { char: 'ж', ipa: 'ʒː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          'зж': [
            { char: 'з', ipa: '', features: { type: 'consonant', silent: true, sibilantMerger: true, mergesInto: 'ж' } },
            { char: 'ж', ipa: 'ʒː', features: { type: 'consonant', soft: false, alwaysHard: true, receivesLength: true } }
          ],
          // Word-specific чн → шн (Grayson p. 239)
          'чн': [
            { char: 'ч', ipa: 'ʃ', features: { type: 'consonant', soft: false, clusterAssimilation: true } },
            { char: 'н', ipa: 'n', features: { type: 'consonant', soft: false } }
          ],
          // Word-specific чт → шт (Grayson p. 240)
          'чт': [
            { char: 'ч', ipa: 'ʃ', features: { type: 'consonant', soft: false, clusterAssimilation: true } },
            { char: 'т', ipa: 't', features: { type: 'consonant', soft: false } }
          ]
        };
        
        const expandedLog = [];
        
        transcriptionLog.forEach(entry => {
          // Check if this is a cluster that should be expanded
          if (entry.features?.type === 'cluster' && CLUSTER_BREAKDOWNS[entry.char]) {
            const breakdown = CLUSTER_BREAKDOWNS[entry.char];
            
            // Check if this is a "merged" cluster (both letters → one sound)
            if (breakdown.type === 'merged') {
              // Get the shared blurb for this merged cluster
              const clusterBlurb = this.lookupBlurb({
                char: entry.char,
                ipa: breakdown.mergedIpa,
                features: { type: 'cluster' }
              });
              
              breakdown.members.forEach((charEntry, idx) => {
                const isFirst = idx === 0;
                const isLast = idx === breakdown.members.length - 1;
                
                expandedLog.push({
                  char: charEntry.char,
                  ipa: isFirst ? breakdown.mergedIpa : '', // Only first row shows IPA
                  features: charEntry.features,
                  syllableIndex: entry.syllableIndex,
                  position: entry.position + idx,
                  // Cluster grouping metadata
                  clusterSource: entry.char,
                  clusterMerged: true,
                  clusterStart: isFirst,
                  clusterEnd: isLast,
                  clusterContinuation: !isFirst,
                  // Blurb only on first row (will be shared visually)
                  blurbData: isFirst ? clusterBlurb : { blurb: '', citation: null, notable: false }
                });
              });
            } else {
              // Standard array format (silent letter clusters, etc.)
              breakdown.forEach((charEntry, idx) => {
                expandedLog.push({
                  char: charEntry.char,
                  ipa: charEntry.ipa,
                  features: charEntry.features,
                  syllableIndex: entry.syllableIndex,
                  position: entry.position + idx,
                  // Mark as part of cluster for potential styling
                  clusterSource: entry.char,
                  blurbData: this.lookupClusterCharBlurb(charEntry, entry.char)
                });
              });
            }
          } else {
            // Regular entry, add blurb data
            expandedLog.push({
              ...entry,
              blurbData: this.lookupBlurb(entry)
            });
          }
        });
        
        return expandedLog;
      },
      
      // Look up blurb for a character within an expanded cluster
      lookupClusterCharBlurb(charEntry, clusterSource) {
        const { char, ipa, features } = charEntry;
        
        // Silent letters get the deletion:cluster blurb
        if (features.silent && features.deletionCluster) {
          return {
            blurb: `In the cluster ⟨${clusterSource}⟩, the letter ⟨${char}⟩ is silent and not pronounced. This is one of several consonant clusters in Russian where a letter is written but has no phonetic realization.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        // Geminate simplified
        if (features.silent && features.geminateSimplified) {
          return {
            blurb: `In ⟨русский⟩ and its declensions, the doubled ⟨сс⟩ is pronounced as a single /s/, not as a geminate. This is an exception to the normal geminate rule.`,
            citation: 'p. 233',
            notable: true
          };
        }
        
        // Cluster assimilation (сч, зч → щ sound)
        if (features.clusterAssimilation && clusterSource === 'сч') {
          return {
            blurb: `The cluster ⟨сч⟩ is pronounced like ⟨щ⟩: a long soft hushing sound /ʃʲʃʲ/. The ⟨с⟩ fully assimilates to match the following ⟨ч⟩.`,
            citation: 'pp. 230–231',
            notable: true
          };
        }
        
        if (features.clusterAssimilation && clusterSource === 'зч') {
          return {
            blurb: `The cluster ⟨зч⟩ is pronounced like ⟨щ⟩: a long soft hushing sound /ʃʲʃʲ/. The ⟨з⟩ fully assimilates to match the following ⟨ч⟩.`,
            citation: 'pp. 230–231',
            notable: true
          };
        }
        
        // Sibilant mergers (Grayson pp. 235-236)
        if (features.sibilantMerger) {
          const mergeTarget = features.mergesInto;
          const voiceChange = features.voices ? ' (voicing)' : features.devoices ? ' (devoicing)' : '';
          return {
            blurb: `The ⟨${char}⟩ merges completely into the following ⟨${mergeTarget}⟩${voiceChange}, lengthening it to /ʒː/ or /ʃː/.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        if (features.receivesLength) {
          return {
            blurb: `This ⟨${char}⟩ receives length from the preceding sibilant, producing a geminate /ʒː/ or /ʃː/.`,
            citation: 'pp. 235–236',
            notable: true
          };
        }
        
        // чн → шн assimilation
        if (features.clusterAssimilation && clusterSource === 'чн') {
          return {
            blurb: `In certain common words (⟨конечно⟩, ⟨скучно⟩, ⟨нарочно⟩, ⟨яичница⟩), the cluster ⟨чн⟩ is pronounced /ʃn/ rather than /tʃn/. This is a historical pronunciation retained in everyday speech.`,
            citation: 'p. 239',
            notable: true
          };
        }
        
        // чт → шт assimilation
        if (features.clusterAssimilation && clusterSource === 'чт') {
          return {
            blurb: `In ⟨что⟩, ⟨чтобы⟩, and ⟨ничто⟩, the cluster ⟨чт⟩ is pronounced /ʃt/ rather than /tʃt/. This is one of the most common pronunciation exceptions in Russian.`,
            citation: 'p. 240',
            notable: true
          };
        }
        
        // Default: look up regular blurb
        return this.lookupBlurb({ char, ipa, features });
      }
    };

    /* ========================================
       IPA TOKENIZER
       Parses IPA strings into draggable atomic units
       Affricates and palatalized consonants travel as single tokens
       ======================================== */
    const IpaTokenizer = {
      // Affricates that must travel as single units (longest first for matching)
      AFFRICATES: ['ʃtʃ', 'tʃ', 'ts', 'dʒ'],
      
      // IPA vowels (including variants)
      VOWELS: new Set([
        'a', 'ɑ', 'æ', 'e', 'ɛ', 'i', 'ɪ', 'o', 'ɔ', 'u', 'ʊ', 'ɨ', 'ə', 'ʌ'
      ]),
      
      // Modifiers that attach to preceding consonant
      MODIFIERS: new Set(['ʲ', 'ʷ', 'ˠ', 'ː']),
      
      // Check if character is a vowel
      isVowel(char) {
        return this.VOWELS.has(char);
      },
      
      /**
       * Tokenize an IPA string into atomic units
       * Each token: { symbol: string, isVowel: boolean, isGeminate: boolean }
       * 
       * Example: 'krɐsá' → ['k', 'r', 'ɐ', 's', 'á']
       * Example: 'vʲjotːsʌ' → ['vʲ', 'j', 'o', 'tː', 's', 'ʌ']
       * Example: 'tʃajtʃ' → ['tʃ', 'a', 'j', 'tʃ']
       */
      tokenize(ipa) {
        // Strip stress marks for tokenization (they stay with vowels)
        const clean = ipa.replace(/[ˈˌ]/g, '');
        const tokens = [];
        let i = 0;
        
        while (i < clean.length) {
          // Check for affricates first (longest match wins)
          let foundAffricate = false;
          for (const affricate of this.AFFRICATES) {
            if (clean.slice(i, i + affricate.length) === affricate) {
              let symbol = affricate;
              i += affricate.length;
              
              // Check for following modifiers (palatalization, length)
              while (i < clean.length && this.MODIFIERS.has(clean[i])) {
                symbol += clean[i];
                i++;
              }
              
              tokens.push({
                symbol,
                isVowel: false,
                isGeminate: symbol.includes('ː')
              });
              foundAffricate = true;
              break;
            }
          }
          if (foundAffricate) continue;
          
          // Check for vowels
          if (this.isVowel(clean[i])) {
            tokens.push({
              symbol: clean[i],
              isVowel: true,
              isGeminate: false
            });
            i++;
            continue;
          }
          
          // Consonant - collect following modifiers
          let symbol = clean[i];
          i++;
          
          while (i < clean.length && this.MODIFIERS.has(clean[i])) {
            symbol += clean[i];
            i++;
          }
          
          tokens.push({
            symbol,
            isVowel: false,
            isGeminate: symbol.includes('ː')
          });
        }
        
        return tokens;
      },
      
      /**
       * Parse tokens into onset/nucleus/coda structure
       * Returns: { onset: [...], nucleus: token, coda: [...] }
       */
      parseSegments(tokens) {
        const vowelIdx = tokens.findIndex(t => t.isVowel);
        
        if (vowelIdx === -1) {
          // No vowel (edge case - shouldn't happen in valid syllables)
          return { onset: tokens, nucleus: null, coda: [] };
        }
        
        return {
          onset: tokens.slice(0, vowelIdx),
          nucleus: tokens[vowelIdx],
          coda: tokens.slice(vowelIdx + 1)
        };
      },
      
      /**
       * Reconstruct IPA string from tokens
       */
      join(tokens) {
        return tokens.map(t => t.symbol).join('');
      }
    };

    /* ========================================
       BOUNDARY STACK
       Manages display-only syllable boundary offsets
       Source data is NEVER mutated - only cut points change
       ======================================== */
    const BoundaryStack = {
      // Storage: Map of wordId → array of boundary offsets
      // Positive offset = stole consonant from right
      // Negative offset = gave consonant to right
      _offsets: new Map(),
      
      /**
       * Get boundary offsets for a word (creates default if none)
       */
      getOffsets(wordId, syllableCount) {
        if (!this._offsets.has(wordId)) {
          // Default: all offsets are 0 (no adjustment)
          this._offsets.set(wordId, new Array(syllableCount).fill(0));
        }
        return this._offsets.get(wordId);
      },
      
      /**
       * Shift a boundary (move consonant between syllables)
       * direction: 'left' (steal from right) or 'right' (give to right)
       * boundaryIdx: which boundary (0 = between syl0 and syl1)
       */
      shiftBoundary(wordId, boundaryIdx, direction, syllableCount) {
        const offsets = this.getOffsets(wordId, syllableCount);
        
        if (direction === 'left') {
          offsets[boundaryIdx]++;  // Steal one consonant from right syllable
        } else {
          offsets[boundaryIdx]--;  // Give one consonant to right syllable
        }
        
        return offsets;
      },
      
      /**
       * Reset all boundaries for a word to default
       */
      reset(wordId) {
        this._offsets.delete(wordId);
      },
      
      /**
       * Check if word has any custom boundaries
       */
      hasCustomBoundaries(wordId) {
        const offsets = this._offsets.get(wordId);
        return offsets && offsets.some(o => o !== 0);
      },
      
      /**
       * Clear all stored offsets (session reset)
       */
      clearAll() {
        this._offsets.clear();
      },
      
      /**
       * Apply boundary offsets to render display syllables
       * Takes the original syllable data and returns adjusted display syllables
       * 
       * CRITICAL: This NEVER mutates source data
       * It only computes where to visually cut the token stream
       */
      applyOffsets(wordId, originalSyllables) {
        const syllableCount = originalSyllables.length;
        const offsets = this.getOffsets(wordId, syllableCount);
        
        // If no custom boundaries, return original
        if (!offsets.some(o => o !== 0)) {
          return originalSyllables;
        }
        
        // Flatten all syllables into one token stream (preserving order)
        const allTokens = [];
        const originalBoundaries = [0]; // Indices where each syllable starts
        
        originalSyllables.forEach((syl, idx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          if (idx > 0) {
            originalBoundaries.push(allTokens.length);
          }
          allTokens.push(...tokens);
        });
        originalBoundaries.push(allTokens.length); // End marker
        
        // Calculate adjusted boundaries
        const adjustedBoundaries = originalBoundaries.map((boundary, idx) => {
          if (idx === 0 || idx === originalBoundaries.length - 1) {
            return boundary; // First and last boundaries don't move
          }
          return boundary + offsets[idx - 1];
        });
        
        // Clamp boundaries to valid range
        for (let i = 1; i < adjustedBoundaries.length - 1; i++) {
          adjustedBoundaries[i] = Math.max(
            adjustedBoundaries[i - 1] + 1, // Must have at least 1 token
            Math.min(adjustedBoundaries[i], adjustedBoundaries[i + 1] - 1)
          );
        }
        
        // Build display syllables from adjusted boundaries
        const displaySyllables = [];
        for (let i = 0; i < syllableCount; i++) {
          const start = adjustedBoundaries[i];
          const end = adjustedBoundaries[i + 1];
          const tokens = allTokens.slice(start, end);
          
          displaySyllables.push({
            ...originalSyllables[i],
            ipa: IpaTokenizer.join(tokens),
            displayTokens: tokens,
            isModified: start !== originalBoundaries[i] || end !== originalBoundaries[i + 1]
          });
        }
        
        return displaySyllables;
      }
    };

    /* ========================================
       ======================================== */
    const DocumentState = {
      lines: [],
      userName: '',  // Empty = [unattributed] in footer; populated from localStorage on init
      metadata: {
        composer: '',
        composerDates: '',
        title: '',
        opus: '',
        poet: '',
        poetDates: ''
      },
      
      updateStress(lineIndex, wordIndex, newStress) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].stress = newStress;
          // Mark as user-verified when stress changes (v5.11.32)
          this.lines[lineIndex][wordIndex].stressSource = 'user';
        }
      },
      
      updateStressSource(lineIndex, wordIndex, source) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].stressSource = source;
        }
      },
      
      updateGloss(lineIndex, wordIndex, newGloss) {
        if (this.lines[lineIndex] && this.lines[lineIndex][wordIndex]) {
          this.lines[lineIndex][wordIndex].gloss = newGloss;
        }
      }
    };


    /* ========================================
       POPUP CONTROLLER (PROCESSING HELPER)
       Phase 3E: UI removed, kept for processing methods:
       - renderRibbon() - builds phoneme ribbon HTML
       - handleYoToggle() - ё/е reprocessing logic
       DrawerInspector delegates to these methods.
       ======================================== */
    const Popup = {
      isOpen: false,  // Always false now - UI removed
      currentWord: null,
      stressWasChanged: false,
      attributionSelected: false,
      elements: {},
      lastWordId: null,          // Track which word was last opened (v5.4.0)
      
      // Staging state for confirmation flow (v5.4.0)
      // Tracks pending changes that require explicit "Apply" to commit
      staged: {
        stressSource: null,  // 'composer' | 'user' | null
        boundary: null       // 'soft' | 'hard' | null
      },
      stagedAt: null,        // Timestamp for 5-minute auto-discard
      
      // Helper: check if any staged changes exist
      hasStaged() {
        return this.staged.stressSource !== null || this.staged.boundary !== null;
      },
      
      // Helper: clear all staged changes
      clearStaged() {
        this.staged.stressSource = null;
        this.staged.boundary = null;
        this.stagedAt = null;
      },
      
      // Helper: check if staged changes have expired (5 minutes)
      isStagedExpired() {
        if (!this.stagedAt) return false;
        const FIVE_MINUTES = 5 * 60 * 1000;
        return (Date.now() - this.stagedAt) > FIVE_MINUTES;
      },
      
      init() {
        this.elements = {
          overlay: document.getElementById('popupOverlay'),
          backdrop: document.getElementById('popupBackdrop'),
          card: document.getElementById('popupCard'),
          syllableLabel: document.getElementById('syllableLabel'),
          syllableDisplay: document.getElementById('syllableDisplay'),
          syllableDisplayHeader: document.getElementById('syllableDisplayHeader'),
          boundaryResetBtn: document.getElementById('boundaryResetBtn'),
          cyrillic: document.getElementById('popupCyrillic'),
          glossInline: document.getElementById('glossInline'),
          // REMOVED IN v5.5 REDESIGN: whyToggle, whyPanel, citationRule, citationRef
          // Refine Analysis disclosure (v5.5) - HIDDEN IN v5.11
          refineToggle: document.getElementById('refineAnalysisToggle'),
          refinePanel: document.getElementById('refinePanel'),
          cliticBadge: document.getElementById('cliticBadge'),
          cliticType: document.getElementById('cliticType'),
          whyCliticBanner: document.getElementById('whyCliticBanner'),
          // Compact modules (v5.4.2) - MOVING TO FLAT FOOTER IN v5.11
          stressSourceModule: document.getElementById('stressSourceModule'),
          stressStagedIndicator: document.getElementById('stressStagedIndicator'),
          stressSourceDictionary: document.getElementById('stressSourceDictionary'),
          stressSourceComposer: document.getElementById('stressSourceComposer'),
          stressSourceUser: document.getElementById('stressSourceUser'),
          phraseBoundaryModule: document.getElementById('phraseBoundaryModule'),
          boundaryStagedIndicator: document.getElementById('boundaryStagedIndicator'),
          boundaryLinked: document.getElementById('boundaryLinked'),
          boundarySeparated: document.getElementById('boundarySeparated'),
          // ё toggle module (v5.8) - OLD LOCATION
          yoToggleModule: document.getElementById('yoToggleModule'),
          yoCurrentForm: document.getElementById('yoCurrentForm'),
          yoToggleBtn: document.getElementById('yoToggleBtn'),
          yoToggleLabel: document.getElementById('yoToggleLabel'),
          yoWarning: document.getElementById('yoWarning'),
          // NEW: Footer controls (v5.11)
          variantRow: document.getElementById('variantRow'),
          variantYo: document.getElementById('variantYo'),
          variantYe: document.getElementById('variantYe'),
          assimilationRow: document.getElementById('assimilationRow'),
          nextWordLabel: document.getElementById('nextWordLabel'),
          assimilationLinked: document.getElementById('assimilationLinked'),
          assimilationSeparated: document.getElementById('assimilationSeparated'),
          yoToast: document.getElementById('yoToast'),
          yoUndoBtn: document.getElementById('yoUndoBtn'),
          // Shared commit footer (v5.4.2)
          sharedCommitFooter: document.getElementById('sharedCommitFooter'),
          sharedApplyBtn: document.getElementById('sharedApplyBtn'),
          sharedRevertBtn: document.getElementById('sharedRevertBtn'),
          // Phoneme Ribbon (v5.5 vertical layout)
          ribbonVertical: document.getElementById('ribbonVertical'),
          ribbonGrid: document.getElementById('ribbonVertical') // Alias for backward compatibility
        };
        
        this.elements.backdrop.addEventListener('click', () => this.close());
        
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.isOpen) {
            this.close();
          }
        });
        
        // REMOVED IN v5.5 REDESIGN: whyToggle click handler
        // Refine Analysis disclosure toggle (v5.5)
        this.elements.refineToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          this.elements.refineToggle.classList.toggle('expanded');
          this.elements.refinePanel.classList.toggle('expanded');
        });
        
        this.elements.glossInline.addEventListener('blur', () => {
          if (this.currentWord) {
            const newGloss = this.elements.glossInline.textContent.trim();
            DocumentState.updateGloss(this.currentWord.lineIndex, this.currentWord.wordIndex, newGloss);
            DrawerController.renderToPaper();
          }
        });
        
        this.elements.card.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        // Syllable button interaction: unified pointer handling (v5.11.27)
        // Distance-on-release: <10px = stress, 10-40px = cancel, >40px = drag
        // No separate click handler - all logic in pointerup
        if (this.elements.syllableDisplay) {
          // Drag handling for consonant boundary editing (v5.10.15, refactored v5.11.27)
          this._setupDragHandlers();
        }
        
        // Stress source segment handlers (v5.4.2)
        [this.elements.stressSourceDictionary, this.elements.stressSourceComposer, this.elements.stressSourceUser].forEach(btn => {
          if (btn) {
            btn.addEventListener('click', () => {
              this.stageStressSource(btn.dataset.source);
            });
          }
        });
        
        // Phrase boundary segment handlers (v5.4.2)
        [this.elements.boundaryLinked, this.elements.boundarySeparated].forEach(btn => {
          if (btn) {
            btn.addEventListener('click', () => {
              this.stageBoundary(btn.dataset.boundary);
            });
          }
        });
        
        // ё toggle button handler (v5.8) - OLD LOCATION
        if (this.elements.yoToggleBtn) {
          this.elements.yoToggleBtn.addEventListener('click', () => {
            this.handleYoToggle();
          });
        }
        
        // NEW: Variant row handlers (v5.11)
        if (this.elements.variantYo) {
          this.elements.variantYo.addEventListener('click', () => {
            this.handleVariantToggle('yo');
          });
        }
        if (this.elements.variantYe) {
          this.elements.variantYe.addEventListener('click', () => {
            this.handleVariantToggle('ye');
          });
        }
        
        // NEW: Assimilation row handlers (v5.11)
        if (this.elements.assimilationLinked) {
          this.elements.assimilationLinked.addEventListener('click', () => {
            this.handleAssimilationToggle('soft');
          });
        }
        if (this.elements.assimilationSeparated) {
          this.elements.assimilationSeparated.addEventListener('click', () => {
            this.handleAssimilationToggle('hard');
          });
        }
        
        // NEW: Toast undo handler (v5.11)
        if (this.elements.yoUndoBtn) {
          this.elements.yoUndoBtn.addEventListener('click', () => {
            this.undoYoToggle();
          });
        }
        
        // Shared commit footer handlers (v5.4.2)
        this.elements.sharedApplyBtn.addEventListener('click', () => {
          this.commitAllStaged();
        });
        
        this.elements.sharedRevertBtn.addEventListener('click', () => {
          this.revertAllStaged();
        });
      },
      
      // ========================================
      // STAGING PATTERN METHODS (v5.4.2)
      // Compact Modules with Shared Commit Bar
      // ========================================
      
      // Stage a stress source selection (visual only, no commit)
      stageStressSource(source) {
        if (!this.currentWord) return;
        
        // Get current committed value for comparison
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        const currentCommitted = word?.stressSource || 'dictionary';
        
        // If clicking the already-committed value, do nothing
        if (source === currentCommitted && !this.staged.stressSource) {
          return;
        }
        
        // If clicking the same staged value, treat as toggle off
        if (source === this.staged.stressSource) {
          this.staged.stressSource = null;
          this.updateAllUI();
          return;
        }
        
        // Stage the new selection
        this.staged.stressSource = source;
        this.stagedAt = Date.now();
        
        // Update visual state
        this.updateAllUI();
      },
      
      // Stage a boundary selection (visual only, no commit)
      stageBoundary(boundary) {
        if (!this.currentWord) return;
        
        // Get current committed value for comparison
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        const currentCommitted = word?.rightBoundary || 'soft';
        
        // If clicking the already-committed value, do nothing
        if (boundary === currentCommitted && !this.staged.boundary) {
          return;
        }
        
        // If clicking the same staged value, treat as toggle off
        if (boundary === this.staged.boundary) {
          this.staged.boundary = null;
          this.updateAllUI();
          return;
        }
        
        // Stage the new selection
        this.staged.boundary = boundary;
        this.stagedAt = Date.now();
        
        // Update visual state
        this.updateAllUI();
      },
      
      // Handle ё toggle (v5.8.1)
      // Switches between е and ё forms with crossfade animation
      handleYoToggle() {
        if (!this.currentWord) return;
        
        const lineIdx = this.currentWord.lineIndex;
        const wordIdx = this.currentWord.wordIndex;
        const word = DocumentState.lines[lineIdx]?.[wordIdx];
        if (!word) return;
        
        const currentCyrillic = word.cyrillic;
        const hasYo = currentCyrillic.includes('ё') || currentCyrillic.includes('Ё');
        const originalInput = word.originalInput;
        const dictionaryForm = word.dictionaryForm;
        
        let newCyrillic;
        let newYoSource;
        
        if (hasYo) {
          // Currently has ё — remove it (revert to original or convert ё→е)
          if (originalInput) {
            newCyrillic = originalInput;
          } else {
            newCyrillic = currentCyrillic.replace(/ё/, 'е').replace(/Ё/, 'Е');
          }
          newYoSource = 'user-yo-edit';
        } else if (dictionaryForm) {
          // Has е, dictionary form available — restore ё
          newCyrillic = dictionaryForm;
          newYoSource = 'yo-restored';
        } else {
          // Has е, no dictionary — add ё to first е
          newCyrillic = currentCyrillic.replace(/е/, 'ё').replace(/Е/, 'Ё');
          newYoSource = 'user-yo-edit';
        }
        
        // Update DocumentState
        word.cyrillic = newCyrillic;
        word.yoSource = newYoSource;
        
        // Check if new form has ё (for stress locking)
        const newHasYo = newCyrillic.includes('ё') || newCyrillic.includes('Ё');
        word.hasYo = newHasYo;
        
        // Re-run stress assignment
        if (newHasYo) {
          const yoSyllable = GraysonEngine.findYoSyllable(newCyrillic);
          if (yoSyllable !== -1) {
            word.stress = yoSyllable;
            word.stressSource = newYoSource;
          }
        } else {
          const lookup = GraysonEngine.lookupStress(newCyrillic);
          if (lookup) {
            word.stress = lookup.stress;
            word.stressSource = lookup.source;
          } else {
            word.stress = 0;
            word.stressSource = 'default';
          }
        }
        
        // Crossfade: fade out popup content
        const popupBody = this.elements.card.querySelector('.popup-body');
        popupBody?.classList.add('fading');
        
        // After brief fade, re-render and refresh popup in place
        setTimeout(() => {
          // Re-render the paper
          DrawerController.renderToPaper();
          
          // Find the new word stack element and update currentWord reference
          const wordStacks = document.querySelectorAll('.word-stack');
          let newElement = null;
          wordStacks.forEach(stack => {
            if (stack.dataset.lineIndex === String(lineIdx) && 
                stack.dataset.wordIndex === String(wordIdx)) {
              newElement = stack;
            }
          });
          
          if (newElement) {
            // Build fresh wordData from the new element
            const freshWordData = {
              element: newElement,
              lineIndex: lineIdx,
              wordIndex: wordIdx,
              cyrillic: newElement.dataset.cyrillic,
              ipa: newElement.dataset.ipa,
              gloss: newElement.dataset.gloss,
              syllables: JSON.parse(newElement.dataset.syllables || '[]'),
              isProclitic: newElement.dataset.isProclitic,
              isEnclitic: newElement.dataset.isEnclitic,
              hasYo: newElement.dataset.hasYo,
              stressSource: newElement.dataset.stressSource,
              rightBoundary: newElement.dataset.rightBoundary,
              boundarySource: newElement.dataset.boundarySource,
              originalInput: newElement.dataset.originalInput,
              dictionaryForm: newElement.dataset.dictionaryForm,
              yoSource: newElement.dataset.yoSource
            };
            
            // Update currentWord reference
            this.currentWord = freshWordData;
            
            // Refresh popup content in place
            this.refreshPopupContent(freshWordData);
          }
          
          // Fade back in
          popupBody?.classList.remove('fading');
          
          // Return focus to toggle button
          this.elements.yoToggleBtn?.focus();
        }, 80); // Match fade-out duration
      },
      
      // Refresh popup content without closing (v5.8.1)
      refreshPopupContent(wordData) {
        // Update IPA and Cyrillic displays
        const syllabifiedCyrillic = wordData.syllables.map(s => 
          s.isStressed ? addAcuteToSyllable(s.cyrillic) : s.cyrillic
        ).join(' ');
        const syllabifiedIPA = wordData.syllables.map((s, idx) => {
          const stressedIdx = wordData.syllables.findIndex(syl => syl.isStressed);
          return idx === stressedIdx ? 'ˈ' + s.ipa : s.ipa;
        }).join(' ');
        
        this.elements.cyrillic.textContent = syllabifiedCyrillic;
        
        // Update syllable buttons (now the primary IPA display)
        // Apply any existing boundary customizations (v5.10.23)
        const wordId = `${wordData.lineIndex}-${wordData.wordIndex}`;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, wordData.syllables);
        
        const hasYo = wordData.hasYo === 'true' || wordData.hasYo === true;
        const syllableCount = displaySyllables.length;
        const buttonsDisabled = hasYo && syllableCount > 1;
        
        this.elements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" data-syllable-index="${idx}" ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}</button>`
        ).join('');
        
        // Show customized state and register reset handler if boundaries were adjusted (v5.10.23)
        this._updateCustomizedState();
        
        // Update stress source module visibility (locked when monosyllable or ё)
        const stressLocked = syllableCount === 1 || hasYo;
        this.elements.stressSourceModule.style.display = stressLocked ? 'none' : 'block';
        
        // Refresh ё toggle module
        this.populateYoToggle(wordData);
        
        // Refresh Phoneme Ribbon
        this.renderRibbon(wordData);
      },
      
      // Commit ALL staged changes (shared footer)
      commitAllStaged() {
        if (!this.currentWord) return;
        
        // Commit stress source if staged
        if (this.staged.stressSource) {
          DocumentState.updateStressSource(
            this.currentWord.lineIndex,
            this.currentWord.wordIndex,
            this.staged.stressSource
          );
          this.attributionSelected = true;
        }
        
        // Commit boundary if staged
        if (this.staged.boundary) {
          const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
          if (word && word.boundarySource !== 'punctuation') {
            word.rightBoundary = this.staged.boundary;
            word.boundarySource = 'user';
            this.currentWord.rightBoundary = this.staged.boundary;
            this.currentWord.boundarySource = 'user';
          }
        }
        
        // Clear staged state
        this.clearStaged();
        
        // Re-render to apply changes
        DrawerController.renderToPaper();
        
        // Update visual state
        this.updateAllUI();
      },
      
      // Revert ALL staged changes (shared footer)
      revertAllStaged() {
        this.clearStaged();
        this.updateAllUI();
      },
      
      // Update all UI elements based on current state
      updateAllUI() {
        this.updateStressSourceUI();
        this.updateBoundaryUI();
        this.updateSharedFooterUI();
      },
      
      // Update stress source segment visual states
      updateStressSourceUI() {
        const word = DocumentState.lines[this.currentWord?.lineIndex]?.[this.currentWord?.wordIndex];
        const committedSource = word?.stressSource || 'dictionary';
        const stagedSource = this.staged.stressSource;
        
        // Update segment classes
        const segments = [
          this.elements.stressSourceDictionary,
          this.elements.stressSourceComposer,
          this.elements.stressSourceUser
        ];
        
        segments.forEach(btn => {
          if (!btn) return;
          const btnSource = btn.dataset.source;
          
          // Remove all state classes
          btn.classList.remove('active', 'staged', 'committed');
          
          if (btnSource === stagedSource) {
            // This option is staged (pending)
            btn.classList.add('staged');
          } else if (btnSource === committedSource) {
            // This option is committed (saved)
            btn.classList.add(committedSource === 'dictionary' ? 'active' : 'committed');
          }
        });
        
        // Show/hide pencil indicator
        if (this.elements.stressStagedIndicator) {
          this.elements.stressStagedIndicator.classList.toggle('visible', stagedSource !== null);
        }
      },
      
      // Update boundary segment visual states
      updateBoundaryUI() {
        const word = DocumentState.lines[this.currentWord?.lineIndex]?.[this.currentWord?.wordIndex];
        const committedBoundary = word?.rightBoundary || 'soft';
        const stagedBoundary = this.staged.boundary;
        
        const segments = [
          this.elements.boundaryLinked,
          this.elements.boundarySeparated
        ];
        
        segments.forEach(btn => {
          if (!btn) return;
          const btnBoundary = btn.dataset.boundary;
          
          // Remove all state classes
          btn.classList.remove('active', 'staged', 'committed');
          
          if (btnBoundary === stagedBoundary) {
            btn.classList.add('staged');
          } else if (btnBoundary === committedBoundary) {
            btn.classList.add('active');
          }
        });
        
        // Show/hide pencil indicator
        if (this.elements.boundaryStagedIndicator) {
          this.elements.boundaryStagedIndicator.classList.toggle('visible', stagedBoundary !== null);
        }
      },
      
      // Update shared commit footer visibility
      updateSharedFooterUI() {
        const hasChanges = this.hasStaged();
        if (this.elements.sharedCommitFooter) {
          this.elements.sharedCommitFooter.classList.toggle('has-changes', hasChanges);
        }
      },
      
      selectAttribution(source) {
        // Legacy method - redirect to new staging approach
        this.stageStressSource(source);
      },
      
      clearAttributionSelection() {
        // Legacy method - clear staged
        this.staged.stressSource = null;
        this.updateAllUI();
      },
      
      generateCitation(wordData) {
        const ipa = wordData.ipa || '';
        const cyrillic = (wordData.cyrillic || '').toLowerCase();
        const syllables = wordData.syllables || [];
        const isProclitic = wordData.isProclitic === 'true';
        const isEnclitic = wordData.isEnclitic === 'true';
        const isO_Interjection = wordData.isO_Interjection === 'true' || wordData.isO_Interjection === true;
        const hasYo = wordData.hasYo === 'true' || wordData.hasYo === true || cyrillic.includes('ё');
        const syllableCount = syllables.length;
        
        // Check for ё first (always stressed)
        if (hasYo && syllableCount > 1) {
            return {
                rule: 'The letter ё always indicates stress. Stress position is fixed.',
                ref: 'Grayson §2.3'
            };
        }
        
        // Check for О interjection (punctuation signals exclamation, not preposition)
        if (isO_Interjection) {
            return {
                rule: '"О" here is an interjection (Oh!), not a preposition. Unlike proclitics, interjections are standalone exclamations that keep their full stress → /o/.',
                ref: 'Context'
            };
        }

        // Check for monosyllables
        if (syllableCount === 1) {
            if (isProclitic) {
                const procliticPosition = wordData.procliticPosition;
                // Check if this is sentence-initial О in a question (interrogative preposition)
                const isFirstWord = wordData.isFirstWord === 'true' || wordData.isFirstWord === true;
                const lineEndsWithQuestion = wordData.lineEndsWithQuestion === 'true' || wordData.lineEndsWithQuestion === true;
                const isInterrogativeO = cyrillic === 'о' && isFirstWord && lineEndsWithQuestion;
                
                // Special explanation for о as preposition
                if (cyrillic === 'о') {
                    if (isInterrogativeO) {
                        // Interrogative preposition: "О чём ты думаешь?"
                        if (procliticPosition === 'pretonic') {
                            return {
                                rule: '"О" here is an interrogative preposition (about what?), not an interjection. As a proclitic, it loses its stress and attaches to the following word. Host stress on first syllable → /ɑ/.',
                                ref: 'Grayson §7.1'
                            };
                        } else {
                            return {
                                rule: '"О" here is an interrogative preposition (about what?), not an interjection. As a proclitic, it loses its stress and attaches to the following word. Remote from host stress → /ʌ/.',
                                ref: 'Grayson §7.1'
                            };
                        }
                    }
                    // Regular preposition: "думаю о маме"
                    if (procliticPosition === 'pretonic') {
                        return {
                            rule: '"О" is a preposition (about). As a proclitic, it loses its stress and attaches phonologically to the following word. Host stress on first syllable → immediate pretonic /ɑ/.',
                            ref: 'Grayson §7.1'
                        };
                    } else {
                        return {
                            rule: '"О" is a preposition (about). As a proclitic, it loses its stress and attaches phonologically to the following word. Remote from host stress → maximum reduction /ʌ/.',
                            ref: 'Grayson §7.1'
                        };
                    }
                }
                // General proclitic explanation
                if (procliticPosition === 'pretonic') {
                    return {
                        rule: 'Proclitic: a function word that loses its stress and attaches phonologically to the following word. Host stress on first syllable → immediate pretonic reduction.',
                        ref: 'Grayson §7.1'
                    };
                }
                return {
                    rule: 'Proclitic: a function word that loses its stress and attaches phonologically to the following word. Remote from host stress → maximum reduction.',
                    ref: 'Grayson §7.1'
                };
            }
            if (isEnclitic) {
                return {
                    rule: 'Enclitic: a function word that loses its stress and attaches phonologically to the preceding word. Unstressed vowel reduces.',
                    ref: 'Grayson §7.1'
                };
            }
            // Check for ё monosyllable
            if (hasYo) {
                return {
                    rule: 'The letter ё always indicates stress.',
                    ref: 'Grayson §2.3'
                };
            }
            // Check if it has stress marked
            const hasStress = syllables.some(s => s.isStressed);
            if (hasStress) {
                return {
                    rule: 'Stressed monosyllable — vowel receives full phonetic value.',
                    ref: 'Grayson §3.1'
                };
            }
            return {
                rule: 'Monosyllable — stress context determines vowel quality.',
                ref: 'Grayson §7.1'
            };
        }
        
        // Multi-syllable words: analyze the IPA for reduction patterns
        // Priority order: most specific/interesting rule first
        
        // Check for ɑ from о-reduction (akanye)
        if (ipa.includes('ɑ') && cyrillic.includes('о')) {
            return {
                rule: 'Unstressed /о/ reduces to [ɑ] in immediate pretonic position',
                ref: 'Grayson §3.2'
            };
        }
        
        // Check for ʌ (remote reduction)
        if (ipa.includes('ʌ')) {
            return {
                rule: 'Unstressed vowel reduces to [ʌ] in remote positions',
                ref: 'Grayson §3.3'
            };
        }
        
        // Check for ɪ from е/я reduction (ikanye)
        if (ipa.includes('ɪ') && (cyrillic.includes('е') || cyrillic.includes('я'))) {
            return {
                rule: 'Unstressed /е/ or /я/ reduces to [ɪ]',
                ref: 'Grayson §3.2'
            };
        }
        
        // Check for palatalization
        if (ipa.includes('ʲ')) {
            return {
                rule: 'Consonant palatalized before soft sign or front vowel',
                ref: 'Grayson §4.2'
            };
        }
        
        // Check for й (j-glide)
        if (ipa.includes('j') && (cyrillic.includes('е') || cyrillic.includes('ё') || cyrillic.includes('ю') || cyrillic.includes('я'))) {
            return {
                rule: 'Iotated vowel produces [j] glide',
                ref: 'Grayson §3.6'
            };
        }
        
        // Default: stressed vowel rule
        return {
            rule: 'Stressed vowel receives full phonetic value',
            ref: 'Grayson §3.1'
        };
    },
    
      // Render Phoneme Ribbon - Vertical Layout (v5.5)
      // Content First redesign: educational ribbon always visible
      // Phase 3C: Added optional targetContainer param for drawer reuse
      renderRibbon(wordData, targetContainer = null) {
        const container = targetContainer || this.elements.ribbonVertical;
        if (!container) return;
        
        const log = wordData.transcriptionLog || [];
        if (log.length === 0) {
          container.innerHTML = '<div style="color: var(--ink-tertiary); font-size: 0.85rem; padding: 1rem; text-align: center;">No transcription data available</div>';
          return;
        }
        
        // Build displayLog with blurb data (memoized per Kimi's optimization)
        const displayLog = RuleRegistry.buildDisplayLog(log);
        
        // Get boundary-adjusted syllables (v5.10.25)
        const wordId = `${wordData.lineIndex}-${wordData.wordIndex}`;
        const originalSyllables = wordData.syllables;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, originalSyllables);
        const hasCustomBoundaries = BoundaryStack.hasCustomBoundaries(wordId);
        
        // Recalculate syllable assignments if boundaries were adjusted
        let adjustedDisplayLog = displayLog;
        if (hasCustomBoundaries) {
          adjustedDisplayLog = this._recalculateSyllableIndices(displayLog, originalSyllables, displaySyllables);
        }
        
        // Group by (adjusted) syllable
        const syllableGroups = new Map();
        adjustedDisplayLog.forEach(entry => {
          const sylIdx = entry.adjustedSyllableIndex ?? entry.syllableIndex ?? 0;
          if (!syllableGroups.has(sylIdx)) {
            syllableGroups.set(sylIdx, []);
          }
          syllableGroups.get(sylIdx).push(entry);
        });
        
        // Get stressed syllable index
        const syllables = wordData.syllables;
        const stressedIdx = syllables.findIndex(s => s.isStressed);
        
        // Build vertical ribbon HTML
        let html = '';
        let isFirstSyllable = true;
        
        // Clitic detection (v6.0.17 - arrows replace tie bar)
        const isProclitic = wordData.isProclitic === 'true' || wordData.isProclitic === true;
        const isEnclitic = wordData.isEnclitic === 'true' || wordData.isEnclitic === true;
        
        // Proclitic blurb (approved by Dann, Feb 3 2026)
        const procliticBlurb = `Some short words — prepositions like "в" and "на," the negation "не" — don't carry their own stress. Instead, they lean forward and attach to the word that follows, forming a single unit of pronunciation. Voicing and palatalization flow right through the boundary as if it were one word. The arrow marks this forward binding.`;
        const procliticCitation = `Grayson (2012), pp. 248–255`;
        
        // Enclitic blurb (approved by Dann, Feb 3 2026)
        const encliticBlurb = `Certain particles — "ли" (question), "же" (emphasis), "бы" (conditional) — attach backward to the word before them. They're unstressed and form a single phonological unit with their host. The same assimilation rules apply across this bond as within any word. The arrow marks this backward binding.`;
        const encliticCitation = `Grayson (2012), pp. 248–255`;
        
        syllableGroups.forEach((entries, sylIdx) => {
          const isStressed = sylIdx === stressedIdx;
          
          // Wrap stressed syllable in tinted region
          if (isStressed) {
            html += `<div class="stressed-syllable-region">`;
          }
          
          // Process entries, grouping merged clusters with two-layer architecture (v5.11.30)
          let i = 0;
          while (i < entries.length) {
            const entry = entries[i];
            const blurb = entry.blurbData;
            const isFirstInSyllable = i === 0;
            const syllableStart = isFirstInSyllable && !isFirstSyllable && !isStressed;
            const isSilent = entry.features?.silent || entry.ipa === '';
            
            // Check if this starts a merged cluster
            if (entry.clusterMerged && entry.clusterStart) {
              // Collect all cluster members
              const clusterMembers = [entry];
              let j = i + 1;
              while (j < entries.length && entries[j].clusterSource === entry.clusterSource) {
                clusterMembers.push(entries[j]);
                j++;
              }
              
              // Generate unique ID for this cluster group
              const clusterId = `cluster-${entry.clusterSource}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
              
              // Build cluster orthography string for aria-label
              const clusterOrthography = clusterMembers.map(m => m.char).join('');
              
              // Render cluster group with two-layer architecture (v5.11.31)
              // Per Kimi: rubric always visible, details accordion below
              const syllableAttr = syllableStart ? ' data-syllable-start="true"' : '';
              html += `
                <div class="cluster-group" id="${clusterId}"${syllableAttr}
                     role="group"
                     aria-label="Consonant cluster: ${clusterOrthography}"
                     aria-expanded="false"
                     data-cluster-ipa="${entry.ipa}"
                     data-cluster-source="${entry.clusterSource}">
                  <div class="cluster-perimeter" 
                       tabindex="0" 
                       role="button"
                       aria-label="Show details for ${clusterOrthography} cluster"></div>
                  ${clusterMembers.map(m => `
                    <div class="phoneme-row cluster-member"
                         data-cluster-id="${clusterId}">
                      <div class="phoneme-mapping">
                        <span class="phoneme-cyr">${m.char}</span>
                        <span class="phoneme-arrow">›</span>
                        <span class="phoneme-ipa">${entry.ipa}</span>
                      </div>
                    </div>
                  `).join('')}
                  <div class="cluster-overlay-container">
                    <div class="cluster-rubric-row">
                      <div class="cluster-connector"></div>
                      <div class="cluster-rubric" role="button" tabindex="0">
                        <span class="cluster-formula-ortho">${clusterOrthography}</span>
                        <span class="cluster-formula-arrow">→</span>
                        <span class="cluster-formula-ipa">/${entry.ipa}/</span>
                      </div>
                    </div>
                    <div class="cluster-details">
                      <div class="cluster-details-content">
                        <div class="cluster-blurb-text">${extractBlurbText(blurb)}</div>
                        ${blurb.citation ? `<div class="cluster-blurb-citation">${blurb.citation}</div>` : ''}
                      </div>
                    </div>
                  </div>
                </div>
              `;
              
              // Skip past all cluster members
              i = j;
              continue;
            }
            
            // Regular entry (non-cluster)
            let rowClasses = 'phoneme-row';
            if (isSilent) rowClasses += ' silent-letter';
            
            const syllableAttr = syllableStart ? ' data-syllable-start="true"' : '';
            const ipaDisplay = isSilent ? '[silent]' : (entry.ipa || '∅');
            
            html += `
              <div class="${rowClasses}"${syllableAttr}
                   tabindex="0"
                   role="button"
                   aria-expanded="false"
                   aria-label="${entry.char} becomes ${entry.ipa || 'nothing'}">
                <div class="phoneme-mapping">
                  <span class="phoneme-cyr">${entry.char}</span>
                  <span class="phoneme-arrow">›</span>
                  <span class="phoneme-ipa">${ipaDisplay}</span>
                </div>
                <div class="phoneme-blurb-overlay">
                  <div class="blurb-text">${extractBlurbText(blurb)}</div>
                  ${blurb.citation ? `<div class="blurb-citation">${blurb.citation}</div>` : ''}
                </div>
              </div>
            `;
            
            i++;
          }
          
          if (isStressed) {
            html += `</div>`;
          }
          
          isFirstSyllable = false;
        });
        
        // Clitic arrow at END of ribbon (v6.0.17 - replaces tie bar)
        // Proclitic: → points forward to host
        // Enclitic: ← points backward to host
        if (isProclitic) {
          html += `
            <div class="phoneme-row clitic-arrow-row" 
                 tabindex="0"
                 role="button"
                 aria-expanded="false"
                 aria-label="Proclitic - this word attaches to the next">
              <div class="phoneme-mapping">
                <span class="arrow-symbol">→</span>
                <span class="arrow-label">proclitic</span>
              </div>
              <div class="phoneme-blurb-overlay">
                <div class="blurb-text">${procliticBlurb}</div>
                <div class="blurb-citation">${procliticCitation}</div>
              </div>
            </div>
          `;
        }
        
        if (isEnclitic) {
          html += `
            <div class="phoneme-row clitic-arrow-row" 
                 tabindex="0"
                 role="button"
                 aria-expanded="false"
                 aria-label="Enclitic - this word attaches to the previous">
              <div class="phoneme-mapping">
                <span class="arrow-symbol">←</span>
                <span class="arrow-label">enclitic</span>
              </div>
              <div class="phoneme-blurb-overlay">
                <div class="blurb-text">${encliticBlurb}</div>
                <div class="blurb-citation">${encliticCitation}</div>
              </div>
            </div>
          `;
        }
        
        // Add backdrop at end (positioned via CSS)
        html += `<div class="ribbon-backdrop"></div>`;
        
        container.innerHTML = html;
        
        // Event delegation for floating overlay (v5.5)
        // Updated v5.11.31: Universal click-outside dismiss, cluster rubric always visible
        // Only attach once per container to avoid stacking handlers
        if (!container._ribbonListenerAttached) {
          container._ribbonListenerAttached = true;
          
          container.addEventListener('click', (e) => {
            const row = e.target.closest('.phoneme-row:not(.cluster-member)');
            const clusterGroup = e.target.closest('.cluster-group');
            const clusterPerimeter = e.target.closest('.cluster-perimeter');
            const clusterRubric = e.target.closest('.cluster-rubric');
            const clusterDetails = e.target.closest('.cluster-details');
            const phonemeBlurb = e.target.closest('.phoneme-blurb-overlay');
            const backdrop = container.querySelector('.ribbon-backdrop');
            
            // UNIVERSAL DISMISS: Close any open popup if clicking outside its content
            const activeRow = container.querySelector('.phoneme-row.expanded');
            const activeCluster = container.querySelector('.cluster-group.active');
            
            // If clicking inside an open phoneme blurb, do nothing (let user read)
            if (phonemeBlurb && activeRow) {
              return;
            }
            
            // If clicking inside cluster details, do nothing (let user read)
            if (clusterDetails && activeCluster) {
              return;
            }
            
            // Close active phoneme blurb if clicking anywhere else
            if (activeRow && !row?.classList.contains('expanded')) {
              activeRow.classList.remove('expanded');
              activeRow.setAttribute('aria-expanded', 'false');
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            }
            
            // Close active cluster if clicking outside the cluster region entirely
            if (activeCluster && !clusterGroup) {
              activeCluster.classList.remove('active');
              activeCluster.setAttribute('aria-expanded', 'false');
            }
            
            // Handle cluster clicks (perimeter, rubric, or connector area)
            if (clusterGroup && (clusterPerimeter || clusterRubric)) {
              e.stopPropagation();
              
              const wasActive = clusterGroup.classList.contains('active');
              
              // Close any other active cluster
              container.querySelectorAll('.cluster-group.active').forEach(c => {
                if (c !== clusterGroup) {
                  c.classList.remove('active');
                  c.setAttribute('aria-expanded', 'false');
                }
              });
              
              // Toggle clicked cluster group
              if (wasActive) {
                clusterGroup.classList.remove('active');
                clusterGroup.setAttribute('aria-expanded', 'false');
              } else {
                clusterGroup.classList.add('active');
                clusterGroup.setAttribute('aria-expanded', 'true');
              }
              return;
            }
            
            // Handle regular row clicks
            if (!row) return;
            
            // Dismiss toast on phoneme interaction (v5.11.47 lifecycle)
            this.hideYoToast();
            
            e.stopPropagation();
            const wasExpanded = row.classList.contains('expanded');
            
            // Toggle clicked row
            if (wasExpanded) {
              row.classList.remove('expanded');
              row.setAttribute('aria-expanded', 'false');
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            } else {
              row.classList.add('expanded');
              row.setAttribute('aria-expanded', 'true');
              container.classList.add('has-active-blurb');
              backdrop?.classList.add('active');
            }
          });
          
          // Keyboard accessibility (cluster perimeter/rubric + regular rows)
          container.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              const row = e.target.closest('.phoneme-row:not(.cluster-member)');
              const perimeter = e.target.closest('.cluster-perimeter');
              const rubric = e.target.closest('.cluster-rubric');
              
              if (perimeter || rubric) {
                e.preventDefault();
                (perimeter || rubric).click();
              } else if (row) {
                e.preventDefault();
                row.click();
              }
            }
            // Escape to close
            if (e.key === 'Escape') {
              const backdrop = container.querySelector('.ribbon-backdrop');
              container.querySelectorAll('.phoneme-row.expanded, .cluster-group.active').forEach(r => {
                r.classList.remove('expanded');
                r.classList.remove('active');
                r.setAttribute('aria-expanded', 'false');
              });
              container.classList.remove('has-active-blurb');
              backdrop?.classList.remove('active');
            }
            
            // Phase 4D: Arrow key navigation through ribbon rows
            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
              const focusableRows = [...container.querySelectorAll('.phoneme-row:not(.cluster-member), .cluster-group, .clitic-arrow-row')];
              const currentIdx = focusableRows.findIndex(row => row.contains(e.target) || row === e.target);
              
              if (currentIdx === -1) return;
              
              e.preventDefault();
              let nextIdx;
              if (e.key === 'ArrowDown') {
                nextIdx = Math.min(currentIdx + 1, focusableRows.length - 1);
              } else {
                nextIdx = Math.max(currentIdx - 1, 0);
              }
              
              const nextRow = focusableRows[nextIdx];
              if (nextRow) {
                // For cluster groups, focus the perimeter or rubric
                const focusTarget = nextRow.querySelector('.cluster-perimeter, .cluster-rubric') || nextRow;
                focusTarget.focus();
                // Scroll into view if needed
                focusTarget.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
              }
            }
          });
        }
      },
      
      /**
       * Recalculate syllable indices for ribbon entries based on boundary adjustments (v5.10.25)
       * Maps each log entry to its new display syllable based on IPA token positions
       */
      _recalculateSyllableIndices(displayLog, originalSyllables, displaySyllables) {
        // Build mapping: cumulative IPA token position → new syllable index
        // First, calculate original token ranges for each syllable
        const originalRanges = [];
        let tokenOffset = 0;
        originalSyllables.forEach((syl, sylIdx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          originalRanges.push({
            start: tokenOffset,
            end: tokenOffset + tokens.length,
            sylIdx
          });
          tokenOffset += tokens.length;
        });
        
        // Calculate display token ranges
        const displayRanges = [];
        let displayOffset = 0;
        displaySyllables.forEach((syl, sylIdx) => {
          const tokens = IpaTokenizer.tokenize(syl.ipa);
          displayRanges.push({
            start: displayOffset,
            end: displayOffset + tokens.length,
            sylIdx
          });
          displayOffset += tokens.length;
        });
        
        // For each log entry, find which display syllable its IPA token(s) now fall into
        // Track cumulative token position as we iterate through entries
        let cumulativeTokenPos = 0;
        const adjustedLog = displayLog.map(entry => {
          const entryTokens = IpaTokenizer.tokenize(entry.ipa || '');
          const entryTokenCount = Math.max(1, entryTokens.length); // At least 1 for positioning
          
          // Find which display syllable contains this token position
          let newSylIdx = entry.syllableIndex ?? 0;
          for (const range of displayRanges) {
            if (cumulativeTokenPos >= range.start && cumulativeTokenPos < range.end) {
              newSylIdx = range.sylIdx;
              break;
            }
          }
          
          // Advance cumulative position
          cumulativeTokenPos += entryTokenCount;
          
          return {
            ...entry,
            adjustedSyllableIndex: newSylIdx
          };
        });
        
        return adjustedLog;
      },
      
      // ё toggle module population (v5.8)
      populateYoToggle(wordData) {
        const cyrillic = wordData.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const hasYe = cyrillic.includes('е') || cyrillic.includes('Е');
        
        // Only show if word contains е or ё
        if (!hasYo && !hasYe) {
          this.elements.yoToggleModule.style.display = 'none';
          return;
        }
        
        this.elements.yoToggleModule.style.display = 'block';
        
        // Get stored data
        const originalInput = wordData.originalInput || '';
        const dictionaryForm = wordData.dictionaryForm || '';
        const yoSource = wordData.yoSource || '';
        
        // Display current form
        this.elements.yoCurrentForm.textContent = cyrillic;
        
        // Determine button label based on state
        let buttonLabel;
        let showWarning = false;
        
        if (hasYo) {
          // Currently has ё — offer to remove
          buttonLabel = 'Remove ё';
          // Show warning if removing ё will change stress (polysyllabic words)
          const syllableCount = wordData.syllables?.length || 1;
          showWarning = syllableCount > 1;
        } else if (dictionaryForm && dictionaryForm !== cyrillic) {
          // Has е, dictionary has ё form available — offer to restore
          buttonLabel = 'Restore ё';
        } else {
          // Has е, no dictionary ё — offer to add
          buttonLabel = 'Add ё';
        }
        
        this.elements.yoToggleLabel.textContent = buttonLabel;
        this.elements.yoWarning.style.display = showWarning ? 'block' : 'none';
      },
      
      // ========================================
      // NEW FOOTER CONTROLS (v5.11)
      // Flat structure replacing accordion
      // ========================================
      
      /**
       * Populate variant row (ё toggle) - v5.11
       * Only shown if word contains е or ё
       */
      populateVariantRow(wordData) {
        const cyrillic = wordData.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const hasYe = cyrillic.includes('е') || cyrillic.includes('Е');
        
        // Hide if word has neither е nor ё
        if (!hasYo && !hasYe) {
          this.elements.variantRow.style.display = 'none';
          return;
        }
        
        this.elements.variantRow.style.display = 'flex';
        
        // Set active state based on current form
        this.elements.variantYo.classList.toggle('active', hasYo);
        this.elements.variantYe.classList.toggle('active', !hasYo && hasYe);
        
        // Store state for undo
        this._yoStateBeforeToggle = hasYo ? 'yo' : 'ye';
      },
      
      /**
       * Populate assimilation row - v5.11
       * Only shown if not last word in line
       */
      populateAssimilationRow(wordData) {
        const line = DocumentState.lines[wordData.lineIndex];
        const isLastWordInLine = wordData.wordIndex >= line.length - 1;
        
        if (isLastWordInLine) {
          this.elements.assimilationRow.style.display = 'none';
          return;
        }
        
        this.elements.assimilationRow.style.display = 'flex';
        
        // Get next word for label
        const nextWord = line[wordData.wordIndex + 1];
        const nextWordCyrillic = nextWord?.cyrillic || nextWord?.originalInput || '—';
        this.elements.nextWordLabel.textContent = nextWordCyrillic;
        
        // Set active state based on current boundary
        const currentBoundary = wordData.rightBoundary || 'soft';
        this.elements.assimilationLinked.classList.toggle('active', currentBoundary === 'soft');
        this.elements.assimilationSeparated.classList.toggle('active', currentBoundary === 'hard');
        
        // Disable if punctuation-forced
        const boundarySource = wordData.boundarySource;
        if (boundarySource === 'punctuation') {
          this.elements.assimilationRow.classList.add('disabled');
        } else {
          this.elements.assimilationRow.classList.remove('disabled');
        }
      },
      
      /**
       * Handle variant toggle (ё ↔ е) - v5.11
       */
      handleVariantToggle(variant) {
        if (!this.currentWord) return;
        
        const cyrillic = this.currentWord.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const currentVariant = hasYo ? 'yo' : 'ye';
        
        // If clicking current state, do nothing
        if (variant === currentVariant) return;
        
        // Store for undo
        this._yoStateBeforeToggle = currentVariant;
        
        // Check if warning needed (polysyllabic + removing ё)
        const syllableCount = this.currentWord.syllables?.length || 1;
        const showWarning = variant === 'ye' && syllableCount > 1;
        
        // Execute toggle (reuse existing logic)
        this.handleYoToggle();
        
        // Show toast warning if needed
        if (showWarning) {
          this.showYoToast();
        }
      },
      
      /**
       * Handle assimilation toggle - v5.11
       */
      handleAssimilationToggle(boundary) {
        if (!this.currentWord) return;
        
        const currentBoundary = this.currentWord.rightBoundary || 'soft';
        
        // If clicking current state, do nothing
        if (boundary === currentBoundary) return;
        
        // Update the boundary directly (no staging pattern for this)
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        if (word) {
          word.rightBoundary = boundary;
          this.currentWord.rightBoundary = boundary;
        }
        
        // Update UI
        this.elements.assimilationLinked.classList.toggle('active', boundary === 'soft');
        this.elements.assimilationSeparated.classList.toggle('active', boundary === 'hard');
        
        // Re-render document to apply assimilation changes
        DrawerController.renderToPaper();
      },
      
      /**
       * Show ё warning toast - v5.11.47 lifecycle-scoped
       */
      showYoToast() {
        this.elements.yoToast.classList.add('visible');
        
        // Clear any existing timer before starting new one
        if (this._yoToastTimer) {
          clearTimeout(this._yoToastTimer);
        }
        
        // Auto-dismiss after 3 seconds
        this._yoToastTimer = setTimeout(() => {
          this.hideYoToast();
        }, 3000);
        
        // Set up hover pause listeners once only
        if (!this._yoToastListenersAttached) {
          this._yoToastListenersAttached = true;
          
          this.elements.yoToast.addEventListener('mouseenter', () => {
            if (this._yoToastTimer) {
              clearTimeout(this._yoToastTimer);
              this._yoToastTimer = null;
            }
          });
          
          this.elements.yoToast.addEventListener('mouseleave', () => {
            this._yoToastTimer = setTimeout(() => {
              this.hideYoToast();
            }, 2000);
          });
        }
      },
      
      /**
       * Hide ё warning toast - v5.11
       */
      hideYoToast() {
        // Guard against missing elements (Phase 3E - popup DOM removed)
        if (this.elements?.yoToast) {
          this.elements.yoToast.classList.remove('visible');
        }
        if (this._yoToastTimer) {
          clearTimeout(this._yoToastTimer);
          this._yoToastTimer = null;
        }
      },
      
      /**
       * Undo ё toggle - v5.11
       */
      undoYoToggle() {
        if (!this.currentWord) return;
        
        // Toggle back
        this.handleYoToggle();
        
        // Hide toast
        this.hideYoToast();
      },

      open(wordData) {
        this.currentWord = wordData;
        this.isOpen = true;
        this.stressWasChanged = false;
        this.attributionSelected = false;
        
        // Hide any lingering toast immediately (v5.11.3)
        this.hideYoToast();
        
        // Collapse refine panel on every open (v5.5 - must be early to avoid flash)
        this.elements.refineToggle?.classList.remove('expanded');
        this.elements.refinePanel?.classList.remove('expanded');
        
        // Store original stress for undo functionality
        const currentStressIdx = wordData.syllables.findIndex(s => s.isStressed);
        this.currentWord.originalStress = currentStressIdx;
        
        // Staging pattern: handle word change and expiry (v5.4.0)
        const wordId = `${wordData.lineIndex}-${wordData.wordIndex}`;
        const isNewWord = this.lastWordId !== wordId;
        this.lastWordId = wordId;
        
        // Clear staged changes if: opening a different word OR staged changes expired
        if (isNewWord || this.isStagedExpired()) {
          this.clearStaged();
        }
        
        // Initialize all UI with current staged/committed state (v5.4.2)
        this.updateAllUI();
        
        // Additional word-type specific UI setup
        const syllableCount = wordData.syllables.length;
        const isClitic = wordData.isProclitic === 'true' || wordData.isEnclitic === 'true';
        const hasYo = wordData.hasYo === 'true' || wordData.hasYo === true;
        const isUnverified = wordData.stressSource === 'default';
        
        // Determine if stress is locked (monosyllable, clitic, or ё)
        const stressLocked = syllableCount === 1 || hasYo;

        // Hide stress source module when stress is locked (monosyllables or ё)
            if (stressLocked) {
                this.elements.stressSourceModule.style.display = 'none';
            } else {
                this.elements.stressSourceModule.style.display = 'block';
            }

        // Render syllable buttons with BoundaryStack offsets (v5.10.23)
        const displaySyllables = BoundaryStack.applyOffsets(wordId, wordData.syllables);
        const buttonsDisabled = hasYo && syllableCount > 1;
        
        this.elements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" data-syllable-index="${idx}" ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}</button>`
        ).join('');
        
        // Monosyllable context label (v5.11.13)
        if (syllableCount === 1) {
          const hasStress = wordData.syllables.some(s => s.isStressed);
          const lang = currentGlossLanguage || 'en';
          if (isClitic) {
            this.elements.syllableLabel.textContent = UI_LABELS['inspector.clitic'][lang];
          } else if (hasStress) {
            this.elements.syllableLabel.textContent = UI_LABELS['inspector.stressedMono'][lang];
          } else {
            this.elements.syllableLabel.textContent = UI_LABELS['inspector.unstressedMono'][lang];
          }
          this.elements.syllableLabel.style.display = 'block';
        } else {
          this.elements.syllableLabel.style.display = 'none';
        }
        
        // Show customized state and register reset handler
        this._updateCustomizedState();
        
        // Populate Cyrillic display and gloss
        const syllabifiedCyrillic = wordData.syllables.map(s => 
          s.isStressed ? addAcuteToSyllable(s.cyrillic) : s.cyrillic
        ).join(' ');
        
        this.elements.cyrillic.textContent = syllabifiedCyrillic;
        this.elements.glossInline.textContent = formatGlossForPopup(wordData.gloss, wordData.pos, wordData.lemma);
        
        // Always hide top clitic badge (info now in Why section)
        this.elements.cliticBadge.style.display = 'none';

        // Show clitic banner in Why section if applicable
            const isProclitic = wordData.isProclitic === 'true' || wordData.isProclitic === true;
            const isEnclitic = wordData.isEnclitic === 'true' || wordData.isEnclitic === true;
            if (isProclitic || isEnclitic) {
                const cliticText = isProclitic 
                    ? 'Proclitic — attaches to the following word like a prefix. A clitic carries no independent stress; its vowel (if any) reduces based on the clitic\'s proximity to the host word\'s stressed syllable. <em>See <span class="tie-bar-ref">‿</span> below for phonological boundaries.</em>'
                    : 'Enclitic — attaches to the preceding word like a suffix. A clitic carries no independent stress; its vowel (if any) reduces based on the clitic\'s proximity to the host word\'s stressed syllable. <em>See <span class="tie-bar-ref">‿</span> below for phonological boundaries.</em>';
                this.elements.whyCliticBanner.innerHTML = cliticText;
                this.elements.whyCliticBanner.style.display = 'block';
            } else {
                this.elements.whyCliticBanner.style.display = 'none';
            }

        // REMOVED IN v5.5 REDESIGN: word-level citation (now using per-phoneme blurbs)
        
        // Render Phoneme Ribbon (v5.5 vertical layout)
        this.renderRibbon(wordData);
        
        // ё toggle module (v5.8) - OLD LOCATION (hidden in v5.11)
        this.populateYoToggle(wordData);
        
        // NEW: Footer controls (v5.11 - flat structure)
        this.populateVariantRow(wordData);
        this.populateAssimilationRow(wordData);
        
        // Phrase boundary control (v5.4.2 - segments instead of radio) - HIDDEN IN v5.11
        const line = DocumentState.lines[wordData.lineIndex];
        const isLastWordInLine = wordData.wordIndex >= line.length - 1;
        const boundarySource = wordData.boundarySource;
        
        if (isLastWordInLine) {
          // Hide for last word — no boundary to control
          this.elements.phraseBoundaryModule.style.display = 'none';
        } else {
          this.elements.phraseBoundaryModule.style.display = 'block';
          
          // Disable if punctuation-forced
          if (boundarySource === 'punctuation') {
            this.elements.phraseBoundaryModule.classList.add('disabled');
          } else {
            this.elements.phraseBoundaryModule.classList.remove('disabled');
          }
          
          // Update boundary UI (handles segment states)
          this.updateBoundaryUI();
        }
        
        this.positionPopup(wordData.element);
        
        this.elements.overlay.classList.add('active');
      },
      
      close() {
        // If stress was changed but no attribution selected, default to 'user'
        if (this.stressWasChanged && !this.attributionSelected && this.currentWord) {
          DocumentState.updateStressSource(
            this.currentWord.lineIndex,
            this.currentWord.wordIndex,
            'user'
          );
        }
        
        // Boundary customizations now persist until page reload (v5.10.23)
        // Word stack IPA already synced in _updateSyllableDisplay()
        
        // Reset state
        this.isOpen = false;
        this.stressWasChanged = false;
        this.attributionSelected = false;
        this.currentWord = null;
        this.elements.overlay.classList.remove('active');
        // UPDATED IN v5.5: refinePanel instead of whyPanel
        this.elements.refineToggle?.classList.remove('expanded');
        this.elements.refinePanel?.classList.remove('expanded');
        this.elements.stressSourceModule.classList.remove('needs-attention');
        this.clearAttributionSelection();
        
        // Reset header customized state (v5.10.19)
        this.elements.syllableDisplayHeader.classList.remove('customized');
        
        // Hide toast (v5.11)
        this.hideYoToast();
      },
      
      positionPopup(element) {
        const rect = element.getBoundingClientRect();
        const card = this.elements.card;
        const cardWidth = 320;
        const margin = 10;
        const viewportHeight = window.innerHeight;
        
        // Horizontal positioning
        let left = rect.left + (rect.width / 2) - (cardWidth / 2);
        left = Math.max(margin, Math.min(left, window.innerWidth - cardWidth - margin));
        
        // Calculate available space above and below the word
        const spaceAbove = rect.top - margin * 2;
        const spaceBelow = viewportHeight - rect.bottom - margin * 2;
        
        let top;
        let maxHeight;
        
        // Prefer placing above if more room there and sufficient space
        if (spaceAbove >= spaceBelow && spaceAbove >= 250) {
          // Place above: position bottom of card at top of word
          maxHeight = Math.min(spaceAbove, viewportHeight * 0.7);
          top = rect.top - margin - maxHeight;
          top = Math.max(margin, top);
          card.classList.remove('arrow-top');
        } else {
          // Place below: position top of card at bottom of word
          maxHeight = Math.min(spaceBelow, viewportHeight * 0.7);
          top = rect.bottom + margin;
          card.classList.add('arrow-top');
        }
        
        // Ensure minimum usable height
        maxHeight = Math.max(250, maxHeight);
        
        card.style.maxHeight = `${maxHeight}px`;
        card.style.top = `${top}px`;
        card.style.left = `${left}px`;
      },
      
      // Drag handling state (v5.10.15, refactored v5.11.27)
      _dragState: null,
      _ghostElement: null,
      _animationInProgress: false,  // Guard against overlapping drag animations
      _hasShownDragHint: false,
      
      /**
       * Setup unified pointer handlers for syllable buttons (v5.11.27)
       * Distance-on-release disambiguation:
       * - <10px movement = tap = reassign stress
       * - 10-40px = hesitation/jitter = silent cancellation
       * - >40px horizontal = drag = shed consonant
       * 
       * No separate click handler, no flags, no timeouts.
       * Pure geometric decision at moment of release.
       */
      _setupDragHandlers() {
        const container = this.elements.syllableDisplay;
        const CLICK_THRESHOLD = 10;   // px - absorbs normal jitter
        const DRAG_THRESHOLD = 40;    // px - existing shed threshold
        
        // Unified handler for mouse and touch
        const handlePointerDown = (e) => {
          const btn = e.target.closest('.syllable-btn');
          if (!btn || !this.isOpen || btn.disabled) return;
          
          // Only handle primary button (left click / single touch)
          if (e.button !== undefined && e.button !== 0) return;
          
          // Get pointer position (mouse or touch)
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          
          this._dragState = {
            startX: clientX,
            startY: clientY,
            syllableIdx: parseInt(btn.dataset.syllableIndex, 10),
            button: btn
          };
          
          // Prevent text selection during potential drag
          e.preventDefault();
        };
        
        const handlePointerMove = (e) => {
          if (!this._dragState) return;
          
          // Optional: cursor feedback when exiting click zone
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const dx = Math.abs(clientX - this._dragState.startX);
          
          if (dx > CLICK_THRESHOLD) {
            this._dragState.button.style.cursor = 'grabbing';
          }
        };
        
        const handlePointerUp = (e) => {
          if (!this._dragState) return;
          
          const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
          const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
          
          const dx = clientX - this._dragState.startX;
          const dy = clientY - this._dragState.startY;
          const distance = Math.abs(dx); // Horizontal distance for drag detection
          
          // Reset cursor
          this._dragState.button.style.cursor = '';
          
          if (distance < CLICK_THRESHOLD) {
            // CASE 1: Clean tap/click → reassign stress
            this.updateStress(this._dragState.syllableIdx);
          } 
          else if (distance >= DRAG_THRESHOLD && Math.abs(dy) < 20) {
            // CASE 2: Committed horizontal drag → shed consonant
            const direction = dx > 0 ? 'right' : 'left';
            this._attemptConsonantShed(this._dragState.syllableIdx, direction);
          }
          // CASE 3: Dead zone (10-40px) or vertical movement → silent cancellation
          // Do nothing - this is the "Calm" moment
          
          this._dragState = null;
        };
        
        // Mouse events
        container.addEventListener('mousedown', handlePointerDown);
        document.addEventListener('mousemove', handlePointerMove);
        document.addEventListener('mouseup', handlePointerUp);
        
        // Touch events (not passive because we preventDefault in pointerdown)
        container.addEventListener('touchstart', handlePointerDown, { passive: false });
        document.addEventListener('touchmove', handlePointerMove, { passive: true });
        document.addEventListener('touchend', handlePointerUp);
      },
      
      /**
       * Attempt to shed a consonant from syllable in given direction
       * 
       * NOTE (v5.11.39): Cluster immutability check REMOVED per Kimi's guidance.
       * The Phoneme Ribbon is pedagogical visualization, not phonological commitment.
       * Users should be able to visualize any syllable break for educational purposes,
       * even if Grayson's engine treats certain clusters as fused units.
       */
      _attemptConsonantShed(syllableIdx, direction) {
        if (!this.currentWord) return;
        
        // Guard: prevent overlapping animations
        if (this._animationInProgress) return;
        
        const syllables = this.currentWord.syllables;
        const syllableCount = syllables.length;
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        
        // Clamp check: can't shed left from first syllable or right from last
        if (direction === 'left' && syllableIdx === 0) {
          this._flashInvalid(syllableIdx);
          return;
        }
        if (direction === 'right' && syllableIdx === syllableCount - 1) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // Get current syllable's tokens
        const displaySyllables = BoundaryStack.applyOffsets(wordId, syllables);
        const currentSyl = displaySyllables[syllableIdx];
        const tokens = IpaTokenizer.tokenize(currentSyl.ipa);
        const segments = IpaTokenizer.parseSegments(tokens);
        
        // Check if we can shed in this direction
        let canShed = false;
        let consonantToShed = null;
        
        if (direction === 'left') {
          // Shed leftmost onset consonant to previous syllable's coda
          if (segments.onset.length > 0) {
            canShed = true;
            consonantToShed = segments.onset[0].symbol;
          }
        } else {
          // Shed rightmost coda consonant to next syllable's onset
          if (segments.coda.length > 0) {
            canShed = true;
            consonantToShed = segments.coda[segments.coda.length - 1].symbol;
          }
        }
        
        if (!canShed) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // NOTE (v5.11.39): Gesture-based reset REMOVED per Kimi's diagnosis.
        // This was causing the "3rd consonant resets to original" bug.
        // Reset is now explicit via per-word button only (Cycle B).
        
        // Get button positions for animation
        const sourceBtn = this.elements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        const targetIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx + 1;
        const targetBtn = this.elements.syllableDisplay.querySelector(`[data-syllable-index="${targetIdx}"]`);
        
        if (sourceBtn && targetBtn) {
          // Animate the ghost consonant
          this._animateConsonantGhost(consonantToShed, sourceBtn, targetBtn, direction, () => {
            // Shift the boundary after animation completes
            const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
            const shiftDir = direction === 'left' ? 'left' : 'right';
            BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
            
            // Update display
            this._updateSyllableDisplay();
            this._updateCustomizedState();
          });
        } else {
          // Fallback: no animation, just update
          const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
          const shiftDir = direction === 'left' ? 'left' : 'right';
          BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
          this._updateSyllableDisplay();
          this._updateCustomizedState();
        }
      },
      
      /**
       * Animate a ghost consonant from source to target button
       */
      _animateConsonantGhost(consonant, sourceBtn, targetBtn, direction, onComplete) {
        // Set animation lock
        this._animationInProgress = true;
        
        // Get positions
        const sourceRect = sourceBtn.getBoundingClientRect();
        const targetRect = targetBtn.getBoundingClientRect();
        
        // Calculate start and end positions
        // For left drag: consonant leaves from left edge of source, arrives at right edge of target
        // For right drag: consonant leaves from right edge of source, arrives at left edge of target
        const startX = direction === 'left' 
          ? sourceRect.left 
          : sourceRect.right - 20;
        const startY = sourceRect.top + sourceRect.height / 2 - 15;
        
        const endX = direction === 'left'
          ? targetRect.right - 20
          : targetRect.left;
        const endY = targetRect.top + targetRect.height / 2 - 15;
        
        // Create ghost element
        const ghost = document.createElement('div');
        ghost.className = 'consonant-ghost';
        ghost.textContent = consonant;
        ghost.style.left = `${startX}px`;
        ghost.style.top = `${startY}px`;
        document.body.appendChild(ghost);
        this._ghostElement = ghost;
        
        // Dim the source button
        sourceBtn.classList.add('dragging');
        
        // Highlight target button
        targetBtn.classList.add('drag-target');
        
        // Trigger animation after a frame (to ensure initial position is set)
        requestAnimationFrame(() => {
          ghost.style.transition = 'left 0.25s ease-out, top 0.25s ease-out';
          ghost.style.left = `${endX}px`;
          ghost.style.top = `${endY}px`;
          ghost.classList.add('valid');
        });
        
        // Cleanup and callback after animation
        setTimeout(() => {
          sourceBtn.classList.remove('dragging');
          targetBtn.classList.remove('drag-target');
          this._cleanupGhost();
          this._animationInProgress = false;  // Release animation lock
          onComplete();
        }, 260);
      },
      
      /**
       * DEPRECATED (v5.11.39): Gesture-based reset removed.
       * This was causing the "3rd consonant resets" bug by triggering
       * when the drag path crossed the original boundary position.
       * Reset is now explicit via per-word button only.
       * 
       * Keeping commented for reference in case we want to restore
       * as an optional behavior later.
       */
      /*
      _isResetGesture(wordId, syllableIdx, direction, syllableCount) {
        const offsets = BoundaryStack.getOffsets(wordId, syllableCount);
        const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
        
        if (boundaryIdx < 0 || boundaryIdx >= offsets.length) return false;
        
        const currentOffset = offsets[boundaryIdx];
        
        // Reset only if this drag would move offset TOWARD zero
        // direction='left' increases offset (++)
        // direction='right' decreases offset (--)
        
        if (direction === 'left' && currentOffset < 0) {
          // Offset is negative (gave to right), dragging left brings it toward 0
          return currentOffset === -1; // Only reset if this is the last step back
        }
        if (direction === 'right' && currentOffset > 0) {
          // Offset is positive (stole from right), dragging right brings it toward 0
          return currentOffset === 1; // Only reset if this is the last step back
        }
        
        return false;
      },
      */
      
      /**
       * Flash invalid feedback on syllable button
       */
      _flashInvalid(syllableIdx) {
        const btn = this.elements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        if (btn) {
          btn.classList.add('drag-invalid');
          setTimeout(() => btn.classList.remove('drag-invalid'), 300);
        }
      },
      
      /**
       * Update syllable button display with boundary offsets applied
       */
      _updateSyllableDisplay() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const originalSyllables = this.currentWord.syllables;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, originalSyllables);
        
        // Re-render buttons with display syllables
        const hasYo = this.currentWord.hasYo === 'true' || this.currentWord.hasYo === true;
        const syllableCount = displaySyllables.length;
        const buttonsDisabled = hasYo && syllableCount > 1;
        
        this.elements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" data-syllable-index="${idx}" ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}</button>`
        ).join('');
        
        // Sync word stack IPA in main document (v5.10.22)
        const wordStack = document.querySelector(
          `.word-stack[data-line-index="${this.currentWord.lineIndex}"][data-word-index="${this.currentWord.wordIndex}"]`
        );
        if (wordStack) {
          const ipaSpan = wordStack.querySelector('.ipa');
          if (ipaSpan) {
            // Build display IPA with stress marks and spaces
            let displayIPA = displaySyllables.map((syl, idx) => {
              return syl.isStressed && displaySyllables.length > 1 ? 'ˈ' + syl.ipa : syl.ipa;
            }).join(' ');
            
            // Preserve clitic tie bars
            const isProclitic = this.currentWord.isProclitic === 'true' || this.currentWord.isProclitic === true;
            const isEnclitic = this.currentWord.isEnclitic === 'true' || this.currentWord.isEnclitic === true;
            if (isProclitic) {
              displayIPA = displayIPA + '‿';
            } else if (isEnclitic) {
              displayIPA = '‿' + displayIPA;
            }
            
            ipaSpan.textContent = displayIPA;
          }
        }
        
        // Re-render ribbon with updated syllable groupings (v5.10.25)
        if (this.currentWord) {
          this.renderRibbon(this.currentWord);
        }
      },
      
      /**
       * Update header to show customized state (boundaries adjusted)
       * v5.11.43: Uses explicit reset button instead of header click handler
       */
      _updateCustomizedState() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const hasCustom = BoundaryStack.hasCustomBoundaries(wordId);
        
        this.elements.syllableDisplayHeader.classList.toggle('customized', hasCustom);
        
        // Show/hide the explicit reset button
        if (this.elements.boundaryResetBtn) {
          this.elements.boundaryResetBtn.classList.toggle('visible', hasCustom);
          this.elements.boundaryResetBtn.style.display = hasCustom ? 'inline-block' : 'none';
        }
        
        // Set up reset button click handler (only once)
        if (!this._resetBtnHandler && this.elements.boundaryResetBtn) {
          this._resetBtnHandler = () => {
            if (!this.currentWord) return;
            const currentWordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
            if (BoundaryStack.hasCustomBoundaries(currentWordId)) {
              BoundaryStack.reset(currentWordId);
              this._updateSyllableDisplay();
              this._updateCustomizedState();
              this._pulseAllConsonants();
            }
          };
          this.elements.boundaryResetBtn.addEventListener('click', this._resetBtnHandler);
        }
      },
      
      /**
       * Pulse animation when resetting to default
       */
      _pulseAllConsonants() {
        const buttons = this.elements.syllableDisplay.querySelectorAll('.syllable-btn');
        buttons.forEach(btn => {
          btn.style.transition = 'transform 0.2s ease-out';
          btn.style.transform = 'scale(1.05)';
          setTimeout(() => {
            btn.style.transform = 'scale(1)';
          }, 200);
        });
      },
      
      /**
       * Clean up ghost element
       */
      _cleanupGhost() {
        if (this._ghostElement) {
          this._ghostElement.remove();
          this._ghostElement = null;
        }
      },
      
      updateStress(newStressIdx) {
        if (!this.currentWord) return;
        
        // Block stress changes for ё words (ё always carries stress)
        const hasYo = this.currentWord.hasYo === 'true' || this.currentWord.hasYo === true || 
                      GraysonEngine.hasYo(this.currentWord.cyrillic);
        if (hasYo) {
          return; // Stress is locked to ё syllable
        }
        
        DocumentState.updateStress(this.currentWord.lineIndex, this.currentWord.wordIndex, newStressIdx);
        DrawerController.renderToPaper();
        
        const result = GraysonEngine.transcribe(this.currentWord.cyrillic, newStressIdx, this.currentWord.isProclitic === 'true' || this.currentWord.isProclitic === true);
        this.currentWord.ipa = result.ipa;
        this.currentWord.syllables = result.syllables;
        this.currentWord.transcriptionLog = result.transcriptionLog;
        
        // Re-render syllable buttons with updated stress marks
        // Guard: ensure syllable count matches button count
        const buttons = this.elements.syllableDisplay.querySelectorAll('.syllable-btn');
        buttons.forEach((btn, idx) => {
          if (idx < result.syllables.length) {
            const syl = result.syllables[idx];
            btn.classList.toggle('stressed', idx === newStressIdx);
            btn.textContent = (idx === newStressIdx) ? 'ˈ' + syl.ipa : syl.ipa;
          }
        });
        
        // Re-render Phoneme Ribbon with new stress position
        this.renderRibbon(this.currentWord);
        
        // Track that stress was changed and trigger attribution prompt
        this.stressWasChanged = true;
        this.attributionSelected = false;
        this.clearAttributionSelection();
        
        // Expand Why panel and trigger pulse animation (with null guards)
        if (this.elements.whyPanel) {
          this.elements.whyPanel.classList.add('expanded');
        }
        if (this.elements.stressSourceModule) {
          this.elements.stressSourceModule.classList.remove('needs-attention');
          // Force reflow to restart animation
          void this.elements.stressSourceModule.offsetWidth;
          this.elements.stressSourceModule.classList.add('needs-attention');
        }
        
        // Update hint text
        if (this.elements.stressSourceHint) {
          this.elements.stressSourceHint.textContent = 'Optional: mark why you changed this';
        }
      }
    };

    /* ========================================
       DRAWER STATE MACHINE (v6.0)
       Manages left-side drawer open/close and
       Root/Drill internal state transitions.
       ======================================== */
    const DrawerState = {
      drawer: null,
      scrim: null,
      previousFocus: null,
      currentWord: null,  // Stores selected word data for Drill state (Phase 3)
      
      // Element references for inspector
      inspectorElements: {},
      
      // Phase 4B: Drag handling state for syllable boundary editing
      _dragState: null,
      _ghostElement: null,
      _animationInProgress: false,

      init() {
        this.drawer = document.getElementById('ilyaDrawer');
        this.scrim = document.getElementById('drawerScrim');
        this.layout = document.querySelector('.ilya-layout');
        
        // Cache inspector elements (Phase 3B)
        this.inspectorElements = {
          backBtn: document.getElementById('drawerBackBtn'),
          wordDisplay: document.getElementById('inspectorWordDisplay'),
          syllableLabel: document.getElementById('inspectorSyllableLabel'),
          syllableHeader: document.getElementById('inspectorSyllableHeader'),
          syllableDisplay: document.getElementById('inspectorSyllableDisplay'),
          boundaryResetBtn: document.getElementById('inspectorBoundaryResetBtn'),
          cyrillic: document.getElementById('inspectorCyrillic'),
          glossInline: document.getElementById('inspectorGlossInline'),
          ribbonSection: document.getElementById('inspectorRibbonSection'),
          ribbon: document.getElementById('inspectorRibbon'),
          controls: document.getElementById('inspectorControls'),
          // Phase 3D: Control modules
          variantRow: document.getElementById('inspectorVariantRow'),
          variantLabel: document.getElementById('inspectorVariantLabel'),
          variantYo: document.getElementById('inspectorVariantYo'),
          variantYe: document.getElementById('inspectorVariantYe'),
          variantConfirm: document.getElementById('inspectorVariantConfirm'),
          variantCancel: document.getElementById('inspectorVariantCancel'),
          variantApply: document.getElementById('inspectorVariantApply'),
          assimilationRow: document.getElementById('inspectorAssimilationRow'),
          boundaryLabel: document.getElementById('inspectorBoundaryLabel'),
          assimilationLinked: document.getElementById('inspectorAssimilationLinked'),
          assimilationSeparated: document.getElementById('inspectorAssimilationSeparated'),
          stressSourceRow: document.getElementById('inspectorStressSourceRow'),
          stressDictionary: document.getElementById('inspectorStressDictionary'),
          stressComposer: document.getElementById('inspectorStressComposer'),
          stressUser: document.getElementById('inspectorStressUser'),
          stressAttributionArrow: document.getElementById('stressAttributionArrow'),
          yoToast: document.getElementById('inspectorYoToast'),
          yoUndoBtn: document.getElementById('inspectorYoUndoBtn')
        };
        
        // Back button returns to Root (with stopPropagation)
        this.inspectorElements.backBtn?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.switchMode('root');
        });
        
        // Gloss editing (save on blur)
        this.inspectorElements.glossInline?.addEventListener('blur', () => {
          if (this.currentWord) {
            const newGloss = this.inspectorElements.glossInline.textContent.trim();
            DocumentState.updateGloss(this.currentWord.lineIndex, this.currentWord.wordIndex, newGloss);
            DrawerController.renderToPaper();
          }
        });
        
        // Prevent gloss click from propagating (keeps focus for editing)
        this.inspectorElements.glossInline?.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        // Phase 3D: Control event handlers
        // Variant toggle (ё/е) - stages change, shows confirmation
        this.inspectorElements.variantYo?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.stageVariantToggle('yo');
        });
        this.inspectorElements.variantYe?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.stageVariantToggle('ye');
        });
        
        // Variant confirmation actions
        this.inspectorElements.variantCancel?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.cancelVariantToggle();
        });
        this.inspectorElements.variantApply?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.applyVariantToggle();
        });
        
        // Assimilation toggle (Linked/Separated)
        this.inspectorElements.assimilationLinked?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleAssimilationToggle('soft');
        });
        this.inspectorElements.assimilationSeparated?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleAssimilationToggle('hard');
        });
        
        // Stress source selection
        this.inspectorElements.stressDictionary?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleStressSourceSelect('dictionary');
        });
        this.inspectorElements.stressComposer?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleStressSourceSelect('composer');
        });
        this.inspectorElements.stressUser?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleStressSourceSelect('user');
        });
        
        // Toast undo button
        this.inspectorElements.yoUndoBtn?.addEventListener('click', (e) => {
          e.stopPropagation();
          this.undoYoToggle();
        });
        
        // Phase 4B: Set up syllable boundary drag handlers
        this._setupDragHandlers();
        
        // Phase 5C: Set up swipe-to-dismiss for mobile bottom sheet
        this._setupSwipeToDismiss();
        
        // Phase 5C: Viewport resize state synchronization
        this._setupViewportListener();
      },

      get isOpen() {
        return this.drawer?.dataset.state === 'open';
      },

      get mode() {
        return this.drawer?.dataset.mode || 'root';
      },

      open(mode = 'root', wordData = null) {
        if (!this.drawer) return;
        this.previousFocus = document.activeElement;
        this.drawer.dataset.state = 'open';
        this.drawer.dataset.mode = mode;
        this.layout?.classList.add('drawer-open');
        
        // If opening in inspect mode with word data, update the inspector
        if (mode === 'inspect' && wordData) {
          this.currentWord = wordData;
          this.updateInspector();
        }
        
        // Phase 4C: Focus first interactive element after transition
        setTimeout(() => {
          this._focusFirstElement(mode);
        }, 310); // After 300ms drawer animation
      },

      close() {
        if (!this.drawer) return;
        this.drawer.dataset.state = 'closed';
        this.layout?.classList.remove('drawer-open');
        // Return focus to triggering element
        this.previousFocus?.focus();
        this.previousFocus = null;
      },

      switchMode(mode, wordData = null) {
        if (!this.drawer) return;
        
        // Phase 4A: Detect word-to-word transition (already in inspect → new word)
        const isWordToWord = this.mode === 'inspect' && mode === 'inspect' && wordData;
        
        if (isWordToWord) {
          // Store previous phonemes for comparison
          this._previousPhonemes = this._extractPhonemeList(this.currentWord);
          
          // Trigger morph animation
          this._morphToNewWord(wordData);
        } else {
          // Standard mode switch (no morph needed)
          this.drawer.dataset.mode = mode;
          
          if (mode === 'inspect' && wordData) {
            this.currentWord = wordData;
            this._previousPhonemes = null; // No comparison for fresh inspection
            this.updateInspector();
          }
          
          // Phase 4C: Focus appropriate element after mode transition
          setTimeout(() => {
            this._focusFirstElement(mode);
          }, 210); // After 200ms internal transition
        }
      },
      
      // Phase 4A: Extract phoneme list from word data for comparison
      _extractPhonemeList(wordData) {
        if (!wordData?.transcriptionLog) return [];
        return wordData.transcriptionLog.map(entry => ({
          char: entry.char,
          ipa: entry.ipa || ''
        }));
      },
      
      // Phase 4A: Morph animation to new word (250ms total)
      _morphToNewWord(wordData) {
        const inspectorBody = document.querySelector('.drawer-inspector .inspector-body');
        if (!inspectorBody) {
          // Fallback: update without animation
          this.currentWord = wordData;
          this.updateInspector();
          return;
        }
        
        // Phase 1: Fade out (125ms)
        inspectorBody.classList.add('morphing');
        inspectorBody.classList.remove('morph-in');
        
        setTimeout(() => {
          // Update content while invisible
          this.currentWord = wordData;
          this.updateInspector();
          
          // Phase 2: Fade in (125ms)
          inspectorBody.classList.remove('morphing');
          inspectorBody.classList.add('morph-in');
          
          // Apply sage highlights to changed phonemes
          this._highlightChangedPhonemes();
          
          // Clean up animation class after complete
          setTimeout(() => {
            inspectorBody.classList.remove('morph-in');
          }, 125);
        }, 125);
      },
      
      // Phase 4A: Compare phonemes and highlight changes
      _highlightChangedPhonemes() {
        if (!this._previousPhonemes || !this.currentWord?.transcriptionLog) return;
        
        const currentPhonemes = this._extractPhonemeList(this.currentWord);
        const ribbonContainer = this.inspectorElements.ribbon;
        if (!ribbonContainer) return;
        
        // Get all phoneme rows and cluster groups
        const rows = ribbonContainer.querySelectorAll('.phoneme-row:not(.clitic-arrow-row), .cluster-group');
        
        rows.forEach((row, idx) => {
          const current = currentPhonemes[idx];
          const previous = this._previousPhonemes[idx];
          
          // Highlight if phoneme is new, different char, or different IPA
          const isChanged = !previous || 
                           (current && (current.char !== previous.char || current.ipa !== previous.ipa));
          
          if (isChanged) {
            row.classList.add('phoneme-changed');
            // Remove highlight class after animation completes
            setTimeout(() => {
              row.classList.remove('phoneme-changed');
            }, 400);
          }
        });
        
        // Clear stored phonemes
        this._previousPhonemes = null;
      },
      
      // Update inspector display with current word (Phase 3B)
      updateInspector() {
        if (!this.currentWord) return;
        
        // Clear pending attribution from previous word
        this.inspectorElements.stressSourceRow?.classList.remove('pending-attribution');
        
        // Sync Drill language pill to currentGlossLanguage (v6.0.51)
        const drillPill = document.getElementById('drillLangPill');
        if (drillPill) {
          drillPill.dataset.lang = currentGlossLanguage;
          drillPill.querySelectorAll('.lang-option').forEach(opt => {
            const isActive = opt.dataset.lang === currentGlossLanguage;
            opt.classList.toggle('active', isActive);
            opt.setAttribute('aria-checked', isActive);
          });
        }
        
        const { cyrillic, ipa, gloss, syllables, isProclitic, isEnclitic, hasYo, wordId } = this.currentWord;
        const syllableCount = syllables?.length || 0;
        const isClitic = isProclitic === 'true' || isEnclitic === 'true';
        const hasYoFlag = hasYo === 'true' || hasYo === true;
        
        // Header: Word display with stress
        const syllabifiedCyrillic = syllables?.map(s => 
          s.isStressed ? addAcuteToSyllable(s.cyrillic) : s.cyrillic
        ).join(' ') || cyrillic;
        
        if (this.inspectorElements.wordDisplay) {
          this.inspectorElements.wordDisplay.textContent = syllabifiedCyrillic;
        }
        
        // Syllable Label (monosyllable/clitic context)
        if (this.inspectorElements.syllableLabel) {
          if (syllableCount === 1) {
            const hasStress = syllables?.some(s => s.isStressed);
            const lang = currentGlossLanguage || 'en';
            if (isClitic) {
              this.inspectorElements.syllableLabel.textContent = UI_LABELS['inspector.clitic'][lang];
            } else if (hasStress) {
              this.inspectorElements.syllableLabel.textContent = UI_LABELS['inspector.stressedMono'][lang];
            } else {
              this.inspectorElements.syllableLabel.textContent = UI_LABELS['inspector.unstressedMono'][lang];
            }
          } else {
            this.inspectorElements.syllableLabel.textContent = '';
          }
        }
        
        // Syllable Buttons (interactive IPA)
        if (this.inspectorElements.syllableDisplay) {
          // Apply boundary offsets if customized
          const displaySyllables = typeof BoundaryStack !== 'undefined' && wordId
            ? BoundaryStack.applyOffsets(wordId, syllables)
            : syllables;
          
          // ё locks stress — disable non-stressed buttons
          const buttonsDisabled = hasYoFlag && syllableCount > 1;
          
          this.inspectorElements.syllableDisplay.innerHTML = displaySyllables?.map((syl, idx) => 
            `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" 
                     data-syllable-index="${idx}" 
                     ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>
              ${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}
            </button>`
          ).join('') || '';
          
          // Wire up syllable button clicks for stress reassignment
          this.inspectorElements.syllableDisplay.querySelectorAll('.syllable-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();  // Prevent drawer from closing
              if (btn.disabled) return;
              const newStressIdx = parseInt(btn.dataset.syllableIndex, 10);
              this.handleStressChange(newStressIdx);
            });
          });
        }
        
        // Cyrillic Display
        if (this.inspectorElements.cyrillic) {
          this.inspectorElements.cyrillic.textContent = syllabifiedCyrillic;
        }
        
        // Gloss (editable)
        if (this.inspectorElements.glossInline) {
          this.inspectorElements.glossInline.textContent = gloss || '';
        }
        
        // Phoneme Ribbon (Phase 3C) - reuse Popup's renderRibbon with drawer container
        if (this.inspectorElements.ribbon && typeof Popup !== 'undefined') {
          Popup.renderRibbon(this.currentWord, this.inspectorElements.ribbon);
        }
        
        // Phase 4A: Reset scroll to top on every word selection
        const inspectorBody = document.querySelector('.drawer-inspector .inspector-body');
        if (inspectorBody) {
          inspectorBody.scrollTop = 0;
        }
        
        // Phase 3D: Populate controls
        this.populateControls();
      },
      
      // Phase 3D: Populate control modules based on current word
      populateControls() {
        if (!this.currentWord) return;
        
        const { cyrillic, syllables, lineIndex, wordIndex, rightBoundary, boundarySource, stressSource } = this.currentWord;
        const syllableCount = syllables?.length || 1;
        const hasYo = cyrillic?.includes('ё') || cyrillic?.includes('Ё');
        const hasYe = cyrillic?.includes('е') || cyrillic?.includes('Е');
        
        // 1. Variant row (ё/е toggle)
        if (!hasYo && !hasYe) {
          this.inspectorElements.variantRow.style.display = 'none';
        } else {
          this.inspectorElements.variantRow.style.display = 'flex';
          
          // Contextual label: "Restore ё:" when showing е, "Restore е:" when showing ё
          if (this.inspectorElements.variantLabel) {
            this.inspectorElements.variantLabel.textContent = hasYo ? 'Restore е:' : 'Restore ё:';
          }
          
          this.inspectorElements.variantYo?.classList.toggle('active', hasYo);
          this.inspectorElements.variantYo?.classList.remove('staged');
          this.inspectorElements.variantYe?.classList.toggle('active', !hasYo && hasYe);
          this.inspectorElements.variantYe?.classList.remove('staged');
          
          // Hide confirmation row
          this.inspectorElements.variantConfirm?.classList.remove('visible');
          this._stagedVariant = null;
          
          // Store state for undo
          this._yoStateBeforeToggle = hasYo ? 'yo' : 'ye';
        }
        
        // 2. Assimilation row (word boundary control)
        const line = DocumentState.lines[lineIndex];
        const isLastWordInLine = wordIndex >= (line?.length || 1) - 1;
        
        if (isLastWordInLine) {
          this.inspectorElements.assimilationRow.style.display = 'none';
        } else {
          this.inspectorElements.assimilationRow.style.display = 'flex';
          
          // Build bespoke label: "Break between [x] and [y]?"
          const currentWordCyrillic = cyrillic || '—';
          const nextWord = line[wordIndex + 1];
          const nextWordCyrillic = nextWord?.cyrillic || nextWord?.originalInput || '—';
          if (this.inspectorElements.boundaryLabel) {
            this.inspectorElements.boundaryLabel.textContent = `Break between [${currentWordCyrillic}] and [${nextWordCyrillic}]?`;
          }
          
          // Set active state based on current boundary (No = soft, Yes = hard)
          const currentBoundary = rightBoundary || 'soft';
          this.inspectorElements.assimilationLinked?.classList.toggle('active', currentBoundary === 'soft');
          this.inspectorElements.assimilationSeparated?.classList.toggle('active', currentBoundary === 'hard');
          
          // Disable if punctuation-forced
          if (boundarySource === 'punctuation') {
            this.inspectorElements.assimilationRow.classList.add('disabled');
          } else {
            this.inspectorElements.assimilationRow.classList.remove('disabled');
          }
        }
        
        // 3. Stress source module
        // Hide when stress is locked (monosyllable or ё)
        const stressLocked = syllableCount === 1 || hasYo;
        this.inspectorElements.stressSourceRow?.classList.toggle('hidden', stressLocked);
        
        if (!stressLocked) {
          const currentSource = stressSource || 'dictionary';
          this.inspectorElements.stressDictionary?.classList.toggle('active', currentSource === 'dictionary');
          this.inspectorElements.stressComposer?.classList.toggle('active', currentSource === 'composer');
          this.inspectorElements.stressComposer?.classList.toggle('committed', currentSource === 'composer');
          this.inspectorElements.stressUser?.classList.toggle('active', currentSource === 'user');
          this.inspectorElements.stressUser?.classList.toggle('committed', currentSource === 'user');
        }
        
        // Hide toast initially
        this.inspectorElements.yoToast?.classList.remove('visible');
        
        // Phase 4B: Initialize reset button visibility
        this._updateCustomizedState();
      },
      
      // Phase 3D: Stage variant toggle (shows confirmation)
      stageVariantToggle(variant) {
        if (!this.currentWord) return;
        
        const cyrillic = this.currentWord.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const currentVariant = hasYo ? 'yo' : 'ye';
        
        // If clicking current state, do nothing
        if (variant === currentVariant) return;
        
        // Stage the change
        this._stagedVariant = variant;
        
        // Update button states: remove active, add staged to target
        this.inspectorElements.variantYo?.classList.remove('active', 'staged');
        this.inspectorElements.variantYe?.classList.remove('active', 'staged');
        
        if (variant === 'yo') {
          this.inspectorElements.variantYo?.classList.add('staged');
        } else {
          this.inspectorElements.variantYe?.classList.add('staged');
        }
        
        // Show confirmation row
        this.inspectorElements.variantConfirm?.classList.add('visible');
      },
      
      // Phase 3D: Cancel variant toggle
      cancelVariantToggle() {
        // Restore button states
        const cyrillic = this.currentWord?.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        
        this.inspectorElements.variantYo?.classList.remove('staged');
        this.inspectorElements.variantYe?.classList.remove('staged');
        this.inspectorElements.variantYo?.classList.toggle('active', hasYo);
        this.inspectorElements.variantYe?.classList.toggle('active', !hasYo);
        
        // Hide confirmation row
        this.inspectorElements.variantConfirm?.classList.remove('visible');
        this._stagedVariant = null;
      },
      
      // Phase 3D: Apply variant toggle
      applyVariantToggle() {
        if (!this._stagedVariant || !this.currentWord) return;
        
        const variant = this._stagedVariant;
        
        // Hide confirmation row first
        this.inspectorElements.variantConfirm?.classList.remove('visible');
        
        // Execute the toggle
        this.handleVariantToggle(variant);
        
        this._stagedVariant = null;
      },
      
      // Phase 3D: Handle variant toggle (ё ↔ е) - executes the change
      handleVariantToggle(variant) {
        if (!this.currentWord) return;
        
        const cyrillic = this.currentWord.cyrillic || '';
        const hasYo = cyrillic.includes('ё') || cyrillic.includes('Ё');
        const currentVariant = hasYo ? 'yo' : 'ye';
        
        // If clicking current state, do nothing
        if (variant === currentVariant) return;
        
        // Store for undo
        this._yoStateBeforeToggle = currentVariant;
        
        // Check if warning needed (polysyllabic + removing ё)
        const syllableCount = this.currentWord.syllables?.length || 1;
        const showWarning = variant === 'ye' && syllableCount > 1;
        
        // Delegate to Popup's handleYoToggle (it has the reprocessing logic)
        if (typeof Popup !== 'undefined' && Popup.currentWord) {
          // Temporarily set Popup's currentWord to match ours
          const originalPopupWord = Popup.currentWord;
          Popup.currentWord = this.currentWord;
          Popup.handleYoToggle();
          Popup.currentWord = originalPopupWord;
        }
        
        // Refresh inspector after change
        this.refreshAfterChange();
        
        // Show toast warning if needed
        if (showWarning) {
          this.showYoToast();
        }
      },
      
      // Phase 3D: Handle assimilation toggle (Linked/Separated)
      handleAssimilationToggle(boundary) {
        if (!this.currentWord) return;
        
        const currentBoundary = this.currentWord.rightBoundary || 'soft';
        
        // If clicking current state, do nothing
        if (boundary === currentBoundary) return;
        
        // Update the boundary directly
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        if (word) {
          word.rightBoundary = boundary;
          word.boundarySource = 'user';
          this.currentWord.rightBoundary = boundary;
          this.currentWord.boundarySource = 'user';
        }
        
        // Update UI
        this.inspectorElements.assimilationLinked?.classList.toggle('active', boundary === 'soft');
        this.inspectorElements.assimilationSeparated?.classList.toggle('active', boundary === 'hard');
        
        // Re-render paper
        DrawerController.renderToPaper();
      },
      
      // Phase 3D: Handle stress source selection
      handleStressSourceSelect(source) {
        if (!this.currentWord) return;
        
        const word = DocumentState.lines[this.currentWord.lineIndex]?.[this.currentWord.wordIndex];
        if (!word) return;
        
        const currentSource = word.stressSource || 'dictionary';
        
        // If clicking current state, do nothing
        if (source === currentSource) return;
        
        // Update stress source
        word.stressSource = source;
        this.currentWord.stressSource = source;
        
        // Update UI
        this.inspectorElements.stressDictionary?.classList.remove('active', 'committed');
        this.inspectorElements.stressComposer?.classList.remove('active', 'committed');
        this.inspectorElements.stressUser?.classList.remove('active', 'committed');
        
        const targetBtn = source === 'dictionary' ? this.inspectorElements.stressDictionary
                        : source === 'composer' ? this.inspectorElements.stressComposer
                        : this.inspectorElements.stressUser;
        
        if (targetBtn) {
          targetBtn.classList.add('active');
          if (source !== 'dictionary') {
            targetBtn.classList.add('committed');
          }
        }
        
        // Re-render paper
        DrawerController.renderToPaper();
        
        // Attribution fulfilled
        this.inspectorElements.stressSourceRow?.classList.remove('pending-attribution');
      },
      
      // Phase 3D: Show ё warning toast
      showYoToast() {
        this.inspectorElements.yoToast?.classList.add('visible');
        
        // Auto-hide after 5 seconds
        clearTimeout(this._yoToastTimeout);
        this._yoToastTimeout = setTimeout(() => {
          this.inspectorElements.yoToast?.classList.remove('visible');
        }, 5000);
      },
      
      // Phase 3D: Undo ё toggle
      undoYoToggle() {
        if (!this._yoStateBeforeToggle) return;
        
        // Toggle back
        this.handleVariantToggle(this._yoStateBeforeToggle);
        
        // Hide toast
        this.inspectorElements.yoToast?.classList.remove('visible');
        clearTimeout(this._yoToastTimeout);
      },
      
      // Phase 3D: Refresh inspector after word change
      refreshAfterChange() {
        const { lineIndex, wordIndex } = this.currentWord;
        
        // Re-render paper
        DrawerController.renderToPaper();
        
        // Find the updated word element and refresh inspector data
        const wordStack = document.querySelector(`.word-stack[data-line-index="${lineIndex}"][data-word-index="${wordIndex}"]`);
        if (wordStack) {
          this.currentWord = {
            ...this.currentWord,
            cyrillic: wordStack.dataset.cyrillic,
            ipa: wordStack.dataset.ipa,
            syllables: JSON.parse(wordStack.dataset.syllables || '[]'),
            hasYo: wordStack.dataset.hasYo,
            stressSource: wordStack.dataset.stressSource,
            rightBoundary: wordStack.dataset.rightBoundary,
            boundarySource: wordStack.dataset.boundarySource
          };
          this.updateInspector();
        }
      },
      
      // Handle stress change from syllable button click (Phase 3B)
      handleStressChange(newStressIdx) {
        if (!this.currentWord) return;
        
        const { lineIndex, wordIndex, syllables } = this.currentWord;
        const currentStressIdx = syllables?.findIndex(s => s.isStressed) ?? -1;
        
        // No change needed
        if (newStressIdx === currentStressIdx) return;
        
        // Update DocumentState
        DocumentState.updateStress(lineIndex, wordIndex, newStressIdx);
        
        // Re-render paper
        DrawerController.renderToPaper();
        
        // Find the updated word element and refresh inspector data
        const wordStack = document.querySelector(`.word-stack[data-line-index="${lineIndex}"][data-word-index="${wordIndex}"]`);
        if (wordStack) {
          this.currentWord = {
            ...this.currentWord,
            syllables: JSON.parse(wordStack.dataset.syllables || '[]'),
            ipa: wordStack.dataset.ipa
          };
          this.updateInspector();
        }
        
        // Prompt for attribution (scholarly act)
        if (this.inspectorElements.stressSourceRow) {
          this.inspectorElements.stressSourceRow.classList.remove('pending-attribution');
          void this.inspectorElements.stressSourceRow.offsetWidth;
          this.inspectorElements.stressSourceRow.classList.add('pending-attribution');
        }
      },
      
      // ========================================
      // PHASE 4B: SYLLABLE BOUNDARY DRAGGING
      // Distance-on-release disambiguation:
      // - <10px = tap = reassign stress
      // - 10-40px = hesitation = silent cancel
      // - >40px horizontal = drag = shed consonant
      // ========================================
      
      _setupDragHandlers() {
        const container = this.inspectorElements.syllableDisplay;
        if (!container) return;
        
        const CLICK_THRESHOLD = 10;   // px - absorbs normal jitter
        const DRAG_THRESHOLD = 40;    // px - committed horizontal drag
        
        const handlePointerDown = (e) => {
          const btn = e.target.closest('.syllable-btn');
          if (!btn || btn.disabled) return;
          
          // Only handle primary button (left click / single touch)
          if (e.button !== undefined && e.button !== 0) return;
          
          // Get pointer position (mouse or touch)
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          
          this._dragState = {
            startX: clientX,
            startY: clientY,
            syllableIdx: parseInt(btn.dataset.syllableIndex, 10),
            button: btn
          };
          
          // Prevent text selection during potential drag
          e.preventDefault();
        };
        
        const handlePointerMove = (e) => {
          if (!this._dragState) return;
          
          // Cursor feedback when exiting click zone
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const dx = Math.abs(clientX - this._dragState.startX);
          
          if (dx > CLICK_THRESHOLD) {
            this._dragState.button.style.cursor = 'grabbing';
          }
        };
        
        const handlePointerUp = (e) => {
          if (!this._dragState) return;
          
          const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
          const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
          
          const dx = clientX - this._dragState.startX;
          const dy = clientY - this._dragState.startY;
          const distance = Math.abs(dx);
          
          // Reset cursor
          this._dragState.button.style.cursor = '';
          
          if (distance < CLICK_THRESHOLD) {
            // CASE 1: Clean tap/click → reassign stress
            this.handleStressChange(this._dragState.syllableIdx);
          } 
          else if (distance >= DRAG_THRESHOLD && Math.abs(dy) < 20) {
            // CASE 2: Committed horizontal drag → shed consonant
            const direction = dx > 0 ? 'right' : 'left';
            this._attemptConsonantShed(this._dragState.syllableIdx, direction);
          }
          // CASE 3: Dead zone (10-40px) or vertical movement → silent cancel
          
          this._dragState = null;
        };
        
        // Mouse events
        container.addEventListener('mousedown', handlePointerDown);
        document.addEventListener('mousemove', handlePointerMove);
        document.addEventListener('mouseup', handlePointerUp);
        
        // Touch events (not passive because we preventDefault in pointerdown)
        container.addEventListener('touchstart', handlePointerDown, { passive: false });
        document.addEventListener('touchmove', handlePointerMove, { passive: true });
        document.addEventListener('touchend', handlePointerUp);
        
        // Phase 4D: Keyboard navigation for syllable buttons
        container.addEventListener('keydown', (e) => {
          const btn = e.target.closest('.syllable-btn');
          if (!btn) return;
          
          const buttons = [...container.querySelectorAll('.syllable-btn:not([disabled])')];
          const currentIdx = buttons.indexOf(btn);
          
          if (e.key === 'ArrowRight') {
            e.preventDefault();
            const nextIdx = Math.min(currentIdx + 1, buttons.length - 1);
            buttons[nextIdx]?.focus();
          } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            const prevIdx = Math.max(currentIdx - 1, 0);
            buttons[prevIdx]?.focus();
          } else if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            // Activate stress change (same as click)
            if (!btn.disabled) {
              const syllableIdx = parseInt(btn.dataset.syllableIndex, 10);
              this.handleStressChange(syllableIdx);
            }
          }
        });
      },
      
      /**
       * Attempt to shed a consonant from syllable in given direction
       * Uses BoundaryStack for display-only boundary adjustments
       */
      _attemptConsonantShed(syllableIdx, direction) {
        if (!this.currentWord) return;
        
        // Guard: prevent overlapping animations
        if (this._animationInProgress) return;
        
        const syllables = this.currentWord.syllables;
        const syllableCount = syllables.length;
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        
        // Clamp check: can't shed left from first syllable or right from last
        if (direction === 'left' && syllableIdx === 0) {
          this._flashInvalid(syllableIdx);
          return;
        }
        if (direction === 'right' && syllableIdx === syllableCount - 1) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // Get current syllable's tokens
        const displaySyllables = BoundaryStack.applyOffsets(wordId, syllables);
        const currentSyl = displaySyllables[syllableIdx];
        const tokens = IpaTokenizer.tokenize(currentSyl.ipa);
        const segments = IpaTokenizer.parseSegments(tokens);
        
        // Check if we can shed in this direction
        let canShed = false;
        let consonantToShed = null;
        
        if (direction === 'left') {
          // Shed leftmost onset consonant to previous syllable's coda
          if (segments.onset.length > 0) {
            canShed = true;
            consonantToShed = segments.onset[0].symbol;
          }
        } else {
          // Shed rightmost coda consonant to next syllable's onset
          if (segments.coda.length > 0) {
            canShed = true;
            consonantToShed = segments.coda[segments.coda.length - 1].symbol;
          }
        }
        
        if (!canShed) {
          this._flashInvalid(syllableIdx);
          return;
        }
        
        // Get button positions for animation
        const sourceBtn = this.inspectorElements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        const targetIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx + 1;
        const targetBtn = this.inspectorElements.syllableDisplay.querySelector(`[data-syllable-index="${targetIdx}"]`);
        
        if (sourceBtn && targetBtn) {
          // Animate the ghost consonant
          this._animateConsonantGhost(consonantToShed, sourceBtn, targetBtn, direction, () => {
            // Shift the boundary after animation completes
            const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
            const shiftDir = direction === 'left' ? 'left' : 'right';
            BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
            
            // Update display (Cycle 4B-3)
            this._updateSyllableDisplay();
            this._updateCustomizedState();
          });
        } else {
          // Fallback: no animation, just update
          const boundaryIdx = direction === 'left' ? syllableIdx - 1 : syllableIdx;
          const shiftDir = direction === 'left' ? 'left' : 'right';
          BoundaryStack.shiftBoundary(wordId, boundaryIdx, shiftDir, syllableCount);
          this._updateSyllableDisplay();
          this._updateCustomizedState();
        }
      },
      
      /**
       * Animate a ghost consonant from source to target button
       */
      _animateConsonantGhost(consonant, sourceBtn, targetBtn, direction, onComplete) {
        // Set animation lock
        this._animationInProgress = true;
        
        // Get positions
        const sourceRect = sourceBtn.getBoundingClientRect();
        const targetRect = targetBtn.getBoundingClientRect();
        
        // Calculate start and end positions
        const startX = direction === 'left' 
          ? sourceRect.left 
          : sourceRect.right - 20;
        const startY = sourceRect.top + sourceRect.height / 2 - 15;
        
        const endX = direction === 'left'
          ? targetRect.right - 20
          : targetRect.left;
        const endY = targetRect.top + targetRect.height / 2 - 15;
        
        // Create ghost element
        const ghost = document.createElement('div');
        ghost.className = 'consonant-ghost';
        ghost.textContent = consonant;
        ghost.style.left = `${startX}px`;
        ghost.style.top = `${startY}px`;
        document.body.appendChild(ghost);
        this._ghostElement = ghost;
        
        // Dim the source button
        sourceBtn.classList.add('dragging');
        
        // Highlight target button
        targetBtn.classList.add('drag-target');
        
        // Trigger animation after a frame (to ensure initial position is set)
        requestAnimationFrame(() => {
          ghost.style.transition = 'left 0.25s ease-out, top 0.25s ease-out';
          ghost.style.left = `${endX}px`;
          ghost.style.top = `${endY}px`;
          ghost.classList.add('valid');
        });
        
        // Cleanup and callback after animation
        setTimeout(() => {
          sourceBtn.classList.remove('dragging');
          targetBtn.classList.remove('drag-target');
          this._cleanupGhost();
          this._animationInProgress = false;
          onComplete();
        }, 260);
      },
      
      /**
       * Flash invalid feedback on syllable button
       */
      _flashInvalid(syllableIdx) {
        const btn = this.inspectorElements.syllableDisplay.querySelector(`[data-syllable-index="${syllableIdx}"]`);
        if (btn) {
          btn.classList.add('drag-invalid');
          setTimeout(() => btn.classList.remove('drag-invalid'), 300);
        }
      },
      
      /**
       * Clean up ghost element
       */
      _cleanupGhost() {
        if (this._ghostElement) {
          this._ghostElement.remove();
          this._ghostElement = null;
        }
      },
      
      /**
       * Update syllable button display with boundary offsets applied
       * Also syncs the word stack IPA on the paper and re-renders the ribbon
       */
      _updateSyllableDisplay() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const originalSyllables = this.currentWord.syllables;
        const displaySyllables = BoundaryStack.applyOffsets(wordId, originalSyllables);
        
        // Re-render buttons with display syllables
        const hasYo = this.currentWord.hasYo === 'true' || this.currentWord.hasYo === true;
        const syllableCount = displaySyllables.length;
        const buttonsDisabled = hasYo && syllableCount > 1;
        
        this.inspectorElements.syllableDisplay.innerHTML = displaySyllables.map((syl, idx) => 
          `<button class="syllable-btn ${syl.isStressed ? 'stressed' : ''} ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}" 
                   data-syllable-index="${idx}" 
                   ${buttonsDisabled && !syl.isStressed ? 'disabled' : ''}>
            ${syl.isStressed ? 'ˈ' + syl.ipa : syl.ipa}
          </button>`
        ).join('');
        
        // Sync word stack IPA in main document
        const wordStack = document.querySelector(
          `.word-stack[data-line-index="${this.currentWord.lineIndex}"][data-word-index="${this.currentWord.wordIndex}"]`
        );
        if (wordStack) {
          const ipaSpan = wordStack.querySelector('.ipa');
          if (ipaSpan) {
            // Build display IPA with stress marks and spaces
            let displayIPA = displaySyllables.map((syl, idx) => {
              return syl.isStressed && displaySyllables.length > 1 ? 'ˈ' + syl.ipa : syl.ipa;
            }).join(' ');
            
            // Preserve clitic tie bars
            const isProclitic = this.currentWord.isProclitic === 'true' || this.currentWord.isProclitic === true;
            const isEnclitic = this.currentWord.isEnclitic === 'true' || this.currentWord.isEnclitic === true;
            if (isProclitic) {
              displayIPA = displayIPA + '‿';
            } else if (isEnclitic) {
              displayIPA = '‿' + displayIPA;
            }
            
            ipaSpan.textContent = displayIPA;
          }
        }
        
        // Re-render ribbon with updated syllable groupings
        if (this.inspectorElements.ribbon && typeof Popup !== 'undefined') {
          Popup.renderRibbon(this.currentWord, this.inspectorElements.ribbon);
        }
      },
      
      /**
       * Update customized state: show/hide reset button based on boundary modifications
       */
      _updateCustomizedState() {
        if (!this.currentWord) return;
        
        const wordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
        const hasCustom = BoundaryStack.hasCustomBoundaries(wordId);
        
        // Update header styling
        this.inspectorElements.syllableHeader?.classList.toggle('customized', hasCustom);
        
        // Show/hide the reset button
        if (this.inspectorElements.boundaryResetBtn) {
          this.inspectorElements.boundaryResetBtn.style.display = hasCustom ? 'inline-block' : 'none';
        }
        
        // Set up reset button click handler (only once)
        if (!this._resetBtnHandler && this.inspectorElements.boundaryResetBtn) {
          this._resetBtnHandler = (e) => {
            e.stopPropagation();
            if (!this.currentWord) return;
            const currentWordId = `${this.currentWord.lineIndex}-${this.currentWord.wordIndex}`;
            if (BoundaryStack.hasCustomBoundaries(currentWordId)) {
              BoundaryStack.reset(currentWordId);
              this._updateSyllableDisplay();
              this._updateCustomizedState();
              this._pulseAllConsonants();
            }
          };
          this.inspectorElements.boundaryResetBtn.addEventListener('click', this._resetBtnHandler);
        }
      },
      
      /**
       * Pulse animation when resetting to default boundaries
       */
      _pulseAllConsonants() {
        const buttons = this.inspectorElements.syllableDisplay.querySelectorAll('.syllable-btn');
        buttons.forEach(btn => {
          btn.style.transition = 'transform 0.2s ease-out';
          btn.style.transform = 'scale(1.05)';
          setTimeout(() => {
            btn.style.transform = 'scale(1)';
          }, 200);
        });
      },
      
      /**
       * Phase 4C: Focus first interactive element based on mode
       * Root: textarea or first input
       * Inspect: back button
       */
      _focusFirstElement(mode) {
        if (!this.drawer) return;
        
        let target;
        if (mode === 'root') {
          // Focus textarea first, then fall back to any input
          target = this.drawer.querySelector('.drawer-root textarea, .drawer-root input');
        } else {
          // Focus back button in inspect mode
          target = this.inspectorElements.backBtn;
        }
        
        target?.focus();
      },
      
      /**
       * Phase 5C: Set up swipe-to-dismiss for mobile bottom sheet
       * Only active when viewport ≤600px
       */
      _setupSwipeToDismiss() {
        const dragHandle = document.querySelector('.drawer-drag-handle');
        if (!dragHandle) return;
        
        let startY = 0;
        let currentY = 0;
        let isDragging = false;
        
        const handleTouchStart = (e) => {
          // Only on mobile
          if (window.innerWidth > 600) return;
          if (!this.isOpen) return;
          
          startY = e.touches[0].clientY;
          currentY = startY;
          isDragging = true;
          this.drawer.style.transition = 'none';
        };
        
        const handleTouchMove = (e) => {
          if (!isDragging) return;
          
          currentY = e.touches[0].clientY;
          const deltaY = currentY - startY;
          
          // Only allow dragging down (positive deltaY)
          if (deltaY > 0) {
            this.drawer.style.transform = `translateY(${deltaY}px)`;
          }
        };
        
        const handleTouchEnd = () => {
          if (!isDragging) return;
          isDragging = false;
          
          const deltaY = currentY - startY;
          this.drawer.style.transition = '';
          
          // If dragged more than 100px down, close the drawer
          if (deltaY > 100) {
            this.close();
          } else {
            // Snap back
            this.drawer.style.transform = '';
          }
        };
        
        dragHandle.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: true });
        document.addEventListener('touchend', handleTouchEnd);
      },
      
      /**
       * Phase 5C: Viewport resize state synchronization
       * Maintains drawer state when crossing breakpoints
       */
      _setupViewportListener() {
        const mobileQuery = window.matchMedia('(max-width: 600px)');
        const tabletQuery = window.matchMedia('(min-width: 601px) and (max-width: 899px)');
        
        const handleResize = () => {
          if (!this.drawer) return;
          
          // Reset any inline transform from swipe gesture
          if (this.isOpen) {
            this.drawer.style.transform = '';
          }
          
          // The CSS handles layout changes automatically
          // This just ensures clean state after resize
        };
        
        mobileQuery.addEventListener('change', handleResize);
        tabletQuery.addEventListener('change', handleResize);
      }
    };

    /* ========================================
       EVENT DELEGATION
       ======================================== */
    document.addEventListener('click', (e) => {
      // Handle word-stack clicks → open drawer in Drill mode (Phase 3A)
      // Popup is now dormant — word inspection happens in drawer
      const wordStack = e.target.closest('.word-stack');
      if (wordStack) {
        const data = {
          wordId: wordStack.dataset.wordId,
          lineIndex: parseInt(wordStack.dataset.lineIndex, 10),
          wordIndex: parseInt(wordStack.dataset.wordIndex, 10),
          ipa: wordStack.dataset.ipa,
          cyrillic: wordStack.dataset.cyrillic,
          gloss: wordStack.dataset.gloss,
          pos: wordStack.dataset.pos,
          lemma: wordStack.dataset.lemma,
          punctuation: wordStack.dataset.punctuation || '',
          syllables: JSON.parse(wordStack.dataset.syllables || '[]'),
          transcriptionLog: JSON.parse(wordStack.dataset.transcriptionLog || '[]'),
          isProclitic: wordStack.dataset.isProclitic,
          isEnclitic: wordStack.dataset.isEnclitic,
          hasYo: wordStack.dataset.hasYo,
          stressSource: wordStack.dataset.stressSource,
          rightBoundary: wordStack.dataset.rightBoundary,
          boundarySource: wordStack.dataset.boundarySource,
          element: wordStack
        };
        
        // PHASE 3A: Popup dormant — route to drawer instead
        // Word inspection now handled entirely by drawer
        
        if (!DrawerState.isOpen) {
          // Drawer closed → open in inspect mode
          DrawerState.open('inspect', data);
        } else {
          // Drawer already open → switch to inspect mode with new word
          DrawerState.switchMode('inspect', data);
        }
        return;
      }

      // Don't process drawer zones if click is inside drawer/input
      if (e.target.closest('.ilya-drawer')) return;
      if (e.target.closest('.input-drawer')) return;

      // Scrim click → close drawer
      if (e.target.closest('.drawer-scrim')) {
        DrawerState.close();
        return;
      }

      // Paper chrome = click inside paper page area but NOT on a word
      // This means clicking white margins, headers, inter-line space on the page
      const page = e.target.closest('.paper-page');
      if (page) {
        DrawerState.open('root');
        return;
      }

      // Everything else (grey aperture background, body) = desk → close
      DrawerState.close();
    });

    // Escape key → close drawer
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && DrawerState.isOpen) {
        DrawerState.close();
        return;
      }
    });
    
    document.addEventListener('keydown', (e) => {
      
      const wordStack = e.target.closest('.word-stack');
      if (!wordStack) return;
      
      const verseLine = wordStack.closest('.verse-line');
      const allWords = [...verseLine.querySelectorAll('.word-stack')];
      const currentIndex = allWords.indexOf(wordStack);
      
      let nextElement = null;
      
      switch (e.key) {
        case 'ArrowRight':
          e.preventDefault();
          if (currentIndex < allWords.length - 1) {
            nextElement = allWords[currentIndex + 1];
          }
          break;
          
        case 'ArrowLeft':
          e.preventDefault();
          if (currentIndex > 0) {
            nextElement = allWords[currentIndex - 1];
          }
          break;
          
        case 'ArrowDown':
          e.preventDefault();
          const nextVerse = verseLine.nextElementSibling;
          if (nextVerse && nextVerse.classList.contains('verse-line')) {
            const nextWords = [...nextVerse.querySelectorAll('.word-stack')];
            nextElement = nextWords[Math.min(currentIndex, nextWords.length - 1)];
          }
          break;
          
        case 'ArrowUp':
          e.preventDefault();
          const prevVerse = verseLine.previousElementSibling;
          if (prevVerse && prevVerse.classList.contains('verse-line')) {
            const prevWords = [...prevVerse.querySelectorAll('.word-stack')];
            nextElement = prevWords[Math.min(currentIndex, prevWords.length - 1)];
          }
          break;
          
        case 'Enter':
        case ' ':
          e.preventDefault();
          wordStack.click();
          return;
      }
      
      if (nextElement) {
        nextElement.focus();
      }
    });

    /* ========================================
       INITIALIZATION
       ======================================== */
    document.addEventListener('DOMContentLoaded', () => {
      DrawerState.init();
      DrawerController.init();
      TabController.init();
      DashboardController.init();
      ProfileController.init();
      DocumentController.init();
      // Popup.init();  // REMOVED Phase 3E - popup UI fully replaced by drawer

      // DrawerBridge REMOVED in Phase 2C - DrawerController now uses left drawer directly

      // ========================================
      // PAPER GLOSS REFRESH (v6.0.54)
      // Re-renders all paper-surface glosses in currentGlossLanguage
      // without re-transcription. Called by pill handler on toggle.
      // ========================================
      function refreshPaperGlosses() {
        const wordStacks = document.querySelectorAll('.word-stack');
        wordStacks.forEach(stack => {
          const glossSpan = stack.querySelector('.gloss');
          if (!glossSpan) return;

          const isClitic = stack.dataset.isProclitic === 'true' || stack.dataset.isEnclitic === 'true';
          const cyrillic = stack.dataset.cyrillic || '';
          let newGloss = '';

          if (isClitic) {
            const cliticEntry = GraysonEngine.cliticData.get(cyrillic.toLowerCase());
            newGloss = extractGloss(cliticEntry?.gloss);
          } else {
            const lineIdx = parseInt(stack.dataset.lineIndex, 10);
            const wordIdx = parseInt(stack.dataset.wordIndex, 10);
            const wordData = DocumentState.lines[lineIdx]?.[wordIdx];
            if (wordData) {
              newGloss = formatGlossForDisplay(wordData.gloss, wordData.pos, wordData.lemma, cyrillic);
            }
          }

          glossSpan.textContent = newGloss;
          stack.dataset.gloss = newGloss;
        });
      }

      // ========================================
      // LANGUAGE PILL (v6.0.51, relocated v6.0.52)
      // Unified segmented pill — Root pill sets language only,
      // Drill pill swaps display language in-place
      // ========================================
      function initLangPill(pillElement, mode) {
        if (!pillElement) return;
        
        const options = pillElement.querySelectorAll('.lang-option');
        
        options.forEach(option => {
          option.addEventListener('click', () => {
            const newLang = option.dataset.lang;
            if (newLang === currentGlossLanguage) return;
            
            // Update global state
            currentGlossLanguage = newLang;
            
            // Update ALL pills to stay in sync (immediate — header stays still)
            document.querySelectorAll('.lang-toggle-pill').forEach(pill => {
              pill.dataset.lang = newLang;
              pill.querySelectorAll('.lang-option').forEach(opt => {
                const isActive = opt.dataset.lang === newLang;
                opt.classList.toggle('active', isActive);
                opt.setAttribute('aria-checked', isActive);
              });
            });
            
            // Breath animation (v6.0.54 — Kimi spec: 150ms out, 250ms in)
            // Targets: drawer-body (Root), inspector-body (Drill), paper-stack (Paper)
            const drawerBody = document.querySelector('.drawer-body');
            const inspectorBody = document.querySelector('.inspector-body');
            const paperStack = document.getElementById('paperStack');
            const breathTargets = [drawerBody, inspectorBody, paperStack].filter(Boolean);
            
            // Phase 1: Breathe out (150ms)
            breathTargets.forEach(el => {
              el.classList.remove('breath-in');
              el.classList.add('breath-out');
            });
            
            // Phase 2: At midpoint, swap content
            setTimeout(() => {
              setUILanguage(newLang);
              
              // Full re-render: glosses, verify badges, and footer attribution (v6.0.54)
              if (DocumentState?.lines?.length > 0) {
                DrawerController.renderToPaper();
              }
              
              if (mode === 'drill') {
                const word = DrawerState.currentWord;
                if (word) {
                  const docWord = DocumentState.lines[word.lineIndex]?.[word.wordIndex];
                  if (docWord) {
                    word.gloss = extractGloss(docWord.gloss);
                  }
                  
                  // Save expanded ribbon state before re-render
                  const ribbon = document.getElementById('inspectorRibbon');
                  const expandedRows = [];
                  const expandedClusters = [];
                  if (ribbon) {
                    ribbon.querySelectorAll('.phoneme-row').forEach((row, idx) => {
                      if (row.classList.contains('expanded')) expandedRows.push(idx);
                    });
                    ribbon.querySelectorAll('.cluster-group').forEach((grp, idx) => {
                      if (grp.classList.contains('expanded')) expandedClusters.push(idx);
                    });
                  }
                  
                  DrawerState.updateInspector();
                  
                  // Restore expanded rows after re-render
                  if (ribbon && (expandedRows.length || expandedClusters.length)) {
                    const rows = ribbon.querySelectorAll('.phoneme-row');
                    expandedRows.forEach(idx => {
                      if (rows[idx]) rows[idx].classList.add('expanded');
                    });
                    const clusters = ribbon.querySelectorAll('.cluster-group');
                    expandedClusters.forEach(idx => {
                      if (clusters[idx]) clusters[idx].classList.add('expanded');
                    });
                  }
                }
              }
              
              // Phase 3: Breathe in (250ms)
              breathTargets.forEach(el => {
                el.classList.remove('breath-out');
                el.classList.add('breath-in');
              });
              
              // Clean up animation classes
              setTimeout(() => {
                breathTargets.forEach(el => el.classList.remove('breath-in'));
              }, 250);
              
            }, 150);
            
            console.log(`Gloss language: ${newLang === 'fr' ? 'Français' : 'English'}`);
          });
        });
      }
      
      // Initialize both pills
      initLangPill(document.getElementById('rootLangPill'), 'root');
      initLangPill(document.getElementById('drillLangPill'), 'drill');
      
      // ========================================
      // TRANSCRIBE BUTTON (v6.0.52)
      // Dedicated action button — label swaps with language pill
      // ========================================
      const transcribeBtn = document.getElementById('drawerTranscribeBtn');
      if (transcribeBtn) {
        transcribeBtn.addEventListener('click', () => {
          const hasText = DrawerController.textInput?.value?.trim().length > 0;
          if (hasText) {
            DrawerController.transcribe();
          } else {
            DrawerController.renderToPaper();
          }
        });
      }
      
      // Render empty title page on load
      DrawerController.renderToPaper();
    });

    /* ========================================
       GOLDEN-MASTER TESTS
       Run with: runGoldenTests() in browser console
       ======================================== */
    
    // Wrapper function for GraysonEngine.transcribe
    function processWord(word, stress, options = {}) {
      const isClitic = options.isClitic || stress === -1;
      return GraysonEngine.transcribe(word, stress, isClitic);
    }

    const GOLDEN_TESTS = {
      'Clitics and Prepositions': [
        { word: 'во', stress: -1, expected: 'vɑ', note: 'Voweled preposition, unstressed' },
        { word: 'ко', stress: -1, expected: 'kɑ', note: 'Voweled preposition, unstressed' },
        { word: 'со', stress: -1, expected: 'sɑ', note: 'Voweled preposition, unstressed' },
        { word: 'не', stress: -1, expected: 'ɲɪ', note: 'Particle, unstressed' },
        { word: 'ни', stress: -1, expected: 'ɲi', note: 'Particle, unstressed' },
      ],
      'Stressed Vowels': [
        { word: 'мама', stress: 0, expected: 'mɑ mɑ', note: 'Stressed а → ɑ' },
        { word: 'папа', stress: 0, expected: 'pɑ pɑ', note: 'Stressed а → ɑ' },
        { word: 'дом', stress: 0, expected: 'dom', note: 'Stressed о → o' },
        { word: 'ночь', stress: 0, expected: 'notʃʲ', note: 'Stressed о → o, ч palatalized' },
        { word: 'сон', stress: 0, expected: 'son', note: 'Stressed о → o' },
        { word: 'лес', stress: 0, expected: 'lʲɛs', note: 'Stressed е → ɛ' },
        { word: 'мир', stress: 0, expected: 'mʲir', note: 'Stressed и → i' },
        { word: 'сын', stress: 0, expected: 'sɨn', note: 'Stressed ы → ɨ' },
        { word: 'дух', stress: 0, expected: 'dux', note: 'Stressed у → u' },
      ],
      'Vowel Reduction - Akanye': [
        { word: 'вода', stress: 1, expected: 'vɑ dɑ', note: 'Immediate pretonic о → ɑ' },
        { word: 'молоко', stress: 2, expected: 'mʌ ɫɑ ko', note: 'Remote о → ʌ, immediate → ɑ' },
        { word: 'хорошо', stress: 2, expected: 'xʌ rɑ ʃo', note: 'Remote о → ʌ, immediate → ɑ' },
        { word: 'голова', stress: 2, expected: 'ɡʌ ɫɑ vɑ', note: 'Remote о → ʌ, immediate → ɑ' },
      ],
      'Vowel Reduction - Ikanye': [
        { word: 'весна', stress: 1, expected: 'vʲɪ snɑ', note: 'Unstressed е → ɪ' },
        { word: 'земля', stress: 1, expected: 'zʲɪ mlʲɑ', note: 'Unstressed е → ɪ' },
      ],
      'И Never Reduces': [
        { word: 'игра', stress: 1, expected: 'i ɡrɑ', note: 'Unstressed и stays i' },
        { word: 'книга', stress: 0, expected: 'kɲi ɡɑ', note: 'Unstressed и stays i' },
      ],
      'Palatal Nasal': [
        { word: 'няня', stress: 0, expected: 'ɲa ɲɑ', note: 'н before я → ɲ' },
        { word: 'конь', stress: 0, expected: 'koɲ', note: 'нь → ɲ' },
        { word: 'день', stress: 0, expected: 'dʲeɲ', note: 'Interpalatal е → e, нь → ɲ' },
        { word: 'очень', stress: 0, expected: 'otʃʲiɲ', note: 'Unstressed interpalatal е → i' },
        { word: 'моей', stress: 1, expected: 'mɑ jej', note: 'Interpalatal stressed е → /e/ (j-glide + е + й)' },
      ],
      'Hard vs Soft Л': [
        { word: 'был', stress: 0, expected: 'bɨɫ', note: 'Hard л → ɫ' },
        { word: 'была', stress: 1, expected: 'bɨ ɫɑ', note: 'Hard л → ɫ' },
        { word: 'люди', stress: 0, expected: 'lʲu dʲi', note: 'Soft л → lʲ' },
        { word: 'любовь', stress: 1, expected: 'lʲu bofʲ', note: 'Soft л → lʲ' },
      ],
      'Voicing Assimilation - Devoicing': [
        { word: 'трубка', stress: 0, expected: 'trup kɑ', note: 'б→п before к' },
        { word: 'обход', stress: 1, expected: 'ɑp xot', note: 'б→п before х' },
        { word: 'ногти', stress: 0, expected: 'nok tʲi', note: 'г→к before т' },
        { word: 'водка', stress: 0, expected: 'vot kɑ', note: 'д→т before к' },
        { word: 'подход', stress: 1, expected: 'pɑt xot', note: 'д→т before х' },
        { word: 'ложка', stress: 0, expected: 'ɫoʃ kɑ', note: 'ж→ш before к' },
        { word: 'лезть', stress: 0, expected: 'lʲesʲtʲ', note: 'Interpalatal е → /e/, з→с before т' },
      ],
      'Voicing Assimilation - Voicing': [
        { word: 'вокзал', stress: 1, expected: 'vɑɡ zɑɫ', note: 'к→г before з' },
        { word: 'сбор', stress: 0, expected: 'zbor', note: 'с→з before б' },
        { word: 'просьба', stress: 0, expected: 'prozʲ bɑ', note: 'с→з before б' },
        { word: 'отбой', stress: 1, expected: 'ɑd boj', note: 'т→д before б' },
      ],
      'Special Clusters': [
        { word: 'что', stress: 0, expected: 'ʃto', note: 'чт→ʃt' },
        { word: 'конечно', stress: 1, expected: 'kɑ ɲɛ ʃnʌ', note: 'чн→ʃn' },
        { word: 'скучно', stress: 0, expected: 'sku ʃnʌ', note: 'чн→ʃn' },
      ],
      'Reflexive Verbs': [
        { word: 'боится', stress: 1, expected: 'bɑ i tːsʌ', note: '-тся→tːsʌ' },
        { word: 'купаться', stress: 1, expected: 'ku pɑ tːsʌ', note: '-ться→tːsʌ' },
      ],
      'Exception Words': [
        { word: 'счастье', stress: 0, expected: 'ʃʲʃʲɑ sʲtʲjɪ', note: 'сч→ʃʲʃʲ' },
        { word: 'сердце', stress: 0, expected: 'sʲɛr tsɨ', note: 'рдц→рц, д silent' },
        { word: 'солнце', stress: 0, expected: 'son tsɨ', note: 'лнц→нц, л silent' },
        { word: 'здравствуй', stress: 0, expected: 'zdrɑ stvuj', note: 'вств→ств, first в silent' },
        { word: 'чувство', stress: 0, expected: 'tʃʲu stvʌ', note: 'вств→ств, first в silent' },
      ],
      'Ё Stress Rule': [
        { word: 'ёлка', stress: 0, expected: 'joɫ kɑ', note: 'ё always stressed' },
        { word: 'моё', stress: 1, expected: 'mɑ jo', note: 'ё always stressed' },
        { word: 'её', stress: 1, expected: 'ji jo', note: 'ё always stressed' },
      ],
      'Pushkin/Tchaikovsky Vocabulary': [
        { word: 'храм', stress: 0, expected: 'xrɑm', note: 'Monosyllable' },
        { word: 'брожу', stress: 1, expected: 'brɑ ʒu', note: 'Common verb' },
        { word: 'улиц', stress: 0, expected: 'u lʲits', note: 'Genitive plural' },
        { word: 'шумных', stress: 0, expected: 'ʃum nɨx', note: 'Adjective genitive plural' },
      ],
    };

    function normalizeForComparison(ipa) {
      return ipa
        .replace(/\s+/g, '')
        .replace(/ˈ/g, '')
        .replace(/ˌ/g, '')
        .replace(/[\/\[\]]/g, '')
        .replace(/\./g, '');
    }

    function runGoldenTests() {
      let totalPassed = 0;
      let totalFailed = 0;
      const failures = [];

      console.log('═══════════════════════════════════════════════════════════');
      console.log('<em>Ilya</em> Golden-Master Tests');
      console.log('═══════════════════════════════════════════════════════════');

      for (const [category, tests] of Object.entries(GOLDEN_TESTS)) {
        console.log(`\n▶ ${category}`);
        for (const test of tests) {
          const result = processWord(test.word, test.stress);
          // Use full-word IPA (includes cross-syllable assimilation) not syllable concatenation
          const actual = result.ipa.replace(/ˈ/g, ' ˈ').replace(/^\s+/, '').trim();
          const syllableIpa = result.syllables.map(s => s.ipa).join(' ');

          const normalizedActual = normalizeForComparison(actual);
          const normalizedExpected = normalizeForComparison(test.expected);
          const passed = normalizedActual === normalizedExpected;

          if (passed) {
            totalPassed++;
            console.log(`  ✅ ${test.word}: /${actual}/`);
          } else {
            totalFailed++;
            failures.push({ word: test.word, expected: test.expected, actual, note: test.note });
            console.log(`  ❌ ${test.word}: got /${actual}/, expected /${test.expected}/`);
            if (actual !== syllableIpa) {
              console.log(`     (syllables: /${syllableIpa}/)`);
            }
            console.log(`     ${test.note}`);
          }
        }
      }

      console.log('\n═══════════════════════════════════════════════════════════');
      const total = totalPassed + totalFailed;
      const passRate = ((totalPassed / total) * 100).toFixed(1);
      if (totalFailed === 0) {
        console.log(`🎉 ALL TESTS PASSED: ${totalPassed}/${total} (${passRate}%)`);
      } else {
        console.log(`⚠️  ${totalPassed}/${total} passed (${passRate}%)`);
        console.log(`\nFailed tests:`);
        failures.forEach(f => {
          console.log(`  - ${f.word}: expected /${f.expected}/, got /${f.actual}/`);
        });
      }
      console.log('═══════════════════════════════════════════════════════════');

      return { passed: totalPassed, failed: totalFailed, total, failures };
    }

    function testWord(word, stress = 0) {
      const result = processWord(word, stress);
      const ipa = result.syllables.map(s => s.ipa).join(' ');
      console.log(`${word} (stress: ${stress}) → /${ipa}/`);
      return result;
    }

    // Expose for browser console
    window.runGoldenTests = runGoldenTests;
    window.testWord = testWord;
    window.GOLDEN_TESTS = GOLDEN_TESTS;
    
    /**
     * DICTIONARY AUDIT DIAGNOSTIC (v5.11.20)
     * Usage: auditDictionary() to audit current document
     *        auditDictionary("Брожу ли я вдоль улиц шумных") to audit custom text
     * 
     * Returns coverage statistics and categorized misses
     */
    window.auditDictionary = function(text) {
      // Use provided text or current document
      const corpus = text || (DocumentState.lines || []).map(l => l.text).join('\n');
      
      if (!corpus) {
        console.log('No text to audit. Paste Russian text into the input area first, or pass text as argument.');
        return;
      }
      
      // Extract words (Cyrillic only, normalized)
      const wordPattern = /[а-яёА-ЯЁ]+/g;
      const rawWords = corpus.match(wordPattern) || [];
      
      // Count word frequencies
      const wordFreq = new Map();
      rawWords.forEach(w => {
        const lower = w.toLowerCase();
        wordFreq.set(lower, (wordFreq.get(lower) || 0) + 1);
      });
      
      // Categorize each unique word
      const results = {
        found: [],
        notInDictionary: [],
        isClitic: [],
        total: wordFreq.size,
        totalTokens: rawWords.length
      };
      
      wordFreq.forEach((freq, word) => {
        // Check if it's a clitic (handled separately)
        if (GraysonEngine.proclitics.has(word) || GraysonEngine.enclitics.has(word)) {
          results.isClitic.push({ word, freq });
          return;
        }
        
        // Check curated glosses
        if (CURATED_GLOSSES.has(word)) {
          results.found.push({ word, freq, source: 'curated' });
          return;
        }
        
        // Check main dictionary
        if (typeof window.russianDictionary !== 'undefined' && window.russianDictionary.has(word)) {
          results.found.push({ word, freq, source: 'dictionary' });
          return;
        }
        
        // Not found
        results.notInDictionary.push({ word, freq });
      });
      
      // Sort misses by frequency (highest first)
      results.notInDictionary.sort((a, b) => b.freq - a.freq);
      
      // Calculate coverage
      const foundCount = results.found.length + results.isClitic.length;
      const coverage = ((foundCount / results.total) * 100).toFixed(1);
      const tokenCoverage = ((results.found.reduce((sum, w) => sum + w.freq, 0) + 
                              results.isClitic.reduce((sum, w) => sum + w.freq, 0)) / 
                             results.totalTokens * 100).toFixed(1);
      
      // Format report
      console.log('%c═══════════════════════════════════════', 'color: #667eea');
      console.log('%c ILYA DICTIONARY AUDIT', 'font-weight: bold; font-size: 14px; color: #667eea');
      console.log('%c═══════════════════════════════════════', 'color: #667eea');
      console.log(`\nUnique words: ${results.total}`);
      console.log(`Total tokens: ${results.totalTokens}`);
      console.log(`\n%cCoverage: ${foundCount}/${results.total} unique words (${coverage}%)`, 'font-weight: bold');
      console.log(`%cToken coverage: ${tokenCoverage}% of running text`, 'font-weight: bold');
      
      console.log(`\n%cMisses by type:`, 'font-weight: bold; color: #e53e3e');
      console.log(`  • Not in dictionary: ${results.notInDictionary.length}`);
      console.log(`  • Clitics (handled separately): ${results.isClitic.length}`);
      
      if (results.notInDictionary.length > 0) {
        console.log(`\n%cTop ${Math.min(15, results.notInDictionary.length)} missing words:`, 'font-weight: bold; color: #e53e3e');
        results.notInDictionary.slice(0, 15).forEach((w, i) => {
          console.log(`  ${i + 1}. "${w.word}" (×${w.freq})`);
        });
      }
      
      console.log('%c═══════════════════════════════════════', 'color: #667eea');
      
      // Return raw data for programmatic use
      return {
        coverage: parseFloat(coverage),
        tokenCoverage: parseFloat(tokenCoverage),
        uniqueWords: results.total,
        totalTokens: results.totalTokens,
        found: results.found.length,
        missing: results.notInDictionary,
        clitics: results.isClitic
      };
    };
  </script>

</body>
</html>
